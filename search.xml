<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go Note</title>
      <link href="/2020/02/16/00034/"/>
      <url>/2020/02/16/00034/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/16/cjeO7x4fsUBDSHo.jpg" alt="bing"></p><blockquote><p>文章主要涉及 Go，以及 Gin、Gorm、Thrift 等 Go 框架的知识点，作为快速索引和查缺补漏的笔记。文章主要记录学习工作过程中容易遗忘的知识点，不会覆盖所有知识面。学到什么就记什么，故文章内容比较杂。</p></blockquote><a id="more"></a><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><h3 id="Go-安装"><a href="#Go-安装" class="headerlink" title="Go 安装"></a>Go 安装</h3><p>在 <a href="https://golang.google.cn/" target="_blank" rel="noopener">Go 官网</a> 下载并安装 Go。若使用 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a>，可在 VS Code 中安装 Go 辅助工具。在 VS Code 中按 ctrl + shift + p，输入 go install，全部勾选后按 enter 键即可。</p><h3 id="Go-命令"><a href="#Go-命令" class="headerlink" title="Go 命令"></a>Go 命令</h3><h4 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h4><p>go get 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包，并自动完成编译和安装。go get 具有很多参数：</p><ul><li>-d 只下载不安装</li><li>-f 不让 -u 验证 import 中的每一个都已经获取，对本地 fork 的包特别有用，只有在包含 -u 参数时才有效</li><li>-t 同时下载需要为运行测试所需要的包</li><li>-u 强制使用网络去更新包和它的依赖包</li><li>-v 显示执行的命令</li></ul><h2 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h2><p>Gin 相关知识点可以在 <a href="https://gin-gonic.com/zh-cn/" target="_blank" rel="noopener">官网</a> 查询。</p><h3 id="Gin-安装"><a href="#Gin-安装" class="headerlink" title="Gin 安装"></a>Gin 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/ping"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h2><h3 id="Gorm-安装"><a href="#Gorm-安装" class="headerlink" title="Gorm 安装"></a>Gorm 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/jinzhu/gorm</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/jinzhu/gorm"</span></span><br><span class="line">    _ <span class="string">"github.com/jinzhu/gorm/dialects/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db, err := gorm.Open(<span class="string">"mysql"</span>,</span><br><span class="line">    <span class="string">"root:123456@(localhost)/apathy?charset=utf8&amp;parseTime=True&amp;loc=Local"</span>)</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"mysql connection error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"mysql connection success"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Code </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计</title>
      <link href="/2019/06/20/00033/"/>
      <url>/2019/06/20/00033/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/qo7NdBwcQjkSutD.jpg" alt="BloomingJacaranda_ZH-CN1456780313_1920x1080.jpg"></p><a id="more"></a><h2 id="短-URL-系统"><a href="#短-URL-系统" class="headerlink" title="短 URL 系统"></a>短 URL 系统</h2><blockquote><p><a href="https://hufangyun.com/2017/short-url/" target="_blank" rel="noopener">短网址(short URL)系统的原理及其实现</a></p></blockquote><h2 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h2><blockquote><p><a href="https://www.cnblogs.com/hadley/p/9459740.html" target="_blank" rel="noopener">秒杀系统设计思路</a></p></blockquote><h3 id="前端层设计"><a href="#前端层设计" class="headerlink" title="前端层设计"></a>前端层设计</h3><ol><li>静态秒杀页面：CDN 部署，秒杀前和抢购后将按钮置灰</li><li>倒计时：本地 JS 调用本地时间倒计时，每隔一段时间与服务器 做 SNTP 时钟同步</li></ol><h3 id="站点层设计"><a href="#站点层设计" class="headerlink" title="站点层设计"></a>站点层设计</h3><ol><li>同一个 uid，限制访问频率，做页面缓存</li><li>同一个 item，做页面缓存</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode类型题汇总</title>
      <link href="/2019/06/07/00032/"/>
      <url>/2019/06/07/00032/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/OFXLG59V17RyCY4.jpg" alt="bing"></p><a id="more"></a><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ol><li><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></p></li><li><p><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></p></li><li><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></p></li><li><p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. 求根到叶子节点数字之和</a></p></li><li><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></p></li><li><p><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. 路径总和 III</a></p></li><li><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/" target="_blank" rel="noopener">687. 最长同值路径</a></p></li><li><p><a href="https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/" target="_blank" rel="noopener">988. 从叶结点开始的最小字符串</a></p></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">KMP</a></p></blockquote><ol><li><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现strStr()-KMP</a></p></li><li><p><a href="https://leetcode-cn.com/problems/shortest-palindrome/" target="_blank" rel="noopener">214. 最短回文串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></p></li><li><p><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = getPalindromic(s);</span><br><span class="line">        partitionHelper(s, <span class="number">0</span>, dp, <span class="keyword">new</span> ArrayList&lt;&gt;(), list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partitionHelper</span><span class="params">(String s, <span class="keyword">int</span> curLen,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span>[][] dp, List&lt;String&gt; l, List&lt;List&lt;String&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curLen == s.length()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(l));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = curLen; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[curLen][j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                l.add(s.substring(curLen, j+<span class="number">1</span>));</span><br><span class="line">                partitionHelper(s, j+<span class="number">1</span>, dp, l, list);</span><br><span class="line">                l.remove(l.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[][] getPalindromic(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[][]&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; len-<span class="number">1</span> &amp;&amp; s.charAt(i) == s.charAt(i+<span class="number">1</span>))</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">3</span>; l &lt;= len; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i+l-<span class="number">1</span> &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+l-<span class="number">1</span>;</span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><ol><li><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39.组合总和</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">     List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        backcombinationSum(candidates, <span class="number">0</span>, target, <span class="keyword">new</span> ArrayList&lt;&gt;(), list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backcombinationSum</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> index, <span class="keyword">int</span> target, List&lt;Integer&gt; l, List&lt;List&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(l));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i] &lt;= target) &#123;</span><br><span class="line">                l.add(candidates[i]);</span><br><span class="line">                backcombinationSum(candidates, i, target-candidates[i], l, list);</span><br><span class="line">                l.remove(l.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span>(candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backcombinationSum2(candidates, <span class="number">0</span>, target, <span class="keyword">new</span> ArrayList&lt;&gt;(), list, <span class="keyword">new</span> <span class="keyword">boolean</span>[candidates.length]);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backcombinationSum2</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> index, <span class="keyword">int</span> target,</span></span></span><br><span class="line"><span class="function"><span class="params">     List&lt;Integer&gt; l, List&lt;List&lt;Integer&gt;&gt; list, <span class="keyword">boolean</span>[] vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(l));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>] &amp;&amp; !vis[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i] &lt;= target) &#123;</span><br><span class="line">                l.add(candidates[i]);</span><br><span class="line">                vis[i] = <span class="keyword">true</span>;</span><br><span class="line">                backcombinationSum2(candidates, i+<span class="number">1</span>, target-candidates[i], l, list, vis);</span><br><span class="line">                l.remove(l.size()-<span class="number">1</span>);</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        backpermute(nums, vis, <span class="keyword">new</span> ArrayList&lt;&gt;(), list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backpermute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] vis, List&lt;Integer&gt; l, List&lt;List&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l.size() == nums.length) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(l));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                vis[i] = <span class="keyword">true</span>;</span><br><span class="line">                l.add(nums[i]);</span><br><span class="line">                backpermute(nums, vis, l, list);</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">                l.remove(l.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backpermuteUnique(nums, vis, <span class="keyword">new</span> ArrayList&lt;&gt;(), list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backpermuteUnique</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] vis, List&lt;Integer&gt; l, List&lt;List&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l.size() == nums.length) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(l));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !vis[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vis[i] = <span class="keyword">true</span>;</span><br><span class="line">            l.add(nums[i]);</span><br><span class="line">            backpermuteUnique(nums, vis, l, list);</span><br><span class="line">            vis[i] = <span class="keyword">false</span>;</span><br><span class="line">            l.remove(l.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        combineHelper(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> index, List&lt;Integer&gt; l, List&lt;List&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l.size() == k)</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(l));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt;= n; i++) &#123;</span><br><span class="line">            l.add(i);</span><br><span class="line">            combineHelper(n, k, i+<span class="number">1</span>, l, list);</span><br><span class="line">            l.remove(l.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtracksubset(nums,<span class="number">0</span>,list,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracksubset</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> position,List&lt;Integer&gt; list,List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position;i&lt;nums.length;i++)&#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backtracksubset(nums,i+<span class="number">1</span>,list,res);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backsubsetsWithDup(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), list, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">     <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backsubsetsWithDup</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;Integer&gt; l, List&lt;List&lt;Integer&gt;&gt; list, <span class="keyword">boolean</span>[] vis)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(l));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !vis[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            l.add(nums[i]);</span><br><span class="line">            vis[i] = <span class="keyword">true</span>;</span><br><span class="line">            backsubsetsWithDup(nums, i+<span class="number">1</span>, l, list, vis);</span><br><span class="line">            l.remove(l.size()-<span class="number">1</span>);</span><br><span class="line">            vis[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ol><li><p><a href="https://leetcode-cn.com/problems/matchsticks-to-square/" target="_blank" rel="noopener">473. 火柴拼正方形</a></p></li><li><p><a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener">698. 划分为k个相等的子集</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span>(sum % k != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> average = sum / k;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums[len-<span class="number">1</span>] &gt; average)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; nums[i] == average; i--) &#123;</span><br><span class="line">            vis[i] = <span class="keyword">true</span>;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> subsetHelper(nums, k, <span class="number">0</span>, <span class="number">0</span>, average, vis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">subsetHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> index, <span class="keyword">int</span> curSum, <span class="keyword">int</span> target, <span class="keyword">boolean</span>[] vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(curSum == target)</span><br><span class="line">            <span class="keyword">return</span> subsetHelper(nums, k-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, target, vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="keyword">true</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vis[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(subsetHelper(nums, k, i+<span class="number">1</span>, curSum+nums[i], target, vis) == <span class="keyword">true</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            vis[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2084" target="_blank" rel="noopener">树塔</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shuta</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            nums[i][j] += Math.max(nums[i+<span class="number">1</span>][j], nums[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2018" target="_blank" rel="noopener">母牛的故事</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">muniu</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(year &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> year;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">55</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= year; i++) &#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[year];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>continue…</p></li></ol><h3 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h3><ol><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; min) &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(prices[i]-min &gt; max) &#123;</span><br><span class="line">            max = prices[i]-min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">            max += prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firBuy = Integer.MIN_VALUE, firShell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> senBuy = Integer.MIN_VALUE, senShell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p: prices)&#123;</span><br><span class="line">        firBuy = Math.max(firBuy, -p);</span><br><span class="line">        firShell = Math.max(firShell, firBuy + p);</span><br><span class="line">        senBuy = Math.max(senBuy, firShell - p);</span><br><span class="line">        senShell = Math.max(senShell, senBuy + p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> senShell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">1</span> || prices.length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span>[] shell = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    Arrays.fill(buy, Integer.MIN_VALUE);</span><br><span class="line">    Arrays.fill(shell, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p: prices)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i == <span class="number">0</span>)&#123;</span><br><span class="line">                buy[i] = Math.max(buy[i], -p);</span><br><span class="line">                shell[i] = Math.max(shell[i], buy[i] + p);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                buy[i] = Math.max(buy[i], shell[i-<span class="number">1</span>] - p);</span><br><span class="line">                shell[i] = Math.max(shell[i], buy[i] + p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shell[k-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buy = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        buy = Math.max(buy, sell-prices[i]);</span><br><span class="line">        sell = Math.max(sell, buy + prices[i] -fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[] no = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    sell[<span class="number">0</span>] = no[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        no[i] = sell[i-<span class="number">1</span>];</span><br><span class="line">        sell[i] = Math.max(sell[i-<span class="number">1</span>], buy[i-<span class="number">1</span>]+prices[i]);</span><br><span class="line">        buy[i] = Math.max(buy[i-<span class="number">1</span>], no[i-<span class="number">1</span>]-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sell[len-<span class="number">1</span>], no[len-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ol><li><p><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num1 == <span class="keyword">null</span> || num1.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    <span class="keyword">if</span>(num2 == <span class="keyword">null</span> || num2.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">int</span> i = num1.length()-<span class="number">1</span>, j = num2.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? Integer.valueOf(num1.charAt(i--)-<span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? Integer.valueOf(num2.charAt(j--)-<span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">        sb.append((n1+n2+diff) % <span class="number">10</span>);</span><br><span class="line">        diff = (n1+n2+diff) /<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">mul</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num1 == <span class="keyword">null</span> || num1.length() == <span class="number">0</span> || num2 == <span class="keyword">null</span> || num2.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">char</span> sign1 = num1.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> sign2 = num2.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">if</span>(sign1 == <span class="string">'+'</span> || sign1 == <span class="string">'-'</span>) &#123;</span><br><span class="line">        sign = sign1;</span><br><span class="line">        num1 = num1.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sign2 == <span class="string">'+'</span> || sign2 == <span class="string">'-'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((sign^sign2) != <span class="number">0</span>)</span><br><span class="line">            sign = <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sign = <span class="string">'+'</span>;</span><br><span class="line">        num2 = num2.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = num1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = num2.length();</span><br><span class="line">    <span class="keyword">char</span>[] chars1 = <span class="keyword">new</span> StringBuilder(num1).reverse().toString().toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chars2 = <span class="keyword">new</span> StringBuilder(num2).reverse().toString().toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len1+len2];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            res[i+j] += (<span class="keyword">int</span>)(chars1[i]-<span class="string">'0'</span>) * (<span class="keyword">int</span>)(chars2[j]-<span class="string">'0'</span>); <span class="comment">// +=</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1+len2; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            res[i+<span class="number">1</span>] += res[i]/<span class="number">10</span>;</span><br><span class="line">            res[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> i = res.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">if</span>(sign == <span class="string">'-'</span>)</span><br><span class="line">        sb.insert(<span class="number">0</span>, <span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串相减</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">subtract</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num2 == <span class="keyword">null</span> || num2.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">int</span> len1 = num1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = num2.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断正负</span></span><br><span class="line">    <span class="keyword">boolean</span> isPositive = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(len1 &lt; len2) &#123;</span><br><span class="line">        isPositive = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 == len2) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len1 &amp;&amp; num1.charAt(i) == num2.charAt(i))</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(num1.charAt(i) &lt; num2.charAt(i))</span><br><span class="line">            isPositive = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    <span class="keyword">char</span>[] chars1 = <span class="keyword">new</span> StringBuilder(num1).reverse().toString().toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chars2 = <span class="keyword">new</span> StringBuilder(num2).reverse().toString().toCharArray();</span><br><span class="line">    <span class="keyword">int</span> maxLen = Math.max(len1, len2);</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = i &lt; len1 ? chars1[i]-<span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = i &lt; len2 ? chars2[i]-<span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isPositive)</span><br><span class="line">            res[i] = n1-n2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res[i] = n2-n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            res[i] += <span class="number">10</span>;</span><br><span class="line">            res[i+<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算结果</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> i = maxLen-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; res[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">if</span>(!isPositive)</span><br><span class="line">        sb.insert(<span class="number">0</span>, <span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进制转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str=<span class="string">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">any2ten</span><span class="params">(String num, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    num = <span class="keyword">new</span> StringBuilder(num).reverse().toString();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++) &#123;</span><br><span class="line">        res += str.indexOf(num.charAt(i)+<span class="string">""</span>) * Math.pow(b, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ten2any</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = num % b;</span><br><span class="line">        num /= b;</span><br><span class="line">        sb.append(str.charAt(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth 2.0</title>
      <link href="/2019/05/12/00031/"/>
      <url>/2019/05/12/00031/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/G7qMlOXtsCJAjxT.jpg" alt="Seidenschwanz_ZH-CN7486965726_1920x1080.jpg"></p><a id="more"></a><h2 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><p>OAuth 2.0 是一种授权机制，用来授权第三方应用，获取用户数据。第三方应用如果直接用密码登录服务提供商的服务器会存在风险。OAuth 2.0 使用令牌登录，服务提供商根据令牌的权限范围和有效期，向第三方应用开放用户的资料。</p><h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><ul><li><p><strong>Third-party application</strong>：第三方应用程序，比如第三方网站</p></li><li><p><strong>HTTP service</strong>：HTTP服务提供商，比如微信</p></li><li><p><strong>Resource Owner</strong>：资源所有者，比如用户</p></li><li><p><strong>User Agent</strong>：用户代理，比如浏览器</p></li><li><p><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器</p></li><li><p><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器</p></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2yh8twsrtj20la0bfjre.jpg" alt="pic"></p><ol><li>第三方应用申请授权</li><li>用户同意授权</li><li>第三方应用使用上一步获得的授权，向认证服务器申请令牌</li><li>认证服务器对第三方服务器认证后，颁发令牌</li><li>第三方应用使用令牌，向资源服务器申请获取资源</li><li>资源服务器确认令牌无误，同意第三方应用获得资源</li></ol><h3 id="令牌-amp-密码"><a href="#令牌-amp-密码" class="headerlink" title="令牌 &amp; 密码"></a>令牌 &amp; 密码</h3><ul><li>令牌是短期的，存在有效期，用户无法修改；密码是长期的，用户可以修改</li><li>令牌可以被用户撤销，立即生效</li><li>令牌有权限范围，密码登录享有用户全部权限</li></ul><h3 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h3><p>第三方应用必须获得用户的授权才能获得令牌申请资源，OAuth 2.0 提供了 4 种授权模式。</p><ul><li>授权码模式</li><li>简化模式</li><li>密码模式</li><li>客户端模式</li></ul><p>第三方应用（客户端）申请令牌之前，必须到服务提供商系统备案，拿到客户端 ID 和客户端密钥。没有经过备案的第三方应用无法拿到令牌。</p><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>授权码模式指第三方应用先申请一个授权码，再用该授权码获取令牌。第三方应用服务器使用授权码和用户交互，用户判断是否进行授权；如果用户同意授权，第三方应用服务器再和认证服务器交互，获取令牌。</p><p><img data-src="https://i.loli.net/2019/05/12/5cd7cae050e53.jpg" alt="pic"></p><ol><li><p>第三方应用 A 提供第三方登录跳转链接，用户点击后会跳转到认证服务器 B 网站，授权用户数据给 A</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure></li><li><p>B 要求用户登录并询问用户是否授权。如果用户同意授权，B 网站会跳转回 <code>redirect_uri</code> 指定的路径并传回一个授权码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://a.com/callback?code=AUTHORIZATION_CODE</span><br></pre></td></tr></table></figure></li><li><p>A 网站拿到授权码后，可以在后端向 B 请求令牌</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure></li><li><p>B 网站颁发令牌。具体做法是向 <code>redirect_uri</code> 指定的网址发送一段 <code>json</code> 数据</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"access_token"</span>:<span class="string">"ACCESS_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"token_type"</span>:<span class="string">"bearer"</span>,</span><br><span class="line">  <span class="attr">"expires_in"</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="attr">"refresh_token"</span>:<span class="string">"REFRESH_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>:<span class="string">"read"</span>,</span><br><span class="line">  <span class="attr">"uid"</span>:<span class="number">100101</span>,</span><br><span class="line">  "info":&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>到此，第三方应用程序拿到令牌，可以通过令牌申请用户数据。</p><h4 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h4><p>有些应用是纯前端的，没有后端，无法使用授权码模式。 OAuth 2.0 运行前端直接获取令牌。</p><ol><li><p>A 网站提供第三方登录跳转链接，用户点击后会跳转到认证服务器 B 网站，授权用户数据给 A</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure></li><li><p>B 要求用户登录并询问用户是否授权。如果用户同意授权，B 网站会跳转回 <code>redirect_uri</code> 指定的路径并传回令牌</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://a.com/callback#token=ACCESS_TOKEN</span><br></pre></td></tr></table></figure></li></ol><p>不安全，应用在安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期（session）有效。</p><h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p>如果高度信任某个应用，用户可以将用户名和密码提供给第三方应用，第三方应用使用密码申请令牌。适用于其他方式都无法使用，并且高度信任第三方应用的场景。</p><h4 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h4><p>适用于没有前端的命令行模式，即在命令行下申请令牌。</p><h3 id="使用令牌"><a href="#使用令牌" class="headerlink" title="使用令牌"></a>使用令牌</h3><p>第三方应用拿到令牌后，可以向服务提供商的 API 请求数据。每个 API 请求都必须携带令牌。具体做法在请求头部加入 <code>Authorization</code> 字段。</p><h3 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h3><p>B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><h2 id="github-授权"><a href="#github-授权" class="headerlink" title="github 授权"></a>github 授权</h2><p>客户端跳转链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/login/oauth/authorize?</span><br><span class="line">  client_id=7e015d8ce32370079895&amp;</span><br><span class="line">  redirect_uri=http://localhost:8080/oauth/redirect</span><br></pre></td></tr></table></figure><p>服务器处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clientID = <span class="string">'7e015d8ce32370079895'</span></span><br><span class="line"><span class="keyword">const</span> clientSecret = <span class="string">'2b976af0e6b6ceea2b1554aa31d1fe94ea692cd9'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> route = <span class="built_in">require</span>(<span class="string">'koa-route'</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = serve(path.join(__dirname + <span class="string">'/public'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> oauth = <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> requestToken = ctx.request.query.code;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'authorization code:'</span>, requestToken);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tokenResponse = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url: <span class="string">'https://github.com/login/oauth/access_token?'</span> +</span><br><span class="line">      <span class="string">`client_id=<span class="subst">$&#123;clientID&#125;</span>&amp;`</span> +</span><br><span class="line">      <span class="string">`client_secret=<span class="subst">$&#123;clientSecret&#125;</span>&amp;`</span> +</span><br><span class="line">      <span class="string">`code=<span class="subst">$&#123;requestToken&#125;</span>`</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      accept: <span class="string">'application/json'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> accessToken = tokenResponse.data.access_token;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`access token: <span class="subst">$&#123;accessToken&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    url: <span class="string">`https://api.github.com/user`</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      accept: <span class="string">'application/json'</span>,</span><br><span class="line">      Authorization: <span class="string">`token <span class="subst">$&#123;accessToken&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(result.data);</span><br><span class="line">  <span class="keyword">const</span> name = result.data.name;</span><br><span class="line">  ctx.response.redirect(<span class="string">`/welcome.html?name=<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.use(route.get(<span class="string">'/oauth/redirect'</span>, oauth));</span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">OAuth 2.0 的四种方式</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/04/github-oauth.html" target="_blank" rel="noopener">GitHub OAuth 第三方登录示例教程</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式</title>
      <link href="/2019/05/11/00030/"/>
      <url>/2019/05/11/00030/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/6WpUfRxqDmSIya4.jpg" alt="DaintreeRiver_ZH-CN2284362798_1920x1080.jpg"></p><a id="more"></a><h2 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h2><blockquote><p><a href="http://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">CAP 定理的含义</a></p></blockquote><p>分布式系统有三个指标：一致性、可用性和分区容错性，CAP 原理表示这三个指标不可能同时做到。</p><p><img data-src="https://i.loli.net/2019/05/11/5cd66adc1ed6b.jpg" alt="pic"></p><h3 id="分区容错"><a href="#分区容错" class="headerlink" title="分区容错"></a>分区容错</h3><p>大多数分布式系统分布在多个子网中，每个子网叫做一个区。分区容错性的意思是，区内部可以正常通信，但区间通信可能失败。在分布式系统中，分区容错性必不可少，即 P 总是成立的，因为需要总是假设网络是不可靠的。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性指发生写操作后，分布式节点必须都能返回新的值。CAP 理论的一致性指的是强一致性。</p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>可用性指在任意时刻，服务器都能处理用户发送的请求。</p><h3 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h3><p>分布式必须保证分区容错性，但一致性和可用性存在矛盾，需要进行权衡。</p><p>为了保证一致性，当分布式系统某节点在对数据进行写操作时，必须锁定其他节点该数据的读写操作，才能满足一致性；而当锁定数据期间，分布式系统无法满足可用性。</p><p>为了保证可用性，当分布式系统某节点在对数据进行写操作时，其他节点仍然能够提供该数据相关的服务，才能满足可用性；而此时无法满足一致性。</p><h2 id="BASE-原则"><a href="#BASE-原则" class="headerlink" title="BASE 原则"></a>BASE 原则</h2><blockquote><p><a href="https://www.cnblogs.com/exceptioneye/p/5452601.html" target="_blank" rel="noopener">分布式系统的BASE理论</a></p></blockquote><p>BASE 理论是对 CAP 理论一致性和可用性权衡的结果，核心思想是虽然无法达到强一致性，但是可以采用适当的方式达到最终一致性。BASE 指基本可用，软状态和最终一致性。</p><h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>基本可用指分布式系统在出现故障的时候，允许损失部分可用性，保证核心功能可用性。</p><h3 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h3><p>允许存在中间状态，而该中间状态不会影响系统的可用性。即允许数据同步时存在延迟。</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>分布式系统的数据在经过一段时间后，能够达到一致。</p><h2 id="FLP-不可能原理"><a href="#FLP-不可能原理" class="headerlink" title="FLP 不可能原理"></a>FLP 不可能原理</h2><p>在异步通信场景下，即使只有一个进程失败，也没有任何算法保证非失败进程达到一致性。</p><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>2PC 是两阶段提交，引入协调者来协调参与者的行为，并最终决定这些参与者是否要真正提交事务。</p><h3 id="2PC-过程"><a href="#2PC-过程" class="headerlink" title="2PC 过程"></a>2PC 过程</h3><ul><li>准备阶段<ul><li>协调者向参与者发送事务内容，询问参与者是否可以提交事务</li><li>各个参与者执行事务操作，并将信息写入 <code>undo</code> 和 <code>redo</code> 日志</li><li>如果参与者执行成功，返回 <code>yes</code>；如果执行失败，返回 <code>no</code></li></ul></li><li>提交阶段<ul><li>如果所有参与者返回 <code>yes</code><ul><li>协调者向参与者发送提交请求</li><li>参与者提交事务，并返回 ACK 完成消息</li><li>协调者收到所有参与者的 ACK ，即完成事务提交</li></ul></li><li>如果存在参与者返回 <code>no</code><ul><li>协调者向参与者发送回滚请求</li><li>参与者回滚事务，并返回 ACK 完成消息</li><li>协调者收到所有参与者的 ACK ，即完成事务回滚</li></ul></li></ul></li></ul><h3 id="2PC-问题"><a href="#2PC-问题" class="headerlink" title="2PC 问题"></a>2PC 问题</h3><ul><li>同步阻塞</li><li>单点故障</li><li>数据不一致</li><li>没有容错性</li></ul><h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><p>3 PC 是三阶段提交，是 2 PC 的改进版本。3PC 引入了超时机制，并且将 2PC 的准备阶段一分为二，产生三阶段提交。</p><h3 id="3PC-过程"><a href="#3PC-过程" class="headerlink" title="3PC 过程"></a>3PC 过程</h3><ul><li>CanCommit<ul><li>协调者向参与者发送 CanCommit 请求，询问是否可以执行事务提交操作</li><li>参与者如果自身能够顺利执行事务，返回 <code>yes</code>；否则返回 <code>no</code></li></ul></li><li>PreCommit<ul><li>如果所有参与者返回 <code>yes</code>，执行 PreCommit<ul><li>协调者向参与者发送 PreCommit 请求</li><li>参与者收到 PreCommit 请求，执行事务，将操作写入 <code>undo</code> 和 <code>redo</code> 日志</li><li>参与者根据执行情况发送 ACK 响应</li></ul></li><li>如果至少有一个参与者返回 <code>no</code> 或协调者等待超时<ul><li>协调者向所有参与者发送中断请求</li><li>参与者收到中断请求或超时，执行事务中断</li></ul></li></ul></li><li>doCommit<ul><li>协调者收到所有参与者的 ACK 响应<ul><li>协调者向参与者发送 doCommit 请求</li><li>参与者收到 doCommit 请求或者超时，正式提交事务</li><li>事务提交完成后，向协调者发送 ACK</li><li>协调者收到所有参与者 ACK ，完成事务</li></ul></li><li>协调者收到 <code>no</code> 或等待超时<ul><li>执行者向所有参与者发送中断请求</li><li>参与者收到中断请求，进行事务回滚并释放事务资源</li><li>参与者向协调者发送 ACK</li><li>协调者收到 ACK 后执行事务中断</li></ul></li></ul></li></ul><p>协调者在 CanCommit 和 PreCommit 阶段，如果收到至少一个 <code>no</code> 或等待超时，都会中断事务；</p><p>在 PreCommit 阶段，如果参与者等待超时，会中断事务；在 doCommit 阶段，如果参与者等待超时，会自动提交事务</p><h3 id="3PC-问题"><a href="#3PC-问题" class="headerlink" title="3PC 问题"></a>3PC 问题</h3><p>3PC 在等待超时后协调者或参与者会中断事务，能够避免单点故障问题；在 doCommit 阶段，如果协调者单点故障，参与者会自动提交事务。</p><p>由于引入超时机制，协调者和参与者不会无限等待下去，在一定程度上减缓了同步阻塞问题。</p><p>但 3 PC 仍然存在数据不一致问题，如果参与者收到 PreCommit 请求并给予响应，等待 doCommit 请求时，协调者发生故障，那么参与者会提交事务，造成数据不一致。</p><h2 id="Paxos-协议"><a href="#Paxos-协议" class="headerlink" title="Paxos 协议"></a>Paxos 协议</h2><p>Paxos 协议用于解决分布式系统一致性问题。将所有节点都写入同一个值，一旦写入不可更改。</p><p>Paxos 的两个操作：</p><ul><li>Proposal Number：提议编号，可理解为提议版本号，要求不能冲突</li><li>Proposal Value：提议的值</li></ul><p>Paxos 的三个角色：</p><ul><li>Proposer：提议发起者，不同的发起者可以提议不同的 Value</li><li>Accpetor：提议接受者，接受者有 N 个且彼此独立。Proposer 提出的 Value 必须获得超过半数 $\frac{N}{2}+1$ 接受者的批准才能通过</li><li>Learner：提议学习者，把通过的确定性值同步给其他未确定的 Accpetor</li></ul><p>Proposer 将发起提案 Value 给所有 Accpetor，超过半数 Accpetor 获得批准后，Proposer 将提案写入Accpetor 内，最终所有 Accpetor 获得一致性的确定性取值，且后续不允许再修改。</p><h3 id="Paxos-过程"><a href="#Paxos-过程" class="headerlink" title="Paxos 过程"></a>Paxos 过程</h3><ul><li>准备阶段<ul><li>每个提议发起者 Proposer 选择一个提议编号 N 并向所有提议接受者 Accpetor 发送提议请求</li><li>每个提议接受者 Accpetor 接受提议请求 $(n_i,v_i )$<ul><li>提议者之前未接受过任何提议请求，那么提议接受者发送一个 $(no \ previous)$ 提议响应，设置当前接受的提议为 $(n_1,v_1 )$ ，并保证以后不会接受序号小于 $n_1$ 的提议</li><li>提议者之前接受过提议请求<ul><li>新的提议请求的 $n_2$ 大于等于已接受提议的 $n_1$ ，发送 $(n_1,v_1)$ 提议响应，并设置当前接受提议为 $(n_2,v_2 )$</li><li>新的提议请求的 $n_2$ 小于已接受提议的 $n_1$，不响应</li></ul></li></ul></li></ul></li><li>接受阶段（此阶段也不接受小于当前 n 的提议）<ul><li>计算提交响应<ul><li>如果提交响应未超过半数 $\frac{N}{2}+1$ ，提议失败</li><li>如果提交响应超过半数 $\frac{N}{2}+1$，可发送接受请求，发送它收到的最大提议编号的值</li></ul></li><li>提议接受者接受到接受请求<ul><li>如果提议版本号小于自己保存的记录版本号，不接受</li><li>如果提议版本号大于等于自己保存的记录版本号，写入本地</li></ul></li></ul></li><li>学习阶段<ul><li>提议接受者向提议学习者发送自己接受的提议 $(n,v)$</li><li>提议学习者选择出大多数接受的提议并把值同步给其他未确定的接受者 Accpetor</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/2019/05/08/00029/"/>
      <url>/2019/05/08/00029/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/O1njhSwcBoTbEvp.jpg" alt="bing"></p><a id="more"></a><p>消息队列是指在消息的传输过程中保存消息的容器。</p><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><ul><li>点对点：消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次</li><li>发布-订阅：消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>系统可用性降低：消息队列挂了，整个系统就崩溃了</li><li>系统复杂性提高<ul><li>保证没有重复消费</li><li>保证可靠数据传输</li><li>保证数据一致性</li><li>保证消息顺序</li></ul></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li><code>ActiveMQ</code>：万级吞吐量；ms 级延迟；主从架构；低概率数据丢失；不推荐</li><li><code>RabbitMQ</code>：万级吞吐量；μs 级延迟；主从架构；中小企业推荐</li><li><code>RocketMQ</code>：10万级吞吐量；ms 级延迟；分布式架构；调优可数据另丢失；大公司推荐</li><li><code>kafka</code>：10万级吞吐量；ms 级延迟；分布式架构；调优可数据另丢失 ；适用于大数据计算</li></ul><h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p>保证业务逻辑具有幂等性。</p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ul><li><p>发送端的可靠性：发送端完成操作后一定能将消息成功发送到消息队列中</p><ul><li>开启事务，失败回滚并重试</li><li>confirm 模式，异步模式</li></ul></li><li><p>消息队列可靠性：持久化</p></li><li><p>接收端的可靠性：接收端能够从消息队列成功消费一次消息</p><ul><li>保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的</li><li>保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号</li></ul></li></ul><h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>拆分成多个消息队列，每个队列对应一个消费者。</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2tx45ueofj20oa09aq3h.jpg" alt="pic"></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ 是实现了高级消息队列协议（AMQP）的消息中间件技术。</p><h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><ul><li>连接管理器（ConnectionFactory）：应用程序与 RabbitMQ 之间建立连接的管理器，程序代码中使用</li><li>信道（Channel）：消息推送使用的通道</li><li>交换器（Exchange）：用于接收和转发消息</li><li>路由键（RoutingKey）：把生成者的数据分配到交换器上</li><li>绑定键（BindingKey）：把交换机的消息绑定到消息队列</li></ul><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>RabbitMQ 使用信道的方式进行数据传输。信道是建立在真实 TCP 连接内的虚拟连接，多个请求共享信道。</p><p>如果直接使用 TCP 连接，每个请求都会建立 TCP 连接，而 TCP 会话是非常昂贵的开销，并且操作系统每秒创建的 TCP 也是有限的，不利于高并发场景。</p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>消息持久化需要程序员设置消息为持久化消息，RabbitMQ 将持久化消息写入磁盘上的持久化日志中。消息被消费之后将消息日志对应的记录标记为可回收。</p><h3 id="交换器的四种模式"><a href="#交换器的四种模式" class="headerlink" title="交换器的四种模式"></a>交换器的四种模式</h3><ul><li><code>direct</code>：如果路由键匹配，则把消息投递到匹配的消息队列</li><li><code>headers</code>：允许使用 AMQP 的 header 信息进行匹配，其他和 <code>direct</code> 一致。性能不佳，不推荐使用</li><li><code>fanout</code>：发布 / 订阅模式。当发送消息时，交换器把消息转发到所有绑定到该交换器的队列上</li><li><code>topic</code>：匹配订阅模式，能够更灵活的匹配自己想订阅的消息</li></ul><h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3><p>为了保证消息能够顺利进入消息队列，RabbitMQ 提供了两种方式：</p><ul><li><p>使用 AMQP 提供的事务机制，事务实现主要是对信道的设置。同步机制，性能很差，不推荐</p><p><code>channel.txSelect()</code>：声明启动事务模式</p><p><code>channel.txComment()</code>：提交事务</p><p><code>channel.txRollback()</code>：回滚事务</p></li><li><p>使用发送者异步确认模式，也是设置Channel进行发送方确认的。异步监听，性能好</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://www.cnblogs.com/daiwei1981/p/9394587.html" target="_blank" rel="noopener">消息队列的面试题1</a></p></li><li><p><a href="https://www.cnblogs.com/daiwei1981/p/9394916.html" target="_blank" rel="noopener">消息队列的面试题2</a></p></li><li><p><a href="https://www.cnblogs.com/daiwei1981/p/9403806.html" target="_blank" rel="noopener">消息队列的面试题3</a></p></li><li><p><a href="https://www.cnblogs.com/daiwei1981/p/9403816.html" target="_blank" rel="noopener">消息队列的面试题4</a></p></li><li><p><a href="https://www.cnblogs.com/daiwei1981/p/9403888.html" target="_blank" rel="noopener">消息队列的面试题5</a></p></li><li><p><a href="https://www.cnblogs.com/daiwei1981/p/9403899.html" target="_blank" rel="noopener">消息队列的面试题6</a></p></li><li><p><a href="https://www.cnblogs.com/daiwei1981/p/9403925.html" target="_blank" rel="noopener">消息队列的面试题7</a></p></li><li><p><a href="https://www.cnblogs.com/ityouknow/p/6120544.html" target="_blank" rel="noopener">RabbitMQ 详解</a></p></li><li><p><a href="https://www.cnblogs.com/vipstone/p/9295625.html" target="_blank" rel="noopener">RabbitMQ交换器Exchange介绍与实践</a></p></li><li><p><a href="https://www.cnblogs.com/vipstone/p/9350075.html" target="_blank" rel="noopener">RabbitMQ事务和Confirm发送方消息确认</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡</title>
      <link href="/2019/05/07/00028/"/>
      <url>/2019/05/07/00028/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/RGcQ9fboCez3d7y.jpg" alt="bing"></p><a id="more"></a><h2 id="分布式-amp-集群"><a href="#分布式-amp-集群" class="headerlink" title="分布式 &amp; 集群"></a>分布式 &amp; 集群</h2><ul><li>分布式：将系统拆分成多个模块，分别部署在多个服务器上，各个模块负责不同的功能</li><li>集群：将系统部署在多个服务器上，互相独立，每个服务器完成相同的功能</li></ul><h2 id="分布式-amp-微服务"><a href="#分布式-amp-微服务" class="headerlink" title="分布式 &amp; 微服务"></a>分布式 &amp; 微服务</h2><ul><li>分布式：系统部署方式，模块分别部署在多个服务器上，每个模块可以复制几个功能</li><li>微服务：架构设计方式，微服务是很小的服务，小到甚至只提供单一的功能。服务可以单独部署，服务之间可以通过 RPC 进行交互</li></ul><h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><p>当主服务器宕机后，集群能够继续提供服务的策略。</p><h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>考虑一种场景，在分布式系统中，如果某个服务需要升级，往往会对其他依赖服务且正在运行的程序产生影响，甚至会产生级联效应造成系统卡顿甚至宕机。</p><p>熔断是一种过载保护机制。当下游服务因访问压力过大而响应变慢或失败时，上游服务为了保护自己以及系统整体的可用性，可以暂时切断对下游服务的调用。</p><ul><li>定义一个识别是否处于“不正常”状态的策略</li><li>“不正常”及时切断联系</li><li>定义一个识别是否处于“正常”状态的策略，并尝试探测</li><li>“正常”恢复联系</li></ul><p>熔断技术：<code>hystrix</code></p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>当系统资源不足以应对大量请求，即系统资源与访问量出现矛盾时，为保证有限资源能够正常服务，对系统按照预设的规则进行流量限制或功能限制的一种方法。</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也可以随机服务。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。分布式系统或微服务架构通过 RPC 进行相互调用。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>系统在应对各种攻击手段时能够有可靠的应对措施。</p><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>防止对任何资源进行未授权的访问，从而使计算机系统在合法的范围内使用。</p><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2tol77fi2j20g40dimy9.jpg" alt="pic"></p><p>服务注册：</p><ul><li>客户端注册</li><li>第三方注册</li></ul><p>服务发现：</p><ul><li>客户端服务发现</li><li>服务器端服务发现</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡服务器使用负载均衡算法将请求转发到集群中不同的主服务器节点上。负载均衡服务器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。负载均衡包括两部分：</p><ul><li>根据负载均衡算法得到转发节点</li><li>进行转发</li></ul><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ul><li>轮询：适用于每个服务器性能相当的场景</li><li>加权轮询：在轮询的基础上，根据服务器的性能差异，为每台服务器分配权重。性能高的服务器权值大，性能低的服务器权值小</li><li>最少连接：将请求转发到最小连接数的服务器上</li><li>加权最少连接：在最少连接的基础上，根据服务器的性能差异，为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数</li><li>随机算法：适用于每个服务器性能相当的场景</li><li>源地址哈希算法：计算客户端 IP 的哈希值，再对服务器数量取模得到目标服务器的序号。可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞</li></ul><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><ul><li>HTTP 重定向<ul><li>缺点：需要两次请求，访问延迟比较高；HTTP 负载均衡器处理能力有限，会限制集群的规模</li></ul></li><li>DNS 域名解析<ul><li>缺点：由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效</li></ul></li><li>反向代理服务器<ul><li>缺点：所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈</li></ul></li><li>网络层<ul><li>缺点：所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈</li></ul></li><li>链路层<ul><li>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
            <tag> Cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web页面请求过程</title>
      <link href="/2019/05/06/00027/"/>
      <url>/2019/05/06/00027/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/Cnm15g3KuQGHJfq.jpg" alt="CorsiniGardens_ZH-CN8547012221_1920x1080.jpg"></p><a id="more"></a><blockquote><p>模拟局域网中有网线的主机向外网服务器发送 HTTP 请求，获取 <code>dzapathy.github.io</code> 页面</p></blockquote><p>浏览器和服务器是应用层程序，使用 HTTP / HTTPS 协议进行网络通信，HTTP 的底层协议是 TCP 协议。为了能够进行通信，首先需要知道源 IP 地址和目的 IP 地址</p><h2 id="源-IP：DHCP"><a href="#源-IP：DHCP" class="headerlink" title="源 IP：DHCP"></a>源 IP：DHCP</h2><p>假设主机没有 IP 地址以及相关信息，需要使用 DHCP 协议获取 IP 地址</p><ul><li>主机发送 DHCP 发现报文<ul><li>主机应用层生成 DHCP 发现报文，并向下传送给传输层</li><li>主机传输层将 DHCP 发现报文封装成 UDP 报文段，源端口号是 68，目的端口号是 67，并向下传送给网络层</li><li>主机网络层将 UDP 报文段封装成 IP 数据报，源 IP 地址是 $0.0.0.0$，目的 IP 地址是 $255.255.255.255$，向下传输给数据链路层</li><li>主机数据链路层将 IP 数据报封装成数据帧，源 MAC 地址是主机 MAC 地址，目的 MAC 地址是 $FF:FF:FF:FF:FF:FF$，并发送给物理层</li><li>主机物理层以比特流的方式传输数据帧，将数据帧发送到交换机</li><li>交换机将主机的 MAC 地址及对应的接口记录在交换表中，然后在交换机的所有出口广播这个数据帧</li><li>DHCP 服务器（路由器可以作为 DHCP 服务器）收到广播的数据帧，拆开首部和尾部得到 IP 数据报并向上传送给网络层</li><li>DHCP 网络层拆开 IP 数据报首部得到 UDP 报文段，并将其发送给传输层</li><li>DHCP 传输层拆开 UDP 数据报得到 DHCP 报文，并将其发送给应用层</li><li>DHCP 应用层服务器得到 DHCP 发现报文</li></ul></li><li>DHCP 服务器发送提供报文<ul><li>DHCP 应用层生成 DHCP 提供报文，包含 IP 地址、子网、网关 IP 和 DNS 服务器 IP 信息，并向下传送给传输层</li><li>DHCP 传输层将 DHCP 提供报文封装成 UDP 报文段，源端口号是 67，目的端口号是 68，并向下传送给网络层</li><li>DHCP 网络层将 UDP 报文段封装成 IP 数据报，源 IP 地址是 DHCP 服务器 IP 地址，目的 IP 地址是 $255.255.255.255$，向下传输给数据链路层</li><li>DHCP 数据链路层将 IP 数据报封装成数据帧，源 MAC 地址是DHCP MAC 地址，目的 MAC 地址是 $FF:FF:FF:FF:FF:FF$，并发送给物理层</li><li>DHCP 物理层以比特流的方式传输数据帧，将数据帧发送到交换机</li><li>交换机将 DHCP 服务器的 MAC 地址及对应的接口记录在交换表中，然后在交换机的所有出口广播这个数据帧</li><li>主机收到广播帧，依次经过数据链路层、网络层、传输层、应用层得到 DHCP 提供报文</li></ul></li><li>主机发送 DHCP 请求报文<ul><li>源端口号是 68，目的端口号是 67，源 IP 地址是 $0.0.0.0$ ，目的 IP 地址是 $255.255.255.255$，依次经过应用层、传输层、网络层、数据链路层和物理层发送给 DHCP 服务器，DHCP 服务器经过数据链路层、网络层、传输层、应用层得到 DHCP 请求报文</li></ul></li><li>DHCP 服务器发送 DHCP 确认报文<ul><li>源端口号是 67，目的端口号是 68，源 IP 地址是 DHCP IP地址，目的 IP 地址是 $255.255.255.255$</li><li>主机收到 DHCP 确认报文，得到自己的 IP 地址、子网掩码、DNS 服务器 IP 地址和网关 IP 地址</li></ul></li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2oc6y9wjtj20ec0bkn04.jpg" alt="pic"></p><p>至此，主机获得 IP！</p><h2 id="网关-MAC：-ARP"><a href="#网关-MAC：-ARP" class="headerlink" title="网关 MAC： ARP"></a>网关 MAC： ARP</h2><p>假设主机没有网关路由器的 MAC 地址的 ARP 高速缓存</p><p>主机在局域网中，要访问局域网之外的主机需要通过网关路由器来进行访问。由于局域网内的 IP 地址可能比较紧缺，所以使用 DHCP 协议进行动态主机配置。DHCP 是有租期的，也就是说 IP 地址可能会改变，所以在局域网内使用 MAC 地址作为主机的唯一标识。对于主机来说，唯一不变的是 MAC 地址。所以要获取网关服务器的 MAC 地址</p><ul><li>主机应用层生成 ARP 查询报文，源 IP 地址是主机 IP 地址，目的 IP 地址是主机的默认网关路由器 IP 地址。经过传输层、网络层、数据链路层和物理层将数据帧发送给交换机</li><li>交换机将数据帧广播出去</li><li>网关路由器接收到数据帧，层层解析得到 ARP 查询报文，发现 ARP 查询报文的目的 IP 地址与自己某个网络接口 IP 地址匹配，发送 ARP 应答报文，报文中包含网关 MAC 地址</li></ul><p>至此，主机能够与默认网关进行通信！</p><h2 id="转换-IP：-NAT"><a href="#转换-IP：-NAT" class="headerlink" title="转换 IP： NAT"></a>转换 IP： NAT</h2><p>假设主机 IP 地址是私有 IP 地址</p><p>如果在局域网内部使用私有地址就无法与外部网络进行通信。为了保证通信，需要在网关处使用网络地址转换协议 NAT 将私有地址转化为公有地址</p><ul><li>在 NAT 路由器转换表中记录 <code>公有IP，新端口号</code>和 <code>源IP，源端口号</code> 的映射关系，转换方式包括静态转换、动态转换和端口多路复用等</li><li>内网向外网发数据：根据 NAT 转换表，利用 <code>公有IP，新端口号</code> 替换每个外出 IP 分组的<code>源IP，源端口号</code></li><li>外网向内网发数据：根据 NAT 转换表，利用<code>源IP，源端口号</code> 替换每个 IP 分组的  <code>公有IP，新端口号</code></li></ul><p>至此，主机能够通过默认网关与外网进行通信！</p><h2 id="目的-IP：DNS"><a href="#目的-IP：DNS" class="headerlink" title="目的 IP：DNS"></a>目的 IP：DNS</h2><p>假设主机没有 DNS 缓存，并且 DNS 查询使用迭代查询</p><ul><li>首先主机将查询发送给本地域名服务器</li><li>本地域名服务器无法解析域名时，本地域名服务器作为代理转发查询访问根域名服务器<ul><li>请求在网络核心通过路由器进行路由转发，由于路由器实现了内部网关协议（RIP，OSPF）和外部网关协议（BGP），所以请求能够正确的到达 DNS 域名服务器</li></ul></li><li>根域名服务器无法解析域名时，返回顶级域名服务器 <code>io</code></li><li>本地域名服务器查询顶级域名解析服务器 <code>io</code></li><li>顶级域名解析服务器无法解析域名时，返回权威域名服务器 <code>github.io</code></li><li>本地域名服务器查询权威域名服务器 <code>github.io</code></li><li>权威域名服务器 <code>github.io</code> 返回 <code>dzapathy.github.io</code> 的 IP 地址</li><li>本地域名服务器将 <code>dzapathy.github.io</code> 的 IP 地址返回给客户端</li></ul><p>至此，主机获得目的 IP 地址！</p><h2 id="建立连接：TCP-三次握手"><a href="#建立连接：TCP-三次握手" class="headerlink" title="建立连接：TCP 三次握手"></a>建立连接：TCP 三次握手</h2><p>现在已经获得了源 IP 地址，源端口号，目的 IP 地址和目的端口号，就可以进行 TCP 三次握手了</p><ul><li>服务器一直处于 LISTEN（监听）状态，等待客户的连接请求</li><li>客户端向服务器发送请求报文，SYN=1，ACK=0，随机初始化序号 x</li><li>服务器收到请求报文，如果同意建立连接则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，随机初始化序号 y</li><li>客户端收到服务器的确认报文后进行第三次握手，确认号为 y+1，序号为 x+1</li><li>服务器收到客户端的第三次握手后，连接 TCP 建立</li></ul><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lndh36zwj20z60ml0yh.jpg" alt="pic"></p><p>至此，主机和服务器建立了 TCP 连接，能够进行 HTTP 通信！</p><h2 id="请求：HTTP"><a href="#请求：HTTP" class="headerlink" title="请求：HTTP"></a>请求：HTTP</h2><p>假设服务器使用 SpringMVC</p><ul><li>主机发送 HTTP GET 请求报文，经过传输层、网络层、数据链路层和物理层交付给服务器</li><li>服务器层层拆分得到 HTTP GET 请求报文</li><li>服务器生成 HTTP 响应报文，将页面数据放入报文实体部分并发送给主机<ul><li>SpringMVC 前端控制器接收请求，并将请求发送给处理器映射器</li><li>处理器映射器根据 URL 查找处理器，并将处理器返回给前端控制器</li><li>前端控制器将处理器发送给处理器适配器，通过处理器适配器访问处理器</li><li>执行处理器</li><li>处理器会返回一个 <code>ModelAndView</code> 对象给处理器适配器</li><li>处理器适配器将 <code>ModelAndView</code> 返回给前端控制器，包括数据和视图</li><li>前端控制器向视图解析器发送视图解析请求</li><li>视图解析器返回视图对象</li><li>前端控制器进行视图渲染，将<code>model</code>转行成<code>responce</code></li></ul></li><li>浏览器收到 HTTP 响应报文，使用浏览器渲染页面，最后显示页面</li></ul><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2ruclid2pj20oi0fg3zt.jpg" alt="pic"></p><p>至此，主机获得请求页面！</p><h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><p>HTTP/1.1 之前默认是短连接的，一旦服务器发送完数据就会主动断开 TCP 连接，进行 TCP 四次挥手。HTTP/1.1 默认是长连接，不会立刻断开连接，可以设置 keep-alive 的 timeout，当到 timeout 后仍然没有数据传输就断开连接</p>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-数据链路层</title>
      <link href="/2019/04/30/00026/"/>
      <url>/2019/04/30/00026/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/xjEKodtfBmykXch.jpg" alt="bing"></p><a id="more"></a><blockquote><p><a href="https://www.icourse163.org/course/HIT-154005" target="_blank" rel="noopener">计算机网络视频</a><br><a href="https://dzapathy.github.io/2019/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络-基础知识</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/">计算机网络-应用层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络-传输层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-网络层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-数据链路层</a></p></blockquote><p>数据链路层解决两个相邻结点（主机或路由器）的数据通信服务，数据单位是数据帧</p><h2 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>将网络层传递下来的 IP 数据报（分组）加上首部和尾部，封装成数据帧。</p><p>加入首部和尾部的原因之一是保证帧同步。物理层的数据传输单位是比特流，为了清楚多少比特能构成一个数据帧，可以用首尾标识，首部即为数据帧的开始，尾部即为数据帧的结束，以此来得到一个完整的数据帧。</p><p>由于数据帧使用首部和尾部进行定界，如果帧的数据部分包含和首部或尾部相同的内容，会导致帧的首部或尾部被误判。为了解决这个问题，如果数据部分和首部或尾部相同，在数据部分的前边插入转义字符。在接收端进行处理后可以还原出原始数据。</p><h3 id="链路接入"><a href="#链路接入" class="headerlink" title="链路接入"></a>链路接入</h3><p>在数据链路层中，主机和路由器称为结点，连接相邻结点的通信信道称为链路。如果链路被很多结点共享，需要解决链路接入问题，保证数据的正确传输。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>协调相邻结点的发送速率和接收速率</p><h3 id="差错检验"><a href="#差错检验" class="headerlink" title="差错检验"></a>差错检验</h3><p>使用循环冗余检验 CRC ，不保证百分百检验出错误。</p><h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><ul><li>全双工通信：可以双向同时传输</li><li>半双工通信：可以双向交替传输</li></ul><h2 id="链路分类"><a href="#链路分类" class="headerlink" title="链路分类"></a>链路分类</h2><ul><li>点对点链路</li><li>广播链路：链路可以共享</li></ul><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>MAC 地址也称局域网地址， MAC 地址用于在网络中唯一标识一个网卡。一个网络设备可以有多个网卡，每个网卡都拥有 MAC 地址。</p><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>对于 Internet 网路使用共享广播链路，如果两个结点同时进行传输，势必造成冲突。为了解决这种问题，需要引入一种协议，保证同时传输不会出问题，多路访问控制协议 MAC 就是为了解决这个问题。</p><h3 id="MAC-分类"><a href="#MAC-分类" class="headerlink" title="MAC 分类"></a>MAC 分类</h3><ul><li>信道划分 MAC 协议：多路复用技术</li><li>随机访问 MAC 协议：信道不划分，允许存在冲突；如果发生冲突采用冲突恢复机制</li><li>轮转 MAC 协议</li></ul><h3 id="随机访问-MAC-协议"><a href="#随机访问-MAC-协议" class="headerlink" title="随机访问 MAC 协议"></a>随机访问 MAC 协议</h3><p>当结点要发送分组时，利用信道全部带宽发送数据，并且允许冲突。</p><h4 id="CSMA-协议"><a href="#CSMA-协议" class="headerlink" title="CSMA 协议"></a>CSMA 协议</h4><p>发送帧之前监听信道，信道空闲发送完整帧，信道忙推迟发送，但是可能仍然存在冲突。</p><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2pk0yprsqj209g0bj0v3.jpg" alt="pic"></p><p>CSMA 协议在数据帧发送之前监听信道，在数据传输过程中不会检测。当 $t_0$ 时刻，B 发现信道空闲开始发送数据。由于数据传播需要时间，在 $t_1$ 时刻还未到达 D，所以 D 监听信道空闲也会发送信号，此时会发生数据冲突。</p><h4 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h4><p>CSMA/CD 协议边发送数据边检测冲突，如果发现冲突可以及时停止发送数据以减少链路资源的浪费。CSMA/CD 协议的冲突检测可以总结为“边发边听，不发不听”</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2pk7o0ikjj20a3094q46.jpg" alt="pic"></p><p>为了保证 CSMA/CD 协议能够检测出冲突，需要保证如下公式：</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2pkiks1z8j20h30ax0vc.jpg" alt="pic"></p><h3 id="轮转-MAC-协议"><a href="#轮转-MAC-协议" class="headerlink" title="轮转 MAC 协议"></a>轮转 MAC 协议</h3><ul><li>信道划分 MAC 协议<ul><li>当网络负载重时，共享信道效率高</li><li>当网路负载轻时，共享信道效率低</li></ul></li><li>随机访问 MAC 协议<ul><li>当网络负载重时，共享信道效率低</li><li>当网路负载轻时，共享信道效率高</li></ul></li></ul><p>轮转访问协议综合前两者的优点！</p><ul><li>轮询：类似于多路 IO 复用</li><li>令牌传递</li></ul><h2 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是一种典型的广播信道，目前以太网占据着有线局域网的市场。可以按照网络拓扑结构对局域网进行分类：</p><p><img data-src="https://i.loli.net/2019/05/04/5ccd8cff895e8.jpg" alt="pic"></p><p>以太网是一种星型拓扑结构局域网。现在以太网使用交换机进行连接，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p><p>如图，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射</p><p><img data-src="https://i.loli.net/2019/05/04/5ccd8da938036.png" alt="pic"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-网络层</title>
      <link href="/2019/04/30/00025/"/>
      <url>/2019/04/30/00025/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/JgW6LEBlMa47fD5.jpg" alt="SouthernYellow_ZH-CN2055825919_1920x1080.jpg"></p><a id="more"></a><blockquote><p><a href="https://www.icourse163.org/course/HIT-154005" target="_blank" rel="noopener">计算机网络视频</a><br><a href="https://dzapathy.github.io/2019/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络-基础知识</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/">计算机网络-应用层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络-传输层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-网络层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-数据链路层</a></p></blockquote><p>网络层提供主机与主机之间的数据传输服务，网络层的数据单位是分组，常用的网络层协议有 IP 协议。网络层向上只提供简单的、无连接的、尽最大努力的数据传输服务</p><ul><li>IP 协议：Internet 网络层核心协议</li><li>路由协议：RIP，OSPF 和 BGP</li><li>ICMP 协议：提供 IP 协议传输过程中的差错报告</li></ul><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ul><li>路由：通过路由算法计算转发表，确定分组从源到目的通过的路径。在检索转发表时使用最长前缀匹配原则，优先选择与目的地址匹配前缀最长的输出端口</li><li>转发：将分组从路由器的输入端口转移到正确的输出端口</li><li>连接建立：不是所有网络层都需要实现连接建立的功能。在数据分组传输之前源主机和目的主机要建立一个虚拟 / 逻辑连接<ul><li>网络层连接：两个主机之间，路径上的路由器需要参与</li><li>传输层连接：两个进程之间建立逻辑连接，仿佛进程和进程之间能够直接通信，路径上的路由器不需要参与</li></ul></li></ul><h2 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h2><ul><li>无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定路径，不同分组的路径可能不同。常见的无连接服务网络有数据报网络</li><li>连接服务：事先为分组的传输确定传输路径，并且每个分组的路径确定且相同。常见的连接服务网络有虚电路网络</li></ul><h2 id="数据报网络-amp-虚电路网路"><a href="#数据报网络-amp-虚电路网路" class="headerlink" title="数据报网络 &amp; 虚电路网路"></a>数据报网络 &amp; 虚电路网路</h2><ul><li>数据报网络没有严格时间要求；虚电路网络从电话网络演变而来，通常有严格的时间要求和可靠数据传输</li><li>数据报网络简化网络，复杂边缘，让网络边缘完成更多的功能；虚电路网络复杂网络，简化边缘</li></ul><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><h3 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h3><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2o5a196l7j20rl0fu0vh.jpg" alt="pic"></p><ul><li>版本号：IP 协议版本，IPV4 的版本号是 4， IPV6 的版本号是 6</li><li>首部长度：首部长度×4 表示真正的首部字节数，比如首部占 20 字节，那么首部长度存储 5</li><li>区分服务：将 IP 数据报分成不同的类型，不同类型表示不同的服务</li><li>总长度：首部部分和数据部分的和</li><li>标识：IP 分片相关</li><li>标志：IP 分片相关</li><li>片偏移：IP 分片相关</li><li>生存时间：IP 分组可以通过的路由器数，每通过一次路由器，生存时间减 1 。当生存时间等于 0 时，路由器丢失该分组并向源主机发送 ICMP 报文</li><li>协议：标识上层协议的数，比如 TCP 为 6，UDP 为 17</li><li>首部校验和：与 UDP 相同，每次路由转发都要重新计算，因为 IP 数据报的首部字段会变</li></ul><h3 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h3><p>网络链路存在最大传输单元（MTU），不同链路的 MTU 不同，MTU 可以认为是数据链路层的数据帧运行的最大数据部分的长度。当大 IP 分组向小 MTU 链路转发时可以被分片，IP 分片到达目的主机后进行重组，路由器不会进行 IP 重组。如果接收端主机没有收到全部的分片，它会丢弃所有的分片</p><ul><li>标识：标识一个 IP 分组</li><li>标志位包括保留、<code>DF</code> 和 <code>MF</code><ul><li><code>DF</code> ：<code>DF</code>等于 1 表示禁止分片，当 IP 分组超过链路 MTU 时，路由器丢掉分组并向原主机发送 ICMP 报文；<code>DF</code> 等于 0 表示允许分片</li><li><code>MF</code> ：<code>MF</code> 等于 1 表示非最后一片，<code>MF</code> 等于 0 表示最后一片</li></ul></li><li>片偏移：以 8 字节为单位，表示 IP 分组数据的偏移量</li></ul><p><img data-src="https://i.loli.net/2019/05/03/5ccbfc9ebe640.png" alt="pic"></p><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>IP 编码是对主机、路由器或交换机的网络接口进行编码。路由器的网络接口有多个，所以要对路由器的各个网络接口设置 IP 地址。IP 地址包括网络号和主机号</p><h4 id="有类-IP"><a href="#有类-IP" class="headerlink" title="有类 IP"></a>有类 IP</h4><p><img data-src="https://i.loli.net/2019/05/03/5ccbff9355782.png" alt="pic"></p><ul><li>A 类地址：网络号占 8 位，并且最高位是 0 ，范围是 $0.0.0.0 \sim 127.255.255.255$</li><li>B 类地址：网络号占 16 位，并且最高位是 10，范围是$128.0.0.0 \sim 191.255.255.255$</li><li>C 类地址：网络号占 24 位，并且最高位是 110，范围是$192.0.0.0 \sim 223.255.255.255$</li><li>D 类地址：最高位是 1110，范围是$224.0.0.0 \sim 239.255.255.255$</li><li>E 类地址：最高位是 1111，范围是$240.0.0.0 \sim 255.255.255.255$</li></ul><p>A B C 类地址可以用于标识网络主机的 IP 地址</p><p>特殊地址：</p><ul><li><code>0.0.0.0</code>：只能作为源地址，不能作为目的地址。在本子网范围内表示本机，在路由表中表示默认路由（相当于整个 Internet ）</li><li><code>0.0.0.23</code>：网络号全 0，主机号特定值，表示本网内某个特定主机</li><li><code>255.255.255.255</code>：只能作为目的地址，不能作为源地址，表示本网广播地址</li><li>网路号特定值，主机号全 0 ，表示一个网络</li><li>网络号特定值，主机号全 1 ，表示对特定网络进行广播</li><li>网络号 127，主机号非全 0 且 非全 1 的任何数，用于本地软件回环测试</li></ul><p>私有地址：</p><ul><li>A 类中网络号是 10</li><li>B 类中 $172.16 \sim 172.31$</li><li>C 类中 $192.168.0 \sim  192.168.255$</li></ul><h4 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h4><ul><li>IP 地址分为网络号、子网号和主机号</li><li>外部网络看不到子网，必须通过子网掩码进行区分</li><li>子网掩码的网络号和子网号全是 1</li></ul><h4 id="无类域间路由"><a href="#无类域间路由" class="headerlink" title="无类域间路由"></a>无类域间路由</h4><p>无类域间路由（CIDR）消除了 A B C 类地址的划分，CIDR 的 IP 地址包括网络前缀和主机地址，融合了子网地址和子网掩码，方便子网划分。无类地址的格式是$a.b.c.d/x$ ，其中 $x$ 表示网络前缀的长度</p><ul><li>提高了 IPV4 地址空间的分配效率</li><li>提高了路由效率，将多个子网构造成更大的子网，在路由表中可以面向更大的子网记录路由转发信息，进行路由聚合从而让路由表大小有了很大的减少</li></ul><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>IPV4 的地址已经分配殆尽，为了保证所有主机能够正常通信，可以不为所有主机分配公有地址，而是在子网内使用私有地址进行通信。私有地址不能与外来网络进行通信，为了保证能够通信，需要使用网络地址转换 NAT ，将源地址替换为公共 IP 地址</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>解决 IPV4 耗尽问题</li><li>内网 IP 地址对外网透明，本地网络变更无需通告外界网络</li><li>外部网络无法直接寻址，保证内网安全</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>内网访问外网的流程：</p><ul><li>内网向外网发送数据：利用 <code>NAT IP地址，新端口号</code> 替换每个外出 IP 分组的<code>源IP地址，源端口号</code>，并在 NAT 转换表中记录 <code>NAT IP地址，新端口号</code> 和 <code>源IP地址，源端口号</code> 的替换关系</li><li>外网返回数据给内网：根据 NAT 转换表，利用  <code>源IP地址，源端口号</code>  替换 IP 分组中的 <code>目的IP地址，目的端口号</code></li></ul><h3 id="NAT-穿透"><a href="#NAT-穿透" class="headerlink" title="NAT 穿透"></a>NAT 穿透</h3><p>外网无法直接访问内网。如果内网有服务器，客户端无法访问内网 IP ，需要穿透 NAT 去请求服务，NAT 穿透问题的解决方案有：</p><ul><li><p>静态配置：静态配置 NAT，将特定端口的服务转发给服务器。比如，$(138.76.29.7,2500)$ 总是转发给 $(10.0.0.1,25000)$</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2p49ps77cj208d05v3zf.jpg" alt="pic"></p></li><li><p>利用 UPNP 协议自动配置，动态配置映射，和静态配置达到相同的效果</p></li><li><p>中继</p></li></ul><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>互联网控制报文协议（ICMP）支持主机和路由器，能够进行差错报告和网络探询。根据 ICMP 的功能将 ICMP 报文分为两大类：</p><ul><li>差错报告报文（5种）<ul><li>目的不可达：当目的主机不可达时，会发送 ICMP 报文通知源主机</li><li>源抑制：当网络阻塞时，路由器可以通过向源主机发送 ICMP 报文，源主机收到该报文可以选择降低自己的发送速率（Internet 未使用）</li><li>超时：当 IP 分组超时时，会向源主机发送 ICMP 报文</li><li>参数问题：IP 分组头部出问题</li><li>重定向：当路由器发现自己无法转发 IP 分组时，向源主机发送 ICMP 报文进行重定向</li></ul></li><li>网络探询报文<ul><li>回声请求和应答报文：<code>ping</code>命令</li><li>时间戳请求和应答报文</li></ul></li></ul><h3 id="ICMP-格式"><a href="#ICMP-格式" class="headerlink" title="ICMP 格式"></a>ICMP 格式</h3><p>ICMP 封装在 IP 数据报中，但是不属于高层协议</p><p><img data-src="https://i.loli.net/2019/05/04/5ccd0a5ea563b.jpg" alt="pic"></p><h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><p>解决 IPV4 地址紧缺的问题</p><ul><li>固定长度的 40 字节基本首部</li><li>路由器不进行分片，如果 IP 分组太大由发送端进行分片，接收端进行重组</li><li>移除校验和</li></ul><p>IPV6 的地址长度占 128 位，使用冒分十六进制表示法和 0 位压缩表示法</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由算法将网络抽象成有权无向图，权重可以是拥塞程度或带宽的倒数等，通常是权重越小路径越好。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>静态路由 &amp; 动态路由<ul><li>静态路由：人工配置，路由更新慢，优先级高</li><li>动态路由：根据路由算法计算得到的，路由更新快</li></ul></li><li>全局信息 &amp; 分散信息<ul><li>全局信息：所有路由器必须掌握完整的网络拓扑和链路费用信息，比如链路状态路由算法</li><li>分散信息：只掌握物理相连的临街及其对应的链路费用，比如距离向量路由算法</li></ul></li></ul><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h4><ul><li>通过广播获取网络拓扑和链路费用</li><li>计算源节点到其他所有节点的最短路径（Dijkstra 算法）</li><li>存在路由震荡问题</li></ul><h4 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h4><p>动态规划思想，存在无穷计数问题<br>$$<br>d_x(y) = min{c(x,v)+d_{v}(y)}<br>$$<br><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2p6tpixn7j208109wmyn.jpg" alt="pic"></p><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2p7bozod1j20iq0bm0wn.jpg" alt="pic"></p><h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p>将路由器进行聚合，产生一个区域，称为自治系统。自治系统内部和自治系统间可以使用不同的路由。为了实现自治系统，需要有一个对外的路由器，称为网关路由器，网关路由器的转发表由自治系统内路由算法和自治系统间路由算法决定</p><h2 id="Internet-路由"><a href="#Internet-路由" class="headerlink" title="Internet 路由"></a>Internet 路由</h2><p>Internet 网路采用层次路由，分为自治系统内路由和自治系统间路由</p><p>自治系统内部路由协议包括</p><ul><li>路由信息协议（RIP）<ul><li>使用距离向量路由算法，RIP 比较简单<ul><li>距离度量：跳数，最大 15 跳</li><li>每隔 30s 更新 DV</li></ul></li></ul></li><li>开放最短路径优先（OSPF）<ul><li>使用链路状态路由算法， OSPF 性能更优</li></ul></li></ul><p>自治系统间路由协议包括</p><ul><li>BGP</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-传输层</title>
      <link href="/2019/04/30/00024/"/>
      <url>/2019/04/30/00024/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/qo7NdBwcQjkSutD.jpg" alt="BloomingJacaranda_ZH-CN1456780313_1920x1080.jpg"></p><a id="more"></a><blockquote><p><a href="https://www.icourse163.org/course/HIT-154005" target="_blank" rel="noopener">计算机网络视频</a><br><a href="https://dzapathy.github.io/2019/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络-基础知识</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/">计算机网络-应用层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络-传输层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-网络层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-数据链路层</a></p></blockquote><p>传输层为不同主机的进程提供逻辑通信服务。传输层向高层用户屏蔽了下面网络层的核心细节，使得进程和进程之间仿佛有一条端到端的逻辑通信信道。</p><ul><li>发送方：将应用层传输的报文封装成报文段，并向下传输给网络层</li><li>接收方：接收网络层传输过来的报文段，组合成报文并向上发送给应用层</li></ul><h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><ul><li>UDP（用户数据报协议）<ul><li>非面向连接</li><li>尽力而为</li></ul></li><li>TCP （传输控制协议）<ul><li>流量控制</li><li>拥塞控制</li><li>面向连接</li></ul></li></ul><h2 id="多路复用-分用"><a href="#多路复用-分用" class="headerlink" title="多路复用 / 分用"></a>多路复用 / 分用</h2><p>传输层提供进程和进程之间的逻辑通信服务，而一个主机可能存在多个进程。为了区分不同的进程，传输层需要提供多路复用 / 分用功能</p><ul><li><p>发送端进行多路复用</p><p>传输层从多个 Socket 接收数据，为每块数据封装上头部信息，生成报文段并发送给网络层</p></li><li><p>接收端进行多路分用</p><p>传输层接收网络层发来的报文段，解析头部信息并将报文发送给正确的 Socket</p></li></ul><h3 id="无连接的多路分用"><a href="#无连接的多路分用" class="headerlink" title="无连接的多路分用"></a>无连接的多路分用</h3><p>无连接的多路分用使用二元组标识：目的 IP 地址和目的端口号</p><h3 id="面向连接的多路分用"><a href="#面向连接的多路分用" class="headerlink" title="面向连接的多路分用"></a>面向连接的多路分用</h3><p>面向连接的多路分用使用四元组标识：源 IP 地址、源端口号、目的 IP 地址和目的端口号</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul><li>基于 IP 协议，实现了多路复用 / 分用、错误校验</li><li>尽力而为服务，UDP 数据报可能会丢失，非按序到达</li><li>无连接，发送方和接收方不需要握手和挥手</li><li>UDP 对报文不拆分，只添加 UDP 首部</li></ul><h3 id="UDP-首部"><a href="#UDP-首部" class="headerlink" title="UDP 首部"></a>UDP 首部</h3><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2lmyn9nmtj20vl0iq0x7.jpg" alt="pic"></p><p>UDP 首部包含源端口号、目的端口号、长度和校验和，共 8 字节</p><ul><li><p>长度：包括 UDP 首部和 UDP 数据部分</p></li><li><p>校验和</p><ul><li>发送方将数据报视为多个16 bit 整数</li><li>将整数求和，进位加在和的后边</li><li>将求和结果按位取反得校验和</li><li>接收方重新计算校验和，并与发送方的 UDP 首部校验和比较，相等认为数据传输正确</li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2lnbaza7rj20hq05iq4h.jpg" alt="pic"></p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>无连接，减少延迟</li><li>实现简单，不需要维护连接状态</li><li>头部开销少，UDP 头部 8 字节</li><li>没有拥塞控制，应用程序可以更好的控制发送时间和速率</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>常用于流媒体应用：容忍数据丢失但对速率敏感</li><li>应用于应用层 DNS 协议</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 是传输层的可靠数据传输协议</p><ul><li>点对点</li><li>可靠、按序字节流</li><li>流水线机制，提高传输性能</li><li>发送方和接收方有缓存</li><li>面向连接</li><li>全双工通信<ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul></li><li>流量控制和拥塞控制</li></ul><p>可靠指数据不错、不丢、不乱序</p><ul><li>不错：校验和、序号、确认号</li><li>不丢：定时器（等待合理时间）和重传机制</li><li>不乱：序号</li></ul><h3 id="TCP-首部"><a href="#TCP-首部" class="headerlink" title="TCP 首部"></a>TCP 首部</h3><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2lmygurwmj210a0p7akt.jpg" alt="pic"></p><ul><li>序号：用于对字节流进行编号，比如序号 200 表示报文段第一个字节的编号是 200 。建立 TCP 连接时，双方随机选择起始序列号</li><li>确认号：期望接收到的下一个字节流的序号，确认号是累计确认机制，该确认号之前的所有字节均被正确接收到</li><li>数据偏移： TCP 首部的长度</li><li>URG：紧急数据，一般不使用</li><li>ACK：标记确认号是否有效，ACK 等于 1 表示确认号有效，TCP 建立连接后 ACK 始终等于 1</li><li>PSH：标记立刻把数据推送给上层</li><li>RST：连接错误</li><li>SYN：建立连接时用来同步连接，三次握手的前两次携带 SYN = 1</li><li>FIN：发送释放连接请求，四次挥手双方各发一次 FIN = 1</li><li>窗口：接收窗口的大小，所愿意接收的字节的数目</li><li>校验和：校验数据</li></ul><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>TCP 在三次握手和四次挥手时不会采用流水线机制</p><blockquote><p><a href="https://dzapathy.github.io/2019/03/14/TCP/">TCP</a></p></blockquote><ol><li>TCP 三次握手的目的是为了防止已失效的连接请求到达服务器，让服务器产生连接的误判，从而造成服务器资源的浪费。如果客户端向服务器发送连接请求，但由于网络拥塞等情况导致服务端迟迟没有收到连接请求，客户端等待超时会重新发送连接请求，这时第一次发送的连接请求即为已失效的连接请求。但是滞留在网络中的已失效的连接请求最后也到达了服务器，服务器无法区分请求是否失效，而是认为客户端又发送了一次新的请求，此时服务端会发送确认报文。如果只有两次握手，会导致服务端打开失效连接等待客户端发送数据，而失效的请求不会发送任何数据，从而导致服务端资源的浪费。而有了三次握手，客户端会丢弃失效连接，不会发送失效请求的确认报文，所以不会造成服务端打开失效连接。</li><li>TCP 三次握手是为了保证“在不可靠信道进行可靠数据传输”这一需求所导致的，TCP 通过三次握手建立可靠的全双工通信。第一次握手和第二次握手建立客户端到服务器的可靠连接，第二次握手和第三次握手建立服务器到客户端的可靠连接。由于服务端的响应报文和连接请求可以放在一起，所以三次握手就能保证建立的可靠的全双工通信。</li></ol><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol><li>主动请求关闭连接的一方发送 <code>FIN = 1</code> 的请求报文，对方发送 ACK 响应报文。此时 TCP 处于半关闭状态，表示主动请求关闭连接的一方没有更多的数据需要发送，但是可以接收来自另一端的数据</li><li>另一端发送完数据后发送 <code>FIN = 1</code> 的请求报文，主动请求关闭连接的一方进行确认</li></ol><p>主动请求关闭连接的一方会进入 TIME_WAIT 状态，TIME_WAIT 需要经过 2个 MSL（最大报文段生存时间）才能关闭，使用 2MSL 定时器记录 TIME_WAIT 的时间。</p><ul><li>如果客户端主动关闭连接，由于 IP 协议不可靠导致服务端最后没有收到客户端发送的 ACK ，服务端就会在超时后重新发送 FIN 。如果没有 TIME_WAIT 而是直接关闭就会导致客户端无法响应服务端再次发送的 FIN，最终服务端收到 RST 连接错误报文。而 TIME_WAIT 能够保证客户端再次接收 FIN 并发送 ACK</li><li>如果客户端主动关闭连接后立刻建立新连接，并且源端口号和原来相同，一般不会有问题。但如果老连接的数据仍然滞留在网络中并最后传输到服务器，会导致服务端无法区分新数据和老数据，造成数据传输错误。2 倍的 MSL 能够保证本次连接的所有数据都能够从网络中消息</li></ul><p>在高并发短连接的 TCP 服务器中，当服务器处理完请求后立刻主动正常关闭连接，会出现大量 Socket 处于TIME_WAIT 状态。如果不到必须解决这个问题最好不要动 TCP 的断开连接的方式，可以使用负载均衡的方式解决高并发问题。</p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><ul><li>RTT ：指一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值</li><li>RTO：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传</li></ul><p>为了保证 TCP 协议的可靠性，当超时或连续收到3次重复确认号时需要重传。超时需要设置重传定时器阀值 RTO ，重传定时器阀值的选择可以参考 RTT 指标，RTO 的计算公式为：</p><p>$$<br>EstimatedRTT = (1-\alpha)EstimatedRTT+\alpha RTT \<br>DevRTT = (1-\beta) DevRTT + \beta |RTT-EstimatedRTT| \<br>Timeout = EstimatedRTT + 4*DevRTT<br>$$</p><p>即求 RTT 的指数移动平均值与 4 倍指数移动方差的和。重传数据的 RTT 不会参与计算，理由很简单，因为程序已经不在正常状态下了，估计出来的数据也是没有意义的。</p><p>TCP 采用流水线机制，使用滑动窗口协议保证数据传输速度，一次能够发送多个报文段。一个滑动窗口共享一个重传计数器，重传计数器记录第一个已发送数据但未收到确认请求的报文段。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制是为了控制发送方发送的速率，保证接收方来得及接收。TCP 发送方和接收方都有缓存并且缓存大小有限，如果发送方速度太快导致接收方缓存空间用尽，将导致大量的数据被扔掉。</p><p>接收方知道自己的剩余缓存大小，把剩余缓存放入 TCP 头部的窗口字段中发送给发送方，然后发送方根据接收方能够接收的数据大小调整自己发送数据的频率。</p><p>如果发送端收到接收端数据段的窗口大小是 0 ，发送端无法发送数据。当接收端有一定大小的缓存能够接收数据时，接收端会向发送端发送非零窗口大小的报文段。但是如果这个非零窗口大小的报文段在传输过程中丢失，导致发送端无法接收该报文段，那么发送端会一直等待下去，而接收到并不知道报文段丢失而会一直等待发送端发送数据，从而导致死锁。</p><p>坚持定时器主要是解决零窗口大小通知可能导致的死锁问题。TCP 为每个连接设置一个坚持定时器，当客户端收到服务器的 0 滑动窗口报文时，启动一个定时器来计时，并在定时器溢出的时向服务器发送探测报文，查询窗口是否已经增大，如果得到非零的窗口就重新开始发送数据，如果得到零窗口就再开一个新的定时器准备下一次查询。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>太多主机发送太多数据或数据发送过快导致网络无法处理。拥塞的表现包括分组丢失（路由器缓存溢出）或分组排队时延过大（在路由器缓存中排队）</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>可靠传输：主要解决端到端的数据传输问题</li><li>流量控制：限制发送发的发送速率以免接收方缓存溢出</li><li>拥塞控制：防止网络拥塞，解决的是整个网络的数据传输问题</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>端到端的拥塞控制：网络层不需要显示的提供拥塞控制的支持，传输层根据分组丢失或分组时延来调整发送方的发送速率。 TCP 使用端到端的拥塞控制</li><li>网络辅助的拥塞控制：路由器向发送方显示的反馈网络拥塞信息</li></ul><h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><ol><li><p>发送方限制发送速率</p><p>动态调整窗口大小，以改变发送速率</p></li><li><p>感知网络拥塞</p><p>当发生超时或收到 3 个重复 ACK 后，认为分组丢失并且网络拥塞，发送方降低发送速率</p></li><li><p>合理调整发送速率</p><ul><li><p>加性增-乘性减：每个 RTT 为增加窗口一个报文段，从而避免网络拥塞；当发生网络拥塞时，将窗口大小减半</p></li><li><p>慢启动：刚启动 TCP 窗口大小呈指数增长</p></li><li><p>TCP 窗口指数增长和线性增长需要进行切换，可以设置 threshold ，值设置为发生拥塞事件前窗口的一半。慢启动解决 TCP 刚建立连接起速太慢的问题；加性增-乘性减是避免数据传输过程中网络拥塞的问题。下图中蓝线是早期版本，黑线是改进版本</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2ln00rk1wj20bh0723zs.jpg" alt="pic"></p></li></ul></li></ol><p>TCP 对不同的拥塞有不同的处理机制</p><ul><li>3 个重复 ACK<ul><li>窗口切到一半，然后线性增长</li><li>发送方收到 3 个重复 ACK 意味着网路还能够进行传输，拥塞比较低</li></ul></li><li>超时<ul><li>窗口设置为 1 ，然后指数增长。当达到 threshold 时线性增长</li><li>超时意味着网路拥塞更严重</li></ul></li></ul><p>总结：</p><ul><li>当窗口小于 threshold 时处于慢启动状态，窗口呈指数增长</li><li>当窗口大于 threshold 时处于拥塞避免状态，窗口呈线性增长</li><li>当收到 3 个重复 ACK 时，窗口大小减半，threshold 减为发生阻塞时窗口大小的一半</li><li>当超时时，窗口减为 1，threshold 减为发生阻塞时窗口大小的一半</li></ul><h4 id="保活定时器"><a href="#保活定时器" class="headerlink" title="保活定时器"></a>保活定时器</h4><p>保活定时器是为了应对 TCP 连接双方出现长时间的没有数据传输的情况。如果客户端与服务器建立了 TCP 连接之后，客户端由于某种原因导致主机故障，则服务器就不能收到来自客户端的数据，而服务器不可能一直处于等待状态，保活定时器就是用来解决这个问题的。服务器每收到一次客户端的数据，就重新设置保活定时器，通常为 2 小时，如果 2 小时没有收到客户端的数据，服务端就发送一个探测报文，以后每隔75秒发送一次，如果连续发送 9 次探测报文段后仍没有收到客户端的响应，服务器就认为客户端出现了故障，就可以终止这个连接</p><p>支持参数配置：</p><ul><li><code>net.ipv4.tcp_keepalive_time=7200</code>：timeout 的时间</li><li><code>net.ipv4.tcp_keepalive_intvl = 75</code>：timeout 后发送探测报文的间隔时间</li><li><code>net.ipv4.tcp_keepalive_probes = 9</code>：发送探测报文的次数</li></ul><h3 id="TCP-机制"><a href="#TCP-机制" class="headerlink" title="TCP 机制"></a>TCP 机制</h3><ol><li>确认应答机制</li><li>超时重传机制：超时</li><li>快速重传机制：3个重复 ACK</li><li>滑动窗口机制</li><li>流量控制</li><li>拥塞控制</li><li>延迟应答机制：接收方处理数据很快，延迟应答保证接收方窗口尽可能的大，提高传输效率</li><li>捎带应答机制：ACK 联通返回数据一并发送给接收端</li></ol><h3 id="TCP-粘包"><a href="#TCP-粘包" class="headerlink" title="TCP 粘包"></a>TCP 粘包</h3><ul><li><p>发送端需要等缓冲区满时才发送出去，造成粘包</p></li><li><p>接收端不及时的接收缓冲区内的包，造成多个包接收</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-应用层</title>
      <link href="/2019/04/30/00023/"/>
      <url>/2019/04/30/00023/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/FrV1DlE8kLepw9o.jpg" alt="Krakatoa_ZH-CN8471800710_1920x1080.jpg"></p><a id="more"></a><blockquote><p><a href="https://www.icourse163.org/course/HIT-154005" target="_blank" rel="noopener">计算机网络视频</a><br><a href="https://dzapathy.github.io/2019/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络-基础知识</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/">计算机网络-应用层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络-传输层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-网络层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-数据链路层</a></p></blockquote><p>应用层是提供不同主机之间进程和进程的通信，应用层的数据单位是报文。常见的应用层协议包括：</p><ul><li>Web：HTTP、HTTPS</li><li>Email：SMTP、POP3、IMAP</li><li>File：FTP</li></ul><h2 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h2><ul><li>C/S：客户端-服务器</li><li>P2P：没有明确客户端和服务器的角色</li><li>混合结构：比如文件传输使用 P2P 结构，文件搜索使用 C/S 结构</li></ul><h2 id="Web-应用"><a href="#Web-应用" class="headerlink" title="Web 应用"></a>Web 应用</h2><blockquote><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/HTTP" target="_blank" rel="noopener">HTTP</a></p><p><a href="https://www.cnblogs.com/blackgan/p/11107317.html" target="_blank" rel="noopener">多进程多线程浏览器</a></p></blockquote><p>HTTP 协议是一个无状态的协议，如果设计成有状态的协议，维护状态需要进行非常复杂的处理。HTTP 默认是持久性连接。</p><ul><li>非持久性连接：一个 TCP 连接只能处理一个 HTTP 请求</li><li>持久性连接：一个 TCP 连接能够处理多个 HTTP 请求</li></ul><p>HTTP 包括请求消息和响应消息，首部包括通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><ul><li>host：主机号在缓存或代理中使用</li></ul><h2 id="DNS-应用"><a href="#DNS-应用" class="headerlink" title="DNS 应用"></a>DNS 应用</h2><p>域名解析系统 DNS 是将域名解析为 IP 地址的分布式分层数据库。DNS 提供以下几种服务：</p><ul><li>将域名映射成 IP 地址</li><li>主机别名</li><li>邮件服务器别名</li><li>负载均衡：在进行域名向 IP 地址的映射时，可以提供多个 IP 地址</li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>域名并不完全存储于一个服务器中，每个 DNS 服务器只保留它自己的数据。</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p><img data-src="https://i.loli.net/2019/05/01/5cc97ed6b1659.jpg" alt="pic"></p><p>域名具有层次结构，从上到下依次是：根域名、顶级域名、二级域名…</p><ul><li>根域名服务器：全球有 13 个根域名服务器</li><li>顶级域名服务器：负责 <code>edu</code>、 <code>com</code> 、 <code>org</code> 等顶级域名</li><li>权威域名服务器：组织的域名解析服务器，负责组织内部的域名解析</li><li>本地域名服务器：每个 ISP 都有一个本地域名服务器。本地域名服务器是默认的域名解析服务器，当主机进行 DNS 查询时，查询被发送到本地域名服务器，本地域名服务器作为代理将查询转发给域名解析系统。</li></ul><h3 id="迭代查询-amp-递归查询"><a href="#迭代查询-amp-递归查询" class="headerlink" title="迭代查询 &amp; 递归查询"></a>迭代查询 &amp; 递归查询</h3><p>域名查询分为两种：迭代查询和递归查询</p><p>若客户端想要查询 <code>dzapathy.github.io</code> 的 IP，迭代查询的流程如下：</p><ul><li><p>首先主机将查询发送给本地域名服务器</p></li><li><p>本地域名服务器无法解析域名时，本地域名服务器作为代理转发查询访问根域名服务器</p></li><li><p>根域名服务器无法解析域名时，返回顶级域名服务器  <code>io</code>  </p></li><li><p>本地域名服务器查询顶级域名解析服务器 <code>io</code></p></li><li><p>顶级域名解析服务器无法解析域名时，返回权威域名服务器 <code>github.io</code></p></li><li><p>本地域名服务器查询权威域名服务器 <code>github.io</code></p></li><li><p>权威域名服务器 <code>github.io</code> 返回  <code>dzapathy.github.io</code>  的 IP 地址</p></li><li><p>本地域名服务器将 <code>dzapathy.github.io</code> 的 IP 地址返回给客户端</p></li></ul><p>若客户端想要查询 <code>dzapathy.github.io</code> 的 IP，递归查询的流程如下：</p><ul><li><p>首先主机将查询发送给本地域名服务器</p></li><li><p>本地域名服务器无法解析域名时，本地域名服务器作为代理转发查询访问根域名服务器</p></li><li><p>根域名服务器无法解析域名时，查询顶级域名服务器  <code>io</code>  </p></li><li><p>顶级域名服务器无法解析域名时，查询权威域名服务器 <code>github.io</code></p></li><li><p>权威域名服务器 <code>github.io</code> 返回  <code>dzapathy.github.io</code>  的 IP 地址给顶级域名服务器</p></li><li><p>顶级域名服务器返回给根域名服务器</p></li><li><p>根域名服务器返回给本地域名服务器</p></li><li><p>本地域名服务器将 <code>dzapathy.github.io</code> 的 IP 地址返回给客户端</p></li></ul><h3 id="查询区别"><a href="#查询区别" class="headerlink" title="查询区别"></a>查询区别</h3><ul><li>迭代查询本地服务器会发送多次查询请求，递归查询本地服务器会发送一次查询请求</li><li>递归查询域名解析系统需要维护并转发查询请求，而迭代查询只需要响应一次查询请求</li><li>一般主机和本地服务器之间使用递归查询，本地服务器和域名解析系统之间使用迭代查找</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>本地域名服务器一般会缓存顶级域名服务器的映射</p><h3 id="DNS-记录"><a href="#DNS-记录" class="headerlink" title="DNS 记录"></a>DNS 记录</h3><p>格式：$(name, value,type,ttl)$，$ttl$ 表示时间有效性</p><p><code>type = A</code> 时，<code>name</code> 表示主机域名，<code>value</code> 表示 IP 地址</p><p><code>type = NS</code> 时，<code>name</code> 表示域（比如<code>edu.cn</code>），<code>value</code> 表示权威域名服务器的主机域名</p><p><code>type = CNAME</code> 时，<code>name</code> 表示真实域名的别名，<code>value</code> 表示真实域名</p><p><code>type = MS</code> 时，<code>value</code> 是与 <code>name</code> 相对应的邮件服务器</p><h3 id="DNS-底层协议"><a href="#DNS-底层协议" class="headerlink" title="DNS 底层协议"></a>DNS 底层协议</h3><p>DNS 可以使用 UDP 或 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）</li></ul><h2 id="Email-应用"><a href="#Email-应用" class="headerlink" title="Email 应用"></a>Email 应用</h2><p>Email 应用包括邮件客户端、邮件服务器和邮件协议。邮件协议包含发送协议和读取协议，发送协议通常使用 SMTP 协议，读取协议通常使用 POP3 或 IMAP 协议。</p><ul><li>邮件客户端：发送、接收邮件</li><li>邮件服务器：为每一个用户分配一个邮箱，并使用一个消息队列存储等待发送的邮件</li><li>邮件协议：邮件服务器之间传递消息所使用的协议</li></ul><h3 id="发送协议"><a href="#发送协议" class="headerlink" title="发送协议"></a>发送协议</h3><p>SMTP 协议是发送协议，依赖于 TCP 协议，使用命令 / 响应模式进行交互，SMTP 占用的端口号是 25 。</p><ul><li>持久性连接：只建立一次 TCP 请求</li><li>消息必须使用 7 位 ASCII 码</li><li>SMTP 使用回车换行确认消息结束</li></ul><h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2m3je77w5j209v07fmxd.jpg" alt="pic"></p><ul><li><p>header：To、From、Subject</p></li><li><p>body：消息本身，只能是 ASCII</p></li></ul><h4 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h4><p>为了进行多媒体邮件扩展，在邮件头部增加额外的行声明 MIME 的内容类型，来支持发送多媒体。MIME 可以发送二进制文件，MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2m3ovdd3gj20iu072n0t.jpg" alt="pic"></p><h3 id="读取协议"><a href="#读取协议" class="headerlink" title="读取协议"></a>读取协议</h3><p>邮件读取协议又称邮件访问协议，主要有 POP3 和 IMAP 协议。</p><ul><li>POP3：提供认证/授权和下载功能，无状态协议</li><li>IMAP：更复杂，更多功能，能够操纵邮件服务器上的消息</li><li>HTTP：网页邮件</li></ul><h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><ul><li>认证过程：客户端发送用户名和密码，服务端响应</li><li>事务阶段：<ul><li>List：列出消息数量</li><li>Retr：用编号获取消息</li><li>Dete：删除邮件</li><li>Quit：退出</li><li>…</li></ul></li></ul><p>POP3 模式：</p><ul><li><p>下载并删除：下载后在服务器删除</p></li><li><p>下载并保持：下载后服务器也会继续保存，支持不同客户端多次浏览</p></li></ul><h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><ul><li>所有消息保存在服务器上</li><li>允许用户利用文件夹组织信息</li><li>IMAP 是有状态协议</li></ul><h2 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h2><p>P2P 没有明确的客户端和服务器的角色，而是点对点的应用，P2P 采用共享的机制分发文件。</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>占用网络带宽</li><li>助长病毒传播</li><li>版权问题</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li><p>集中式索引</p><p>节点加入时将 IP 和持有的内容通知给中央服务器，中央服务器去维护所有节点的索引信息。集中索引存在单点故障、性能瓶颈、版权等问题</p></li><li><p>洪泛式查询</p><p>完全分布式的架构，每个节点对它共享的文件进行索引且只对它共享的文件进行索引。查询时向已有的 TCP 连接发送查询请求，任何收到查询请求的节点会转发查询请求。如果查询命中，利用反向路径发回查询节点</p></li><li><p>层次式覆盖网络</p><p>层次式覆盖网络是介于集中式索引和洪泛式查询之间的方法。网络节点分为两类：普通节点和超级节点。普通节点只和超级节点建立 TCP 连接，这部分可以看成集中式索引；超级节点维护索引信息，超级节点之间建立 TCP 连接，这部分可以看成洪泛式查询</p><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2mr1pe0skj208w07rjrt.jpg" alt="pic"></p></li></ul><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><blockquote><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/计算机网络%20-%20应用层?id=文件传送协议" target="_blank" rel="noopener">FTP</a></p></blockquote><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><blockquote><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/计算机网络%20-%20应用层?id=动态主机配置协议" target="_blank" rel="noopener">DHCP</a></p></blockquote><p>一个主机如何获取 IP 地址：</p><ul><li>静态配置： IP 地址、子网、默认网关和本地域名服务器 DNS</li><li>动态配置：动态主机配置协议 DHCP，从 DHCP 服务器获取 IP 地址。DHCP 能够保证主机即插即用，并且允许地址重用</li></ul><p>过程：</p><ul><li>主机发送”DHCP discover”发现报文，源 IP 地址和端口号是 $0.0.0.0:68$，目的 IP 地址和端口号是 $255.255.255.255:67$。广播的原因是为了发现子网内的 DHCP 服务器</li><li>DHCP 服务器利用”DHCP offer“ 提供报文进行响应，DHCP 进行广播的原因是因为此时主机还没有 IP 地址</li><li>主机发送 ”DHCP request“ 请求报文，继续广播，原因是可能有多个 IP 地址，主机携带接受的 IP ，其他 DHCP 服务器可以为其他主机分配 IP</li><li>DHCP 服务器发送”DHCP ACK“ 确认报文，DHCP 进行广播的原因是因为此时主机还没有 IP 地址，最后主机动态分配了一个 IP 地址</li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2oc6y9wjtj20ec0bkn04.jpg" alt="pic"></p><p>不过客户获取的IP一般是用租期，到期前需要更新租期</p><ul><li>当租期使用 50% ，客户端直接向为其提供 IP 的DHCP 服务器发送 DHCP request 报文</li><li>如果收到 DHCP 服务器 ACK 报文更新租期；如果没有收到 ACK 报文继续使用</li><li>当租期使用 87.5% ，再次向为其提供 IP 的DHCP 服务器发送 DHCP request 报文</li><li>如果收到 DHCP 服务器 ACK 报文更新租期；如果没有收到 ACK 报文发送 DHCP offer 重新获取 IP</li></ul><h2 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义</p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>Socket API 对外使用 IP 地址和端口号来区分 Socket，对内操作系统使用套接字描述符来区分 Socket 。每个进程有一个端口号，可以有多个 Socket 。每个进程维护一个 Socket 描述符表，存储套接字描述符，套接字描述符指向对应的 Socket 数据结构。Socket 数据结构中包含源 IP 地址，源端口号，目的 IP 地址和目的端口号，以此来区分唯一 Socket 连接</p><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2mutpcdlwj20hz0810v4.jpg" alt="pic"></p><p>端口号的范围是$0 \sim 65535$，其中 $0 \sim 1023$ 是知名端口号， $1024 \sim 65535$ 动态端口号。知名端口号为特定的网络应用提供服务端口</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2mwyyx1rtj20ip0atn0x.jpg" alt="pic"></p><h3 id="处理单个连接请求"><a href="#处理单个连接请求" class="headerlink" title="处理单个连接请求"></a>处理单个连接请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.apathy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个连接的demo</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>); <span class="comment">// 创建 Socket</span></span><br><span class="line">        Socket socket = serverSocket.accept(); <span class="comment">// 监听客户端连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建输入输出流</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedInputStream(socket.getInputStream()));</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> length = dis.readDouble();</span><br><span class="line">            <span class="keyword">if</span>(length &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(<span class="string">"服务器端收到的正方形边为："</span> + length);</span><br><span class="line">            <span class="keyword">double</span> result = length * length;</span><br><span class="line">            dos.writeDouble(result);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.apathy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedInputStream(socket.getInputStream()));</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 for 循环模拟多次计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入正方形边长（小于0退出）"</span>);</span><br><span class="line">            <span class="keyword">double</span> length = i - <span class="number">0.5</span>;</span><br><span class="line">            dos.writeDouble(length);</span><br><span class="line">            dos.flush();</span><br><span class="line">            <span class="keyword">if</span>(length &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">double</span> res = dis.readDouble();</span><br><span class="line">            System.out.println(<span class="string">"计算结果为："</span> + res);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理多个连接请求"><a href="#处理多个连接请求" class="headerlink" title="处理多个连接请求"></a>处理多个连接请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.apathy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        AtomicInteger number = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                exec.execute(<span class="keyword">new</span> SimpleServer(socket, number.getAndIncrement()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleServer</span><span class="params">(Socket socket, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"客户端 "</span> + num + <span class="string">"建立连接"</span>);</span><br><span class="line">            dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(socket.getInputStream()));</span><br><span class="line">            dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">double</span> length = dis.readDouble();</span><br><span class="line">                <span class="keyword">if</span>(length &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(<span class="string">"收到客户端 "</span> + num+ <span class="string">" 的正方形边为："</span> + length);</span><br><span class="line">                <span class="keyword">double</span> result = length * length;</span><br><span class="line">                dos.writeDouble(result);</span><br><span class="line">                dos.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis != <span class="keyword">null</span>)</span><br><span class="line">                    dis.close();</span><br><span class="line">                <span class="keyword">if</span>(dos != <span class="keyword">null</span>)</span><br><span class="line">                    dos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步-IO-处理多个请求"><a href="#异步-IO-处理多个请求" class="headerlink" title="异步 IO 处理多个请求"></a>异步 IO 处理多个请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">package</span> com.apathy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketNIOService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Selector sel = Selector.open(); <span class="comment">// 创建选择器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ServerSocketChannel，监听新进来的TCP连接</span></span><br><span class="line">        ServerSocketChannel socketChannel = ServerSocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 设置非阻塞 IO</span></span><br><span class="line">        <span class="comment">/* 将通道注册到选择器上</span></span><br><span class="line"><span class="comment">        SelectionKey.OP_CONNECT:连接就绪，一个Channel成功连接到另一个服务器</span></span><br><span class="line"><span class="comment">        SelectionKey.OP_ACCEPT：接收就绪，一个ServerSocketChannel准备好接收新进入的连接</span></span><br><span class="line"><span class="comment">        SelectionKey.OP_READ：读就绪，一个有数据可读的通道</span></span><br><span class="line"><span class="comment">        SelectionKey.OP_WRITE：写就绪，一个等待写数据的通道</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        socketChannel.register(sel, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 ServerSocketChannel 绑定到特定端口</span></span><br><span class="line">        ServerSocket serverSocket = socketChannel.socket(); <span class="comment">// 创建套接字</span></span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address); <span class="comment">// 绑到特定端口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            sel.select(); <span class="comment">// 监听事件，没有事件会阻塞</span></span><br><span class="line">            Set&lt;SelectionKey&gt; set = sel.selectedKeys(); <span class="comment">// 获取到达的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = set.iterator(); <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123; <span class="comment">// 轮询</span></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;  <span class="comment">// 连接就绪</span></span><br><span class="line">                    <span class="comment">// 如果是连接请求，将连接通道注册到 selector 上</span></span><br><span class="line">                    ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    sc.register(sel, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;  <span class="comment">// 读就绪</span></span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sc));</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">package</span> com.apathy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketNIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream ops = socket.getOutputStream();</span><br><span class="line">        String str = <span class="string">"hello, apathy"</span>;</span><br><span class="line">        ops.write(str.getBytes());</span><br><span class="line">        ops.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Code </tag>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-进程管理</title>
      <link href="/2019/04/27/00022/"/>
      <url>/2019/04/27/00022/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/456K3DVxJr1COwh.jpg" alt="SurfboardRow_ZH-CN5154549470_1920x1080.jpg"></p><a id="more"></a><h2 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是指具有一定独立功能的程序在一个数据集上的一次动态执行过程，进程是资源分配的基本单位</p><h4 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h4><ul><li>动态性：可以动态创建、结束进程</li><li>并发性：进程之间可以通过时间片轮询并发执行</li><li>独立性：不同进程工作互不影响，需要通过进程通信</li><li>制约性：多个进程访问临界资源时需要实现同步机制</li></ul><h4 id="进程-amp-程序"><a href="#进程-amp-程序" class="headerlink" title="进程 &amp; 程序"></a>进程 &amp; 程序</h4><ul><li>进程是处于执行状态的程序的抽象，包括程序和执行状态；程序是静态可执行文件</li><li>同一个程序的多次执行对应着不同的进程</li><li>进程是资源分配的基本单位，进程运行需要系统资源，比如 CPU 和内存</li><li>进程是动态的，程序是静态的</li><li>进程是暂时的，程序是永久的</li></ul><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>进程控制块是操作系统管理控制进程运行的信息集合，描述了进程的基本信息和运行状态。创建进程时生成该进程的进程控制块，进程终止时回收进程控制块，操作系统通过进程控制块来管理控制进程</p><h4 id="进程控制块内容"><a href="#进程控制块内容" class="headerlink" title="进程控制块内容"></a>进程控制块内容</h4><ul><li>进程标识信息：FID，UID 等</li><li>进程控制信息：进程所用资源、进程间通信信息、调度和状态信息等</li><li>现场保存：寄存器</li></ul><p>进程地址空间中保存了初始化数据、代码、堆栈、段表、共享库等，抽取一部分信息放在进程控制块中</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><img data-src="https://i.loli.net/2019/04/28/5cc521ca62966.png" alt="pic"></p><ul><li>创建（created）</li><li>就绪（ready）：进程获取了除 CPU 之前的资源，等待被调度</li><li>运行（running）：正在执行的进程</li><li>阻塞（waiting）：等待资源或等待某个事件的出现</li><li>终止（terminated）</li></ul><p>创建 - &gt; 就绪：进程被创建，完成初始化，一切就绪工作执行完就会进入就绪状态</p><p>就绪 -&gt; 运行：当前进程时间片执行完，CPU 使用进程调度算法从就绪队列中选择一个进程执行</p><p>运行 -&gt; 就绪：运行状态的进程时间片用完或高优先级进程抢占低优先级进程时间片</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可以有多个线程，线程能够提高进程内部的并发性，是独立调度的基本单位。线程共享同一进程的资源</p><p>线程的地址空间类似于 Java 运行时数据区域</p><ul><li>用户线程：线程功能在用户态实现，开发者能够制定自己的线程调度算法，不需要进入内核态，开销小；但进程是独立调度的基本单位</li><li>内核线程（正在使用的）：线程功能由操作系统完成，线程是独立调度的基本单位；线程调度需要进入内核态，开销比较大</li></ul><h3 id="进程和线程的比较"><a href="#进程和线程的比较" class="headerlink" title="进程和线程的比较"></a>进程和线程的比较</h3><ul><li>进程是资源分配的基本单位，线程是独立调度的基本单位</li><li>进程的系统开销比线程大</li><li>线程共享进程的资源，通信方便；进程通信需要借助进程通信机制</li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ul><li>暂停当前进程，保存进程状态到 PCB 中，从运行状态变成其他状态</li><li>调度另一个进程，从PCB中恢复现场，从就绪状态变为运行状态</li></ul><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><ul><li>fork：创建子进程，子进程完全复制父进程的地址空间，但子进程有自己的进程ID</li><li>exec：加载可执行文件并覆盖进程的地址空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共有两个进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childId;</span><br><span class="line">    childId = fork(); <span class="comment">// 创建子进程，对父进程地址空间的一次复制。父进程返回子进程ID，子进程返回0</span></span><br><span class="line">    <span class="keyword">if</span>(childId == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行子进程</span></span><br><span class="line">        exec(); <span class="comment">// 加载子进程代码，会替换掉父进程的代码</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//　执行父进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共有四个进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">// 子进程代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h3><ul><li>CPU 利用率：CPU处于忙状态的时间百分比</li><li>吞吐量：单位时间内完成的进程数量</li><li>周转时间：进程从初始化到结束的总时间</li></ul><h3 id="调度策略的目标"><a href="#调度策略的目标" class="headerlink" title="调度策略的目标"></a>调度策略的目标</h3><ul><li>减少响应时间</li><li>减少响应时间的波动</li><li>公平性</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p>先来先服务：依据进程进入优先队列的先后顺序排列。当前进程进入阻塞或终止状态时，就绪队列中的下一个进程占用 CPU</p><p>3个进程ABC依次到达，计算时间分别为12 3 3，则 FCFS 的周转时间为<br>$$<br>(12+15+18)/3=15<br>$$<br>优点：简单</p><p>缺点：平均等待时间波动较大；IO 资源和 CPU 资源利用率低</p></li><li><p>短进程优先：平均周转时间短</p><ul><li><p>短作业优先：选择执行时间最短的进程占用 CPU</p><p>优点：有最优周转时间</p><p>缺点：不公平，导致长进程饥饿，需要预知未来执行时间</p></li><li><p>最短剩余时间优先：选择剩余时间最短的进程占用 CPU</p></li></ul></li><li><p>最高响应比优先：依据就绪队列中进程等待时间的长短</p><p>能够解决饥饿现象</p></li><li><p>时间片轮转：时间片结束后，按照先来先服务算法切换到下一个进程</p><p>优点：公平</p><p>缺点：平均等待时间较差</p></li><li><p>优先级调度：为每个进程分配一个优先级，按优先级进行调度</p></li><li><p>多级反馈队列：将就绪队列排成多个子队列，不同子队列时间片长短不同，优先级不同</p><p>每个队列可以拥有自己的调度策略</p></li></ul><p>不同的系统对进程调度的要求不一样：</p><ul><li>批处理系统：要求高吞吐量和较短的周转时间</li><li>交互式系统：要求响应时间短</li><li>实时系统：要求一个请求在一个确定时间内得到响应</li></ul><h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>对临界资源进行访问的需要互斥执行的那段代码称为临界区</p><h3 id="临界区的实现"><a href="#临界区的实现" class="headerlink" title="临界区的实现"></a>临界区的实现</h3><ul><li><p>禁用中断：禁用时钟中断，没有上下文切换，即保证了同一时刻只有一个进程访问临界资源</p><p>缺点：禁用中断后，进程无法被停止，可能导致其他进程处于饥饿状态</p></li><li><p>软件实现：通过进程之间共享变量的方式实现</p></li><li><p>更高级的抽象方法</p><ul><li>原子操作指令锁（单CPU和多CPU均可）</li><li>信号量</li><li>管程</li></ul></li></ul><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>操作系统提供的互斥资源访问的方法</p><p>信号是一种抽象数据结构，由一个整型变量（$sem$）和两个原子操作组成，并且包含等待队列</p><ul><li>P意味着信号量值减1，减完之后如果信号量值小于0，则说明资源不够用的，把进程加入等待队列</li><li>V意味着信号量值加1，加完之后如果信号量值小于等于0，则说明等待队列里有进程，那么唤醒一个等待进程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem--;</span><br><span class="line">    <span class="keyword">if</span>(sem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem++;</span><br><span class="line">    <span class="keyword">if</span>(sem &lt;= <span class="number">0</span>) &#123; <span class="comment">// 说明前边还有等待的进程</span></span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P 和 V 操作由操作系统保证原子性，比如说屏蔽中断。如果信号量只能取 0 和 1，他就是互斥量</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><ul><li><p>管程是一种用于多线程访问互斥访问共享资源的程序结构</p></li><li><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作</p></li><li><p>管程包括一个锁、一个或多个条件变量</p></li><li><p>管程可以放弃临界资源访问权</p></li></ul><h3 id="管程-amp-信号量"><a href="#管程-amp-信号量" class="headerlink" title="管程 &amp; 信号量"></a>管程 &amp; 信号量</h3><ul><li>信号量先检查资源信号量，才能进入临界区；管程可以先进入临界区再去检查条件变量</li><li>在管程中的线程可以临时放弃管程的互斥访问，让其他线程进入到管程中来；临界区中的线程只能在线程退出临界区时，才可以放弃对临界区的访问</li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>同时拿左边或同时拿右边会死锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line">semaphone fork[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            p(fork[i]);</span><br><span class="line">            p(fork[(i+<span class="number">1</span>)%N]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            p(fork[(i+<span class="number">1</span>)%N]);</span><br><span class="line">            p(fork[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        eat();</span><br><span class="line">        v(fork[i]);</span><br><span class="line">        v(fork[(i+<span class="number">1</span>)%N]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line">semaphone fork[<span class="number">5</span>];</span><br><span class="line">semaphone mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        p(mutex);</span><br><span class="line">        p(fork[i]);</span><br><span class="line">        p(fork[(i+<span class="number">1</span>)%N]);</span><br><span class="line">        eat();</span><br><span class="line">        v(fork[i]);</span><br><span class="line">        v(fork[(i+<span class="number">1</span>)%N]);</span><br><span class="line">        v(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81" target="_blank" rel="noopener">死锁</a></p></blockquote><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>互斥</li><li>持有并等待<ul><li>进程持有至少一个资源，并等待其他进程持有的资源</li></ul></li><li>非抢占</li><li>循环等待</li></ul><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><ul><li><p>死锁预防：采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件</p><ul><li>持有并等待<ul><li>进程请求资源时，要求他不持有任何其他资源</li><li>仅允许进程在开始执行时，一次请求所有需要的资源</li></ul></li></ul></li><li><p>死锁避免</p><ul><li>银行家算法</li></ul></li><li><p>死锁检测和恢复</p><ul><li>允许操作系统出现死锁</li><li>维护系统的资源分配图</li><li>定期用死锁检测算法来搜索图中是否存在死锁</li><li>出现死锁时，用死锁恢复机制进行恢复</li></ul><p>死锁检测算法和银行家算法相似</p></li></ul><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>银行家算法是一种死锁避免的算法</p><p>银行家 -&gt; 操作系统</p><p>资金 -&gt; 系统资源</p><p>客户 -&gt; 进程</p><hr><p>n = 线程总数<br>m = 资源类型数量<br>Available（剩余空闲量）：长度为m的向量<br>Max（总需求量）：n×m矩阵<br>Allocation（已分配量）：n×m矩阵<br>Need（未来需要量）：n×m矩阵<br>$$<br>Need[i,j] = Max[i,j]-Allocation[i,j]<br>$$</p><hr><p>安全：</p><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lnvw77fgj20g807nae0.jpg" alt="pic"></p><p>不安全：</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lnwc5lhzj20hv095aer.jpg" alt="pic"></p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信是进行信息交流和同步的机制。通信具有两种基本操作：发送操作和接收操作</p><p>直接通信和间接通信</p><ul><li>直接通信：两个进程通过共享信道实现通信</li><li>间接通信：在内核建立消息队列</li></ul><p>阻塞通信和非阻塞通信</p><ul><li>阻塞通信<ul><li>阻塞发送：发送者发送消息后进入等待，直到接收者成功接收到</li><li>阻塞接收：接收者请求消息后进入等待，直到成功接收消息</li></ul></li><li>非阻塞通信<ul><li>非阻塞发送：发送者发送消息之后执行其他操作</li><li>非阻塞接收：没有消息时，接收者请求接收消息，不会得到任何消息</li></ul></li></ul><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>进程间的软件中断通知和处理机制</p><p>信号的接收处理：</p><ul><li>捕获</li><li>忽略</li><li>屏蔽</li></ul><p>缺点：传送信息少，只有一个信号类型</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>进程间基于内存文件的通信机制</p><p>缺点：</p><ul><li>只支持半双工通信（双向交替传输）</li><li>只能在父子进程中使用</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是把同一个物理内存区域映射到多个进程的内存地址空间的通信机制</p><p>优点：快</p><p>缺点：不提供同步，需要程序员实现同步机制</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating Systems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设备管理</title>
      <link href="/2019/04/27/00021/"/>
      <url>/2019/04/27/00021/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/VBSkWXtsPEuy1r4.jpg" alt="SanSebastianFilm_ZH-CN5506786379_1920x1080.jpg"></p><a id="more"></a><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><blockquote><p><a href="https://www.cnblogs.com/jswang/p/9071847.html" target="_blank" rel="noopener">硬盘基本知识（磁头、磁道、扇区、柱面）</a></p><p><a href="https://blog.csdn.net/hguisu/article/details/7408047" target="_blank" rel="noopener">磁盘的读写原理</a></p></blockquote><ul><li>一个磁盘包括多个盘片，每个盘片包含两个面，每个面都有一个磁头，用来将磁信号转换成电信号（读）或将电信号转换成磁信号（写）</li><li>每个盘面包括多个磁道，每个磁道划分成多个扇区，扇区是最小的存储单位</li><li>磁盘使用主轴进行旋转，使用磁臂进行寻道</li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2lnelq5k6j20j60fiq8p.jpg" alt="pic"></p><h2 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h2><p>$$<br>容量 = 盘面数 × 每个盘面的磁道数 × 每个磁道的扇区数 × 扇区大小<br>$$</p><h2 id="磁盘读取时间"><a href="#磁盘读取时间" class="headerlink" title="磁盘读取时间"></a>磁盘读取时间</h2><p>当需要从磁盘读取数据时，操作系统将逻辑地址传给磁盘，磁盘的控制电路将逻辑地址翻译成物理地址</p><ol><li><p>寻道时间：磁臂移动，寻找合适磁道；寻道时间最长</p></li><li><p>旋转时间：主轴转动盘面，寻找合适扇区；每分钟能几千甚至上万转</p></li><li><p>数据传输时间</p></li></ol><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>磁盘调度算法的目的是使平均寻道时间最短</p><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>按照磁盘请求顺序进行调度</p><ul><li><p>优点：简单公平</p></li><li><p>没有考虑磁道的距离，导致平均寻道时间过长</p></li></ul><h3 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h3><p>优先调度与当前磁头最近的磁道</p><ul><li><p>平均寻道时间短</p></li><li><p>不公平，两端的磁道容易出现饥饿现象</p></li></ul><h3 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h3><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向</p><ul><li>解决了两端磁道的饥饿现象</li></ul><h2 id="磁盘读写"><a href="#磁盘读写" class="headerlink" title="磁盘读写"></a>磁盘读写</h2><p>操作系统将数据存储到磁盘，按照柱面、磁头、扇区的方式进行。从外到内，从上到下</p><p>柱面编号由外到内依次递增，磁头编号从上到下依次递增。首先将数据存储在第一盘面的第一磁道的所有扇区中，然后是同一柱面的下一个磁头。一个柱面的所有磁道存储满之后推进到下一个柱面</p><h2 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>当一个数据被用到时，其附近的数据也通常会马上被使用</p><h3 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h3><p>为了减少 IO 操作，磁盘往往不是按需读取，而是每次都会预读。预读过程中磁盘会进行顺序读取，顺序读取不需要磁盘并且只需要很短的旋转时间，所以预读可以提高 IO 效率，速度非常快。预读的长度一般为页的整倍数</p><h2 id="磁盘碎片"><a href="#磁盘碎片" class="headerlink" title="磁盘碎片"></a>磁盘碎片</h2><p>磁盘是连续存储的。增加数据时，需要将增加的数据存储到磁盘的别处；删除数据时，就会产生小碎片</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating Systems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2019/04/26/00020/"/>
      <url>/2019/04/26/00020/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/WjsxNtnEziaOM3P.jpg" alt="SquirrelHeather_ZH-CN1683129884_1920x1080.jpg"></p><a id="more"></a><p>Spring 是轻量级的 IOC 和 AOP 框架，是为 Java 应用程序提供基础服务的框架。目的是为了简化企业应用程序的开发，让开发人员只关心业务逻辑。Spring 是模块式的框架，包括 20 多个模块。</p><ul><li>Spring core：提供 IOC 容器</li><li>Spring context：提供 Spring 应用程序上下文信息</li><li>Spring AOP：提供 AOP 功能</li><li>Spring Dao：提供数据库访问的统一接口，对 JDBC 的抽象和封装</li><li>Spring ORM：集成 ORM 框架，比如 Struts、Mybatis 等</li><li>Spring Web：提供 Spring web 程序的上下文信息</li><li>Spring MVC：Spring 的 MVC 框架</li></ul><h2 id="Spring-优点"><a href="#Spring-优点" class="headerlink" title="Spring 优点"></a>Spring 优点</h2><ul><li>Spring 简化企业应用程序的开发，使开发人员只关心业务逻辑</li><li>Spring 使用 IOC 容器管理 bean，可以通过 DI 注入对象，减小了代码的耦合度</li><li>Spring 提供 AOP 技术，提高代码的可复用性。通过使用 AOP 可以实现事务、权限校验、日志、安全等功能</li><li>Spring 对主流框架提供了集成支持，方便开发人员灵活的选择技术</li></ul><h2 id="IOC-初始化过程"><a href="#IOC-初始化过程" class="headerlink" title="IOC 初始化过程"></a>IOC 初始化过程</h2><ul><li><p>Resource 定位（Bean 的定义文件定位）</p><p>获取文件。Resource 是 Spring 封装的 IO 操作接口，可以读取 XML、文件、二进制流、classpath 等</p></li><li><p>将 Resource 定位好的资源载入到 BeanDefinition</p><p>解析文件。bean 在 Spring IOC 内部被表示成了 BeanDefinition 这种数据结构</p></li><li><p>将 BeanDefinition 注册到容器中</p><p>将 BeanDefinition 封装成 BeanDefinitionHolder 类并注册到 beanDefinitionMap 中</p></li></ul><h2 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h2><p>Spring IOC 容器主要包括 BeanFactory 和 ApplicationContext 两类，用于创建和管理 bean 。bena 的生命周期中涉及两个易混淆的概念：</p><ul><li>实例化：创建对象，并为对象开辟空间</li><li>初始化：对对象中的值赋上初始值</li></ul><h3 id="ApplicationContext-生命周期"><a href="#ApplicationContext-生命周期" class="headerlink" title="ApplicationContext 生命周期"></a>ApplicationContext 生命周期</h3><ul><li>由 ApplicationContext 读取配置文件或配置类，并通过 Java 反射机制调用 bean 的构造方法生成实例</li><li>setter 方法注入</li><li>如果实现了 <code>BeanNameAware</code> 接口，执行 <code>setBeanName()</code> 方法（为 bean 命名）</li><li><strong>如果实现了 <code>ApplicationContextAware</code> 接口，执行 <code>setApplicationContext()</code> 方法</strong></li><li>如果实现了 <code>BeanPostProcessor</code> 接口，执行 <code>processBeforeInitialization()</code> 方法（初始化前代理）</li><li>如果实现了 <code>InitializingBean</code> 接口，执行  <code>afterPropertiesSet()</code> 方法</li><li>如果定义了 <code>init-method</code> ，执行 <code>init-method</code> 方法（初始化方法）</li><li>如果实现了 <code>BeanPostProcessor</code>  接口，执行 <code>processAfterInitialization()</code> 方法（初始化后代理）</li><li>如果实现了 <code>DisposableBean</code> 接口，在容器关闭时执行 <code>destroy()</code> 方法</li><li>如果定义了 <code>destory-method</code> ，在容器关闭时执行 <code>destory-method</code> 方法</li></ul><h3 id="BeanFactory-amp-ApplicationContext"><a href="#BeanFactory-amp-ApplicationContext" class="headerlink" title="BeanFactory &amp; ApplicationContext"></a>BeanFactory &amp; ApplicationContext</h3><ul><li>BeanFactory 是 Spring 中最底层的接口，提供了实例化对象和获取对象的方法；ApplicationContext 是 BeanFactory 的子接口，并提供了更多的功能，包括国际化、载入多个上下文、AOP 等</li><li>BeanFactory 在启动时不会实例化 bean，只有在使用时才会去实例化；ApplicationContext 在启动时就会实例化 bean</li></ul><h2 id="Bean-作用域"><a href="#Bean-作用域" class="headerlink" title="Bean 作用域"></a>Bean 作用域</h2><ul><li>singleton</li><li>prototype</li><li>request</li><li>session</li><li>global-session：仅在门户网站中有意义</li></ul><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><blockquote><p><a href="https://segmentfault.com/a/1190000013882720#articleHeader8" target="_blank" rel="noopener">循环依赖问题</a></p></blockquote><ul><li>构造器循环依赖：无法解决，抛出 <code>BeanCurrentlyInCreationException</code> 异常</li><li>setter 方法循环依赖：只能解决单例作用域的循环依赖</li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><blockquote><p><a href="https://segmentfault.com/a/1190000007469968" target="_blank" rel="noopener">彻底征服 Spring AOP 之 理论篇</a><br><a href="https://segmentfault.com/a/1190000007469982" target="_blank" rel="noopener">彻底征服 Spring AOP 之 实战篇</a></p></blockquote><p>AOP 全称是面向切面编程，是面向对象编程的补充。 AOP 将可重用代码抽取出来并封装在一个模块中，便于代码复用。使用 AOP 可以实现事务、安全、日志和权限校验等功能。Spring AOP 是基于动态代理的，使用 JDK 动态代理和 cglib 动态代理。</p><ul><li>静态代理：在编译阶段生成 AOP 代理类，也称为编译时增强。在编译时将切面织入 Java 字节码中，运行时就是被增强的 AOP 对象</li><li>动态代理：不修改 Java 字节码，而是在运行时在内存中生成 AOP 对象，这个对象包含了目标对象的全部方法，并且在特定的切点进行了增强</li></ul><h3 id="AOP-执行顺序"><a href="#AOP-执行顺序" class="headerlink" title="AOP 执行顺序"></a>AOP 执行顺序</h3><p>没有异常的执行顺序：</p><ul><li>around before advice</li><li>before advice</li><li>target method</li><li>around after advice</li><li>after advice</li><li>afterReturning</li></ul><p>有异常的执行顺序：</p><ul><li>around before advice</li><li>before advice</li><li>target method</li><li>around after advice</li><li>after advice</li><li>afterThrowing</li><li>java.lang.RuntimeException</li></ul><h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><blockquote><p><a href="https://segmentfault.com/a/1190000013341344#articleHeader8" target="_blank" rel="noopener">spring 事务传播行为详解</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    methodB();</span><br><span class="line">    methodC();</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transaction</span>(Propagation=XXX)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transaction</span>(Propagation=XXX)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Propagation_REQUIRED</code></p><ul><li>如果外围方法<code>methodA()</code>未开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>会自己的创建事务，并且事务之间相互独立</li><li>如果外围方法<code>methodA()</code>开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>会使用外围方法的事务，即三个方法使用一个事务。只要有一个方法回滚，整个事务回滚</li></ul></li><li><p><code>PROPAGATION_REQUIRES_NEW</code></p><ul><li>如果外围方法<code>methodA()</code>未开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>会自己的创建事务，并且事务之间相互独立</li><li>如果外围方法<code>methodA()</code>开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>会自己的创建事务，并且事务之间相互独立，和外围事务也相互独立</li></ul></li><li><p><code>PROPAGATION_NESTED</code></p><ul><li>如果外围方法<code>methodA()</code>未开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>会自己的创建事务，并且事务之间相互独立</li><li>如果外围方法<code>methodA()</code>开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>的事务是外围方法的子事务，属于嵌套关系，外围事务回滚，子事务一定回滚；子事务回滚，不影响外围事务和其他子事务</li></ul></li><li><p><code>PROPAGATION_SUPPORTS</code></p><ul><li>如果外围方法<code>methodA()</code>未开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>以非事务方式运行</li><li>如果外围方法<code>methodA()</code>开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>使用外围方法的事务</li></ul></li><li><p><code>PROPAGATION_MANDATORY</code></p><ul><li>如果外围方法<code>methodA()</code>未开启事务，抛异常</li><li>如果外围方法<code>methodA()</code>开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>使用外围方法的事务</li></ul></li><li><p><code>PROPAGATION_NOT_SUPPORTED</code></p><ul><li><p>如果外围方法<code>methodA()</code>未开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>以非事务方式运行</p></li><li><p>如果外围方法<code>methodA()</code>开启事务，将外围方法的事务挂起，内部方法<code>methodB()</code>和<code>methodC()</code>以非事务方式运行</p></li></ul></li><li><p><code>PROPAGATION_NEVER</code></p><ul><li>如果外围方法<code>methodA()</code>开启事务，抛出异常</li><li>如果外围方法<code>methodA()</code>未开启事务，内部方法<code>methodB()</code>和<code>methodC()</code>以非事务方式运行</li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://blog.csdn.net/a745233700/article/details/80959716" target="_blank" rel="noopener">Spring常见面试题总结</a></p></li><li><p><a href="https://www.jianshu.com/p/63ad69c480fe/" target="_blank" rel="noopener">Spring Boot 面试题</a></p></li><li><p><a href="http://ifeve.com/spring-interview-questions-and-answers/" target="_blank" rel="noopener">69道Spring面试题和答案</a></p></li><li><p><a href="https://www.cnblogs.com/jingmoxukong/p/9408037.html" target="_blank" rel="noopener">Spring 面试问题 TOP 50</a></p></li><li><p><a href="https://segmentfault.com/a/1190000013882720" target="_blank" rel="noopener">Spring 常见的一些面试题整理</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-内存管理</title>
      <link href="/2019/04/26/00019/"/>
      <url>/2019/04/26/00019/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/6WpUfRxqDmSIya4.jpg" alt="DaintreeRiver_ZH-CN2284362798_1920x1080.jpg"></p><a id="more"></a><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>$$<br>1 B = 8 Bit \<br>1 KB = 1024 B \<br>1 MB = 1024 KB \<br>1 GB = 1024 GB<br>$$</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul><li>CPU 寄存器<ul><li>CPU 中包含算数逻辑单元（ALU）、内存管理单元（MMU）、寄存器、高速缓存和控制逻辑</li></ul></li><li>内存</li><li>外存（虚拟内存）：存储在磁盘中</li><li>磁盘</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>抽象：将物理地址抽象成逻辑地址</li><li>保护：各个进程拥有独立的地址空间，每个进程拥有的内存不会被其他进程破坏</li><li>共享：进程共享内核地址空间，减少内存使用</li><li>虚拟：将物理内存抽象成更大的逻辑内存</li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><p>给进程分配一块不小于指定大小的连续的物理内存区域</p><p>方法：</p><ul><li>最先匹配策略：搜索到第一个匹配的连续物理区域</li><li>最佳匹配策略：搜索到比指定大小大并且大的最少的连续物理区域</li><li>最差匹配策略：搜索到最大的连续物理内存区域</li></ul><p>缺点：会产生内存碎片</p><ul><li>内部碎片：进程内存内部存在没有被利用的空间</li><li>外部碎片：不同进程内存之间存在没有被利用的空间</li></ul><h3 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h3><ul><li>分页</li><li>分段</li><li>段页式</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存简介"><a href="#虚拟内存简介" class="headerlink" title="虚拟内存简介"></a>虚拟内存简介</h3><p>虚拟内存是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p><p>操作系统将内存抽象成地址空间，16位操作系统的地址空间大小是$2^{16}B (0 \sim 64K)$；32位操作系统的地址空间大小是$2^{32}B(0 \sim 4G)​$</p><p>地址空间被划分成多个块，每一块称为一页，一页的大小通常为$4K$ ，16位操作系统共有$16$个页；32位操作系统共有$2^{20}​$个页。这些页通过内存管理单元被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有的页都在物理内存中</p><p>每个程序都拥有自己的地址空间，程序在运行时不需要将全部的页调入内存。当程序引用到不在物理内存中的页时，会发生缺页中断，将缺失的部分载入物理内存并重新执行失败的指令</p><p><img data-src="https://i.loli.net/2019/04/26/5cc29f53c3a92.png" alt="pic"></p><p>上图是具有$32K​$ 物理内存的16位操作系统的虚拟地址空间和物理内存的关系。虚拟地址空间每一块称为一页，物理内存的每一块称为一个页框，页和页框的大小都为$4K​$</p><h3 id="地址空间划分"><a href="#地址空间划分" class="headerlink" title="地址空间划分"></a>地址空间划分</h3><p>通常32位 Linux 操作系统将 $0 \sim 3G-1​$ 划分为用户空间，将 $3G \sim 4G-1​$ 划分为内核空间；操作系统程序和驱动程序运行在内核空间，应用程序运行在用户空间</p><p>每个进程的虚拟地址空间是$4G$，进程在用户态只能访问$0 \sim 3G-1$，只有通过系统调用进入内核态才能访问$3G \sim 4G-1​$</p><h2 id="地址映射模型"><a href="#地址映射模型" class="headerlink" title="地址映射模型"></a>地址映射模型</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h4 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h4><p>内存管理单元（MMU）是 CPU 硬件的功能，管理虚拟地址空间和物理内存的转换。内存管理单元负责虚拟地址和物理地址的映射，并提供硬件机制的内存访问权限检查。内存管理单元使得每一个进程都拥有自己的地址空间，并通过内存访问权限检查保证每一个进程所用的内存不被其他进程破坏</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>页表存储着虚拟地址空间（逻辑地址）和物理地址的映射</p><ul><li><p>逻辑地址</p><p>虚拟地址空间由两部分构成：页面号和偏移量<br>$$<br>页面号 = 虚拟地址 / 4K \<br>偏移量 = 虚拟地址 % 4K<br>$$<br>32位操作系统的地址空间为$4G$，页的大小为$4K​$，需要20位存储页面号，需要12位存储偏移量。32位操作系统的逻辑地址高20位存储页面号，低12位存储偏移量</p></li><li><p>物理地址</p><p>物理地址也由两部分构成：物理页框号和偏移量<br>$$<br>页框号 = 物理地址 / 4K \<br>偏移量 = 物理地址 % 4K<br>$$<br>$2G$内存的操作系统，页的大小为$4K$，共有$2^{19}$个页框，$2G$ 内存的操作系统，至少需要19位存储页框号，剩下的12位存储偏移量</p></li></ul><p>页表实际上是页面号和页框号的映射，因为偏移量相等。页表由页框号和标记位构成，标记位用来表示页是否在内存中，1 表示在内存中。如果不在内存中会发生缺页中断，内核缺页异常处理程序将缺失的页载入内存中；如果内存空间不足，将调用页面置换算法将需要的页置换进内存，并重新执行失败的命令</p><p><img data-src="https://i.loli.net/2019/04/26/5cc2ab27c1d60.png" alt="pic"></p><p>应用进程使用的都是逻辑地址，每个进程都会维护一个单独的页表。当进程未执行时，页表起始地址和页表长度的信息在进程控制块（PCB）中存储，进程执行时会将页表起始地址和页表长度存储在 CPU 的页表寄存器中</p><p>映射流程：</p><ul><li><p>计算虚拟地址的页面号和偏移量<br>$$<br>页面号 = 虚拟地址 / 4K \<br>页内偏移量 = 虚拟地址 % 4K<br>$$</p></li><li><p>页表寄存器中存储页表起始地址和页表长度，将页面号和页表长度对比，确认在页表范围内</p></li><li><p>根据页表起始地址和偏移量找到对应的页框号</p></li><li><p>将页框号与偏移量拼接即为物理地址，即<br>$$<br>页框号<em>页表长度+页内偏移量<br>$$<br>$页框号</em>页表长度$ 可以理解为页框号向左移动”页表长度“个位</p></li></ul><blockquote><p><a href="https://www.cnblogs.com/felixfang/p/3420462.html" target="_blank" rel="noopener">内存管理笔记(分页，分段，逻辑地址，物理地址与地址转换方式)</a></p></blockquote><h4 id="页表的存储方式"><a href="#页表的存储方式" class="headerlink" title="页表的存储方式"></a>页表的存储方式</h4><p>每个进程都有独立的页表，由于页表比较大所以它存储在内存中，并且页表的起始地址和页表长度存储在进程控制块中。当进程执行时，将页表的起始地址和页表长度存储在 CPU 的页表寄存器中</p><p>由于页表存储在内存中，所以访问数据需要访问两次内存：获取页表项算一次，访问数据算一次。为了减少内存访问次数加入了 TBL（快表，在 CPU 中存储），TBL中存储了页表的一小部分条目</p><p> <img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2lnno12haj20mj0dvjvt.jpg" alt="pic"></p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>一个32位操作系统，页的大小为$4K​$，那么共有$2^{32}B / 4K = 2^{20}​$ 个页，需要20位作为页面号，则$32-20=12​$位作为偏移量。假设页表项大小是$4B​$，则存储页表需要$4B*2^{20}=4MB​$</p><p>使用多级页表可以减少表所占的空间，比如32位操作系统使用两级页表，则可以将20位页面号再次划分成：10位页面号+10位偏移量</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lnoivvehj20iz08wjt2.jpg" alt="pic"></p><h4 id="页表的优缺点"><a href="#页表的优缺点" class="headerlink" title="页表的优缺点"></a>页表的优缺点</h4><ul><li>分页不会产生外部碎片，但可能产生内部碎片</li></ul><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>由于分页的机制，使得应用进程以页为单位进程内存分配，并且页不必存储在连续的内存空间。从编程者的角度考虑，一段程序的内存应该是连续的，分页造成了用户视角和实际视角的分离。分段机制将地址空间划分成段，段的大小不固定并且可以动态增长</p><p>逻辑地址由两部分构成：段号和偏移量</p><p>段表由两部分构成：界限和基址</p><p>映射流程：</p><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lnpclmnaj20io0cuwi8.jpg" alt="pic"></p><h4 id="分页-amp-分段"><a href="#分页-amp-分段" class="headerlink" title="分页 &amp; 分段"></a>分页 &amp; 分段</h4><ul><li><p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段</p></li><li><p>地址空间的维度：分页是一维地址空间，分段是二维的</p><ul><li><p>分页：虽然逻辑地址包括页号和偏移量，但是分页对程序员不透明，由系统完成，只需给定逻辑地址就可以了，所以是一维地址</p></li><li><p>分段：分段对程序员不透明，好处是程序模块化，需要程序员指定段号和偏移量，所以是二维地址</p></li><li><p>段页式：先分段再分页，所以是二维地址</p></li></ul></li><li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变</p></li><li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</p></li></ul><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>地址空间划分成大小不等的段，每个段又划分成大小相等的页</p><p>映射过程：逻辑地址 -&gt; 线性地址 -&gt; 物理地址</p><ul><li>逻辑地址：16位选择符+16位偏移量</li><li>选择符：选择符中包含13位索引，1位TI和2位保护位<ul><li>段描述符一般有$8B$，需要64位，记录了段的位置和大小的信息；可以通过索引找到描述符表中的段描述符</li></ul></li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2lnqe24n0j20fy0eojvr.jpg" alt="pic"></p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>为了便于内存管理，操作系统将内存抽象成地址空间，每个程序都有自己的地址空间，这些地址空间又被分成多个块，每一块称为一页。程序运行时不需要将所有的页都载入内存中，当程序引用一个不在内存中的页时，会发生缺页中断，由内核执行缺页异常处理程序，将缺失的页载入内存。如果内存空间不足，使用页面置换算法将内存中的页置换出去，为需要的页腾出空间。页面置换算法的目的是为了使缺页率最少</p><h3 id="最佳（OPT）"><a href="#最佳（OPT）" class="headerlink" title="最佳（OPT）"></a>最佳（OPT）</h3><p>将未来最久不会再次被访问的页置换出去，能够保证最低的缺页率，是一种理论上的算法，无法实现</p><p>例：一个系统为某进程分配 3 个物理块</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure><p>进程开始运行时，将7、0、1载入内存；当进程需要访问页面 2 时，将 7 置换出去；进程访问页面 0 时，不需要置换；访问页面 3 时，将页面 1 置换出去…</p><h3 id="最近最久未使用（LRU）"><a href="#最近最久未使用（LRU）" class="headerlink" title="最近最久未使用（LRU）"></a>最近最久未使用（LRU）</h3><p>将过去最近最久没有被访问的页面置换出去</p><p>实现方式：</p><ul><li>使用双向链表实现，链表中存储着曾经被访问的所有页的页号。如果当前页的页号在链表中，将其移动到链表的头部；如果当前页的页号不在链表中，将其插入到链表的头部；在进行置换时，从尾节点向上遍历，直到遍历到一个在内存中的页面号为止，将所对应的页从内存中置换出去</li><li>使用双向链表实现，链表中存储着在内存中的页号的最近最久使用情况。如果当前页的页号在链表中，将其移动到链表的头部；如果当前页的页号不在链表中，将其插入到链表的头部，将尾节点删除，并将尾节点对应的页从内存中置换出去</li><li>使用<code>HashMap</code>和循环链表实现，降低遍历链表的时间复杂度</li></ul><p>每次都要移动链表，造成性能开销</p><h3 id="最近未使用（NRU）"><a href="#最近未使用（NRU）" class="headerlink" title="最近未使用（NRU）"></a>最近未使用（NRU）</h3><p>操作系统为每个页面设置两个标记位：R 和 W 。当页面被访问时 R 位置 1，当页面被修改时 W 位置 1。</p><p>R 和 W 可以存储在页表中。当启动一个进程时，将所有的页标记为不在内存中。当进程引用不在内存中的页时发生缺页中断，此时操作系统将页表项的 R 位置 1，设置为 <code>read only</code> 模式；当进程需要修改页面时再次引起缺页中断，此时操作系统将 W 位置 1，设置为<code>read/write</code>模式</p><ul><li>R 位会被定期清零，这样能够区别最近被使用的页面和未被使用的页面</li><li>W 位置 1 后不清零，操作系统需要通过 W 位判断页是否需要写入磁盘中</li></ul><p>当发生缺页中断时，操作系统根据 R 和 W 位将页分为 4 类：</p><ul><li><code>00</code>：未被访问，未被修改</li><li><code>01</code>：未被访问，已被修改（脏页）</li><li><code>10</code>：已被访问，未被修改（干净页）</li><li><code>11</code>：已被访问，未被修改</li></ul><p>NRU 随机地从类编号最小的非空类中挑选一个页并将其淘汰</p><h3 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h3><p>将最先进入内存的页面置换出去</p><p>可以使用队列实现，经常被使用的页也会被置换出去，导致缺页率升高</p><h3 id="第二次机会算法"><a href="#第二次机会算法" class="headerlink" title="第二次机会算法"></a>第二次机会算法</h3><p>FIFO 可能将经常使用的页置换出去，造成缺页率增加。第二次机会算法是对 FIFO 算法的改进，在发生缺页中断并需要进行页面置换的时候，查看最老页面的 R 位。如果 R 位是 0，可以将其置换出去；如果 R 位是 1，将其 R 位置 0 并将其 push 进队列，将其认为是刚装入的页面，然后再 pop 出队列头继续搜索能被置换的页面</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>第二次机会算法需要进行节点的移动，降低了效率。时钟算法使用循环链表将页面连接起来，使用一个指针指向最老的页面</p><p>第二次机会算法是对 FIFO 算法的改进，防止置换出经常使用的页面；时钟算法是对第二次机会算法的改进，防止频繁移动节点</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating Systems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket &amp; Java NIO</title>
      <link href="/2019/04/25/00018/"/>
      <url>/2019/04/25/00018/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/6XV9xJrcsNpPGdz.jpg" alt="bing"></p><a id="more"></a><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h3 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h3><p>一个输入操作包括两个阶段：</p><ul><li>等待数据准备好：网络编程是等待数据从网络中到达，当数据到达时存储到内核的缓冲区中</li><li>从内核向应用进程复制数据：将数据从内核缓冲区复制到应用进程缓冲区</li></ul><p>IO 模型：</p><blockquote><p><a href="https://www.cnblogs.com/euphie/p/6376508.html" target="_blank" rel="noopener">同步IO、异步IO、阻塞IO、非阻塞IO之间的联系与区别</a></p></blockquote><ul><li><p>阻塞 IO</p><ul><li><p>应用进程被阻塞，等待数据准备好，直到数据从内核缓冲区复制到应用进程缓冲区</p></li><li><p>当进程被阻塞时，其他进程可以执行，不会消耗 CPU 时间</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lnswoklij20h909edh0.jpg" alt="pic"></p></li></ul></li><li><p>非阻塞 IO</p><ul><li>应用进程不会阻塞地等待数据准备好，如果数据没有准备好，内核会返回一个错误码，此时应用进程可以执行其他的操作，但需要通过轮询的方式进行系统调用直到数据准备好</li><li>非阻塞 IO 会不断进行系统调用，CPU 利用率不高</li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2lnszngw5j20ji0aetar.jpg" alt="pic"></p></li><li><p>IO 复用</p><ul><li>使用<code>select</code>或<code>poll</code>选择器等待数据，如果没有准备好进程被阻塞，一旦有至少一个数据准备好，就执行系统调用，将数据从内核态复制到用户态</li><li>使用 IO 复用可以让一个进程处理多个 IO 请求，如果不使用 IO 复用，每个 Socket 都要创建一个线程去处理， IO 复用避免了线程切换带来的开销</li></ul><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lnt2vhhnj20jq0adaca.jpg" alt="pic"></p><p><code>select</code>、<code>poll</code> 和<code>epoll</code> 都是多路 IO 复用的解决方案</p><ul><li><code>select</code> ：通过轮询的方式遍历 Socket，全部遍历并且存在最大连接数限制</li><li><code>poll</code>：通过轮询的方式遍历 Socket，全部遍历，不存在最大连接数限制</li><li><code>epoll</code>：只遍历已经准备好的 Socket</li></ul></li><li><p>信号驱动 IO</p><ul><li><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程不会阻塞，可以继续执行；当数据准备好内核向应用进程发送信号，之后应用进程执行系统调用将数据从内核缓冲区复制到应用进程缓冲区</p></li><li><p>信号驱动 I/O 的 CPU 利用率更高</p></li></ul><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lnt6bnp2j20jq0avwg7.jpg" alt="pic"></p></li><li><p>异步 IO</p><ul><li>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号</li></ul><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lnt97dkwj20jd0boabf.jpg" alt="pic"></p></li></ul><h3 id="IO-模型对比"><a href="#IO-模型对比" class="headerlink" title="IO 模型对比"></a>IO 模型对比</h3><ul><li>同步 IO：将数据从内核缓冲区复制到应用进程缓冲区时，应用进程会阻塞</li><li>异步 IO：将数据从内核缓冲区复制到应用进程缓冲区时，应用进程不会阻塞</li></ul><p>对比：</p><ul><li>阻塞 IO：是同步 IO，在数据准备阶段会阻塞，不会占用 CPU 时间</li><li>非阻塞 IO：是同步 IO，在数据准备阶段不会阻塞，轮询进行系统调用直到数据准备好，CPU 利用率低</li><li>IO 复用：是同步 IO，在数据准备阶段会阻塞，通过选择器轮询，可以避免线程切换</li><li>信号驱动 IO：是同步 IO，在数据准备阶段不会阻塞，通过信号判断数据是否准备好，CPU 利用率高</li><li>异步 IO：不是同步 IO，在数据准备阶段不会阻塞，直到完全复制完再通知应用进程</li></ul><h3 id="IO-复用"><a href="#IO-复用" class="headerlink" title="IO 复用"></a>IO 复用</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>描述符类型使用数组实现，有描述符数量的限制</p></li><li><p><code>select</code> 有三种类型的描述符 / 事件类型，分别为读、写、异常类型的描述符</p></li><li><p>调用<code>select</code>会一直阻塞，直到有描述符的事件到达或者超时</p></li><li><p>每次系统调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区</p></li><li><p>系统调用的返回结果中没有声明哪些描述符已经准备好，需要应用进程全部轮询判断哪些描述符准备好</p></li><li><p>几乎所有系统都支持<code>select</code></p></li></ul><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>描述符类型使用链表实现，没有描述符数量的限制</li><li>提供了更多的事件类型</li><li>每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区</li><li>系统调用的返回结果中没有声明哪些描述符已经准备好，需要应用进程全部轮询判断哪些描述符准备好</li><li>比较新的系统支持<code>poll</code></li></ul><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>epoll</code> 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次</li><li>没有描述符数量的限制</li><li>系统调用的返回结果是准备好的事件</li><li>只有 Linux 支持<code>epoll</code></li></ul><p>触发模式：</p><ul><li>LT（level trigger）：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking</li><li>ET（edge trigger）：通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><code>select</code>：可移植性更高；超时时间支持<code>ns</code>，更适用于实时性要求比较高的场景</li><li><code>poll</code>：没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select</li><li><code>epoll</code>：只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接</li></ul><h2 id="java-NIO"><a href="#java-NIO" class="headerlink" title="java NIO"></a>java NIO</h2><h3 id="NIO-amp-IO"><a href="#NIO-amp-IO" class="headerlink" title="NIO &amp; IO"></a>NIO &amp; IO</h3><ul><li>I/O 以流的方式处理数据，而 NIO 以块（缓冲）的方式处理数据</li><li>IO 是阻塞 IO，NIO 是非阻塞 IO</li></ul><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><ul><li>FileChannel：不能配置非阻塞</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><h4 id="缓冲区类型"><a href="#缓冲区类型" class="headerlink" title="缓冲区类型"></a>缓冲区类型</h4><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShotBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h4 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h4><ul><li>capacity：最大容量</li><li>position：当前已经读写的字节数</li><li>limit-positon：还可以读写的字节数</li></ul><h3 id="文件-IO-实例"><a href="#文件-IO-实例" class="headerlink" title="文件 IO 实例"></a>文件 IO 实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastCopy</span><span class="params">(String src, String desc)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">        FileChannel fcin = in.getChannel();</span><br><span class="line"></span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(desc);</span><br><span class="line">        FileChannel fcout = out.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = fcin.read(buffer);</span><br><span class="line">            <span class="keyword">if</span>(cur == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            fcout.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Socket-NIO-实例"><a href="#Socket-NIO-实例" class="headerlink" title="Socket NIO 实例"></a>Socket NIO 实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">package</span> com.apathy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketNIOService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Selector sel = Selector.open(); <span class="comment">// 创建选择器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ServerSocketChannel，监听新进来的TCP连接</span></span><br><span class="line">        ServerSocketChannel socketChannel = ServerSocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 设置非阻塞 IO</span></span><br><span class="line">        <span class="comment">/* 将通道注册到选择器上</span></span><br><span class="line"><span class="comment">        SelectionKey.OP_CONNECT:连接就绪，一个Channel成功连接到另一个服务器</span></span><br><span class="line"><span class="comment">        SelectionKey.OP_ACCEPT：接收就绪，一个ServerSocketChannel准备好接收新进入的连接</span></span><br><span class="line"><span class="comment">        SelectionKey.OP_READ：读就绪，一个有数据可读的通道</span></span><br><span class="line"><span class="comment">        SelectionKey.OP_WRITE：写就绪，一个等待写数据的通道</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        socketChannel.register(sel, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 ServerSocketChannel 绑定到特定端口</span></span><br><span class="line">        ServerSocket serverSocket = socketChannel.socket(); <span class="comment">// 创建套接字</span></span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address); <span class="comment">// 绑到特定端口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            sel.select(); <span class="comment">// 监听事件，没有事件会阻塞</span></span><br><span class="line">            Set&lt;SelectionKey&gt; set = sel.selectedKeys(); <span class="comment">// 获取到达的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = set.iterator(); <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123; <span class="comment">// 轮询</span></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;  <span class="comment">// 连接就绪</span></span><br><span class="line">                    <span class="comment">// 如果是连接请求，将连接通道注册到 selector 上</span></span><br><span class="line">                    ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    sc.register(sel, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;  <span class="comment">// 读就绪</span></span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sc));</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">package</span> com.apathy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketNIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream ops = socket.getOutputStream();</span><br><span class="line">        String str = <span class="string">"hello, apathy"</span>;</span><br><span class="line">        ops.write(str.getBytes());</span><br><span class="line">        ops.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Code </tag>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL leetcode</title>
      <link href="/2019/04/24/00017/"/>
      <url>/2019/04/24/00017/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/nmrgfAkcoOV7i4I.jpg" alt="bing"></p><a id="more"></a><ol><li><p><a href="https://leetcode-cn.com/problems/combine-two-tables/" target="_blank" rel="noopener">组合两个表</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT p.FirstName, p.LastName, a.City, a.State</span><br><span class="line">FROM Person AS p LEFT JOIN Address AS a</span><br><span class="line">ON p.PersonId &#x3D; a.PersonId;</span><br></pre></td></tr></table></figure><ul><li>左外连接：左表中满足条件的记录能够都查询到，即使右表中没有与之匹配的行</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">第二高的薪水</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">(SELECT DISTINCT(Salary)</span><br><span class="line">FROM Employee</span><br><span class="line">ORDER BY Salary desc</span><br><span class="line">LIMIT 1,1) as SecondHighestSalary;</span><br></pre></td></tr></table></figure><ul><li>关键字顺序：<code>SELECT</code> -&gt; <code>FROM</code> -&gt; <code>WHERE</code> -&gt;<code>GROUP BY</code> -&gt; <code>HAVING</code> -&gt; <code>ORDER BY</code> -&gt; <code>LIMIT</code></li><li>使用<code>DISTINCT</code> 筛选重复的查询结果</li><li>为保证查询结果为空时返回<code>NULL</code>，需要在外边再包装一层<code>SELECT</code></li><li><code>LIMIT</code> 可以进行范围搜索</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/nth-highest-salary/" target="_blank" rel="noopener">第N高的薪水</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  set N &#x3D; N-1;</span><br><span class="line">  RETURN (</span><br><span class="line">      SELECT(SELECT DISTINCT(Salary) FROM Employee ORDER BY Salary DESC LIMIT N, 1)</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure><ul><li>函数注重返回值，返回值只能是一个值，不能是集合</li><li><code>LIMIT</code>进行范围查询</li><li>包装<code>SELECT</code> 返回<code>NULL</code></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/rank-scores/" target="_blank" rel="noopener">分数排名</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.Score,COUNT(DISTINCT(s2.Score)) rank</span><br><span class="line">FROM Scores s1,Scores s2</span><br><span class="line">WHERE s1.Score &lt;&#x3D; s2.Score</span><br><span class="line">GROUP BY s1.Id  -- 此处运行环境不同可能会报错</span><br><span class="line">ORDER BY s1.Score DESC;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.Score,</span><br><span class="line">(SELECT COUNT(DISTINCT(s2.Score)) FROM Scores s2 WHERE s2.Score &gt; s1.Score)+1 AS rank</span><br><span class="line">FROM Scores s1</span><br><span class="line">ORDER BY s1.Score DESC;</span><br></pre></td></tr></table></figure><ul><li>利用<code>DISTINCT</code>去重分数相等的个数</li><li>自连接对同一张表的数据进行比较</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/consecutive-numbers/" target="_blank" rel="noopener">连续出现的数字</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(l1.Num) AS ConsecutiveNums</span><br><span class="line">FROM Logs l1, Logs l2, Logs l3</span><br><span class="line">WHERE l1.Num &#x3D; l2.Num AND l2.Num &#x3D; l3.Num</span><br><span class="line">AND l1.Id &#x3D; l2.Id-1 AND l2.Id &#x3D; l3.Id-1;</span><br></pre></td></tr></table></figure><ul><li>利用<code>Id</code> 进行三表自连接查询</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/" target="_blank" rel="noopener">超过经理收入的员工</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e1.Name Employee</span><br><span class="line">FROM Employee e1,Employee e2</span><br><span class="line">WHERE e1.ManagerId &#x3D; e2.Id</span><br><span class="line">AND e1.Salary &gt; e2.Salary;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/duplicate-emails/" target="_blank" rel="noopener">查找重复的电子邮箱</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Email</span><br><span class="line">FROM Person</span><br><span class="line">GROUP BY Email</span><br><span class="line">HAVING COUNT(*) &gt; 1;</span><br></pre></td></tr></table></figure><ul><li><code>GROUP BY</code> 计算分组内记录个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(p1.Email) AS Email</span><br><span class="line">FROM Person p1, Person p2</span><br><span class="line">WHERE p1.Id !&#x3D; p2.Id AND p1.Email &#x3D; p2.Email;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/customers-who-never-order/" target="_blank" rel="noopener">从不订购的客户</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Name AS Customers</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE Id NOT IN (SELECT DISTINCT(CustomerId) FROM Orders);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/department-highest-salary/" target="_blank" rel="noopener">部门工资最高的员工</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 当同一部门内最大工资不是一个时，只能查询到一个</span><br><span class="line">SELECT d.Name AS Department,ANY_VALUE(e.Name) AS Employee,MAX(e.Salary)</span><br><span class="line">FROM Employee e, Department d</span><br><span class="line">WHERE e.DepartmentId &#x3D; d.Id</span><br><span class="line">GROUP BY Department;</span><br></pre></td></tr></table></figure><ul><li>MySql 5.7 要求在使用<code>GRUOP BY</code>时，<code>SELECT</code>内的非函数查询必须包含在<code>GROUP BY</code> 中，否则报错<code>sql_mode=only_full_group_by</code>，可以通过使用<code>ANY_VALUE()</code>解决</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT dep.Name AS Department,e.Name AS Employee, e.Salary</span><br><span class="line">FROM Employee e, (SELECT d.Id, ANY_VALUE(d.Name) AS Name, MAX(e.Salary) AS m</span><br><span class="line">FROM Employee e, Department d</span><br><span class="line">WHERE e.DepartmentId &#x3D; d.Id</span><br><span class="line">GROUP BY Id) AS dep</span><br><span class="line">WHERE e.DepartmentId &#x3D; dep.Id AND e.Salary &#x3D; dep.m;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/department-top-three-salaries/" target="_blank" rel="noopener">部门工资前三高的员工</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT P2.Name AS Department,P3.Name AS Employee,P3.Salary AS Salary</span><br><span class="line">FROM Employee AS P3</span><br><span class="line">INNER JOIN Department AS P2</span><br><span class="line">ON P2.Id &#x3D; P3.DepartmentId</span><br><span class="line">WHERE (</span><br><span class="line">    SELECT COUNT(DISTINCT Salary)</span><br><span class="line">    FROM Employee AS P4</span><br><span class="line">    WHERE P3.DepartmentId &#x3D; P4.DepartmentId</span><br><span class="line">    AND P4.Salary &gt;&#x3D; P3.Salary</span><br><span class="line">) &lt;&#x3D; 3</span><br><span class="line">ORDER BY DepartmentId,Salary DESC;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/delete-duplicate-emails/" target="_blank" rel="noopener">删除重复的电子邮箱</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM Person</span><br><span class="line">WHERE Id NOT IN (</span><br><span class="line">    SELECT Id FROM</span><br><span class="line">    (SELECT MIN(p.Id) AS Id</span><br><span class="line">    FROM Person p</span><br><span class="line">    GROUP BY Email) pe</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>不嵌套一层<code>SELECT</code> 会报错：<code>You can&#39;t specify target table &#39;Person&#39; for update in FROM clause</code></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/rising-temperature/" target="_blank" rel="noopener">上升的温度</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT w1.Id</span><br><span class="line">FROM Weather w1, Weather w2</span><br><span class="line">WHERE DATEDIFF(w1.RecordDate, w2.RecordDate)&#x3D;1 AND w1.Temperature &gt; w2.Temperature;</span><br></pre></td></tr></table></figure><ul><li><code>使用</code>DATEDIFF`函数求救两个日期的差集</li><li><code>DATE</code>类型不能直接加减，比如“2019-04-30”+1会变成“20190431”</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/trips-and-users" target="_blank" rel="noopener">行程和用户</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT t.request_at Day,(</span><br><span class="line">        round(count(if(status !&#x3D; &#39;completed&#39;, status, null)) &#x2F; count(status), 2)</span><br><span class="line">    ) AS &#39;Cancellation Rate&#39;</span><br><span class="line">FROM Users u INNER JOIN Trips t ON u.Users_id &#x3D; t.Client_Id AND u.banned !&#x3D; &#39;Yes&#39;</span><br><span class="line">WHERE t.Request_at &gt;&#x3D; &#39;2013-10-01&#39; AND t.Request_at &lt;&#x3D; &#39;2013-10-03&#39;</span><br><span class="line">GROUP BY t.Request_at;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/big-countries" target="_blank" rel="noopener">大的国家</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, population, area</span><br><span class="line">FROM World</span><br><span class="line">WHERE (area &gt; 3000000 OR population &gt; 25000000);</span><br></pre></td></tr></table></figure><ul><li><code>OR</code>用括号括起来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, population, area</span><br><span class="line">FROM World</span><br><span class="line">WHERE area &gt; 3000000</span><br><span class="line">UNION</span><br><span class="line">SELECT name, population, area</span><br><span class="line">FROM World</span><br><span class="line">WHERE population &gt; 25000000</span><br></pre></td></tr></table></figure><ul><li><code>UNION</code>：并集操作，不包括重复行，同时进行默认排序</li><li><code>UNION ALL</code>：并集操作，包括重复行，不进行排序</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/classes-more-than-5-students" target="_blank" rel="noopener">超过5名学生的课</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT class</span><br><span class="line">FROM courses</span><br><span class="line">GROUP BY class</span><br><span class="line">HAVING COUNT(DISTINCT(student)) &gt;&#x3D; 5;</span><br></pre></td></tr></table></figure><ul><li>考虑重复记录</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/human-traffic-of-stadium" target="_blank" rel="noopener">体育馆的人流量</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT a.*</span><br><span class="line">FROM stadium a,stadium b,stadium c</span><br><span class="line">WHERE a.people&gt;&#x3D;100 AND b.people&gt;&#x3D;100 AND c.people&gt;&#x3D;100</span><br><span class="line">AND (</span><br><span class="line">     (a.id &#x3D; b.id-1 AND b.id &#x3D; c.id -1) OR</span><br><span class="line">     (a.id &#x3D; b.id-1 AND a.id &#x3D; c.id +1) OR</span><br><span class="line">     (a.id &#x3D; b.id+1 AND b.id &#x3D; c.id +1)</span><br><span class="line">) ORDER BY a.id;</span><br></pre></td></tr></table></figure><ul><li>注意如果只一种情况，会导致最后两个满足条件的记录查询不到</li></ul></li><li><p><a href="https://leetcode-cn.com/problems/not-boring-movies" target="_blank" rel="noopener">有趣的电影</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM cinema</span><br><span class="line">WHERE description !&#x3D; &#39;boring&#39; AND id%2 &#x3D; 1</span><br><span class="line">ORDER BY rating DESC;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/exchange-seats" target="_blank" rel="noopener">换座位</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT (CASE</span><br><span class="line">            WHEN MOD(id,2) &#x3D; 1 AND id &#x3D; (SELECT COUNT(*) FROM seat) THEN id</span><br><span class="line">            WHEN MOD(id,2) &#x3D; 1 THEN id+1</span><br><span class="line">            ElSE id-1</span><br><span class="line">        END) AS id, student</span><br><span class="line">FROM seat</span><br><span class="line">ORDER BY id;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/swap-salary" target="_blank" rel="noopener">交换工资</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE salary SET sex &#x3D; IF(sex&#x3D;&#39;m&#39;,&#39;f&#39;,&#39;m&#39;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE salary</span><br><span class="line">SET sex &#x3D; CHAR ( ASCII(sex) ^ ASCII( &#39;m&#39; ) ^ ASCII( &#39;f&#39; ) );</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Code </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2019/04/17/00016/"/>
      <url>/2019/04/17/00016/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/QJrxoF3Ndlz1R7u.jpg" alt="bing"></p><a id="more"></a><h2 id="mysql-基础"><a href="#mysql-基础" class="headerlink" title="mysql 基础"></a>mysql 基础</h2><blockquote><p><a href="http://www.cnblogs.com/lyhabc/p/3776739.html" target="_blank" rel="noopener">mysql 学习心得</a></p><p><a href="https://www.cnblogs.com/dannylinux/articles/8288790.html" target="_blank" rel="noopener">mysql面试题</a></p></blockquote><h3 id="三层逻辑架构"><a href="#三层逻辑架构" class="headerlink" title="三层逻辑架构"></a>三层逻辑架构</h3><ul><li>第一层：负责连接管理、授权认证、安全等</li><li>第二层：负责解析查询并进行优化</li><li>第三层：存储引擎</li></ul><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2lnfxz6qej20ff0ehgou.jpg" alt="pic"></p><hr><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lng2kw0cj20hx0ajwh9.jpg" alt="pic"></p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><blockquote><p><a href="https://blog.csdn.net/FallingU/article/details/78955707" target="_blank" rel="noopener">数据库Schema理解</a></p></blockquote><p>打个比方</p><ul><li><p>数据库 database：酒店</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE database_name;</span><br></pre></td></tr></table></figure></li><li><p>模式 schema：房间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE SCHEMA schema_name; -- mysql中模式和数据库是同义的</span><br></pre></td></tr></table></figure></li><li><p>表 table：床</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">  id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">  name VARCHAR(50) NOT NULL,</span><br><span class="line">  age DATA NULL,</span><br><span class="line">  PRIMARY KEY(&#39;id&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>行 row：床上用品</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student(name,age) VALUES(&#39;apathy&#39;,NOW());</span><br></pre></td></tr></table></figure></li><li><p>用户 user：酒店管理员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER user_name IDENTIFIED BY &#39;password&#39;; -- 新创建的用户没有任何权限</span><br><span class="line">DROP USER user_name； -- 删除用户</span><br><span class="line">RENAME user_name TO new_name; -- 重命名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 权限</span><br><span class="line">SHOW GRANTS FOR user_name;</span><br><span class="line"></span><br><span class="line">-- 账户名 username@host，username@% 表示默认主机</span><br><span class="line">GRANT USAGE ON *.* TO &#39;apathy&#39;@&#39;%&#39;; -- apathy用户无权限</span><br><span class="line"></span><br><span class="line">-- 授予权限</span><br><span class="line">GRANT SELECT ON test.* TO &#39;apathy&#39;; -- 为apathy用户授予test数据库查看权限</span><br><span class="line"></span><br><span class="line">-- 撤销权限</span><br><span class="line">REVOKE SELECT ON test.* FROM &#39;apathy&#39;; -- 撤销apathy用户的test数据库查看权限</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据定义语言-DDL"><a href="#数据定义语言-DDL" class="headerlink" title="数据定义语言(DDL)"></a>数据定义语言(DDL)</h3><ul><li><p>CREATE</p></li><li><p>ALTER</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student ADD COLUMN gender VARCHAR(10); -- 增加列</span><br><span class="line">ALTER TABLE student DROP COLUMN age; -- 删除列</span><br></pre></td></tr></table></figure></li><li><p>DROP</p></li></ul><h3 id="数据操纵语言-DML"><a href="#数据操纵语言-DML" class="headerlink" title="数据操纵语言(DML)"></a>数据操纵语言(DML)</h3><ul><li>INSERT</li><li>DELETE<ul><li>DELETE：删除一行数据或删除匹配的数据，并将删除操作记录在二进制文件和重做日志中</li><li>TRUNCATE：删除表中所有数据，不记录日志，不会触发删除触发器</li></ul></li><li>UPDATE</li><li>SELECT</li></ul><p>查询语句书写顺序：</p><p><code>select</code> -&gt; <code>from</code> -&gt; <code>where</code> -&gt; <code>group by</code> -&gt; <code>having</code>  -&gt; <code>order by</code>  -&gt; <code>limit</code></p><p>查询语句执行顺序：</p><p><code>from</code>：从哪些表进行检索，自右向左解析表</p><p><code>where</code>：过滤表数据，自左向右解析条件</p><p><code>group by</code> ：对过滤后的数据进行分组</p><p><code>having</code> ：过滤分组后的数据</p><p><code>select</code>：获得查询结果</p><p><code>order by</code>：对查询结果进行排序</p><p><code>limit</code>：限制返回结果数</p><h3 id="数据库控制语言-DCL"><a href="#数据库控制语言-DCL" class="headerlink" title="数据库控制语言(DCL)"></a>数据库控制语言(DCL)</h3><ul><li>grant</li><li>revoke</li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul><li><p>内连接</p><p>内连接与等值连接相同，从笛卡尔乘积中选择满足筛选条件的数据记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.value, B.value</span><br><span class="line">FROM tablea AS A INNER JOIN tableb AS B</span><br><span class="line">ON A.key &#x3D; B.key;</span><br><span class="line"></span><br><span class="line">SELECT A.value, B.value</span><br><span class="line">FROM tablea AS A, tableb AS B</span><br><span class="line">WHERE A.key &#x3D; B.key;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tablea AS A, tableb AS b;  -- 返回笛卡尔积</span><br></pre></td></tr></table></figure></li><li><p>自然连接</p><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tablea AS A NATURAL JOIN tableb AS B;</span><br></pre></td></tr></table></figure></li><li><p>外连接</p><ul><li><p>左外连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tablea AS A LEFT OUTER JOIN tableb AS B ON A.key &#x3D; B.key;</span><br></pre></td></tr></table></figure></li><li><p>右外连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tablea AS A RIGHT OUTER JOIN tableb AS B ON A.key &#x3D; B.key;</span><br></pre></td></tr></table></figure></li><li><p>全外连接<br>mysql 不支持全外连接，使用<code>UNION ALL</code> 模拟</p></li></ul></li><li><p>自连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tablea AS A AND tablea AS B WHERE A.key &#x3D; B.key;</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图的定义功能强于基本表，视图的操作功能弱于基本表，视图的控制功能与基本表相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_name AS SELECT s.id, s.name FROM student AS s; -- as后跟查询</span><br><span class="line">SELECT * FROM view_name ...; -- 视图和表操作一致</span><br><span class="line">SHOW TABLES; -- 查看所有的表和视图</span><br></pre></td></tr></table></figure><p>基表是单表：对视图进行DML操作会影响基表</p><ul><li>INSERT：不一定成功</li><li>UPDATE：成功</li><li>DELETE：成功</li></ul><p>基表是多表：对视图进行DML操作会影响基表</p><ul><li>INSERT：不一定成功</li><li>UPDATE：成功</li><li>DELETE：不一定成功</li></ul><p>优点：</p><ul><li>简化复杂 sql 操作，提高 sql 重用性</li><li>视图是虚拟表，只使用实际表的部分数据</li><li>通过只给用户访问视图的权限，保证数据的安全性</li><li>对数据库重构，不影响程序运行</li><li>更改数据格式和表示</li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul><li><p>外键约束</p><ul><li>关联两张表，保证表和表之间的数据完整性和准确性，实现一些级联操作</li><li>InnoDB 引擎支持外键，MyISAM 引擎不支持外键</li><li>外键必须建立索引，没有索引会自动创建索引</li><li>外键关系的两个表的列必须是数据类型相似的，能够进行转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT symbol] FOREIGN KEY [id] (index_col_name, ...)</span><br><span class="line">REFERENCES tbl_name (index_col_name, ...)</span><br><span class="line">[ON DELETE &#123;RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT&#125;]</span><br><span class="line">[ON UPDATE &#123;RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT&#125;]</span><br><span class="line">-- RESTRICT 限制外表中的外键改动</span><br><span class="line">-- CASCADE 跟随外键改动</span><br><span class="line">-- SET NULL 设空值</span><br><span class="line">-- NO ACTION 无动作，默认的</span><br><span class="line">-- SET DEFAULT 设默认值</span><br></pre></td></tr></table></figure></li><li><p>主键约束</p></li><li><p>唯一约束</p></li><li><p>非空约束</p></li><li><p>自增</p></li><li><p>默认值</p></li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li>1NF：属性不可分</li><li>2NF：满足1NF，并且非主属性完全依赖主键</li><li>3NF：满足2NF，并且非主属性相互独立，没有依赖关系</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 创建函数</span><br><span class="line">CREATE FUNCTION function_name([parameter_name type,...])</span><br><span class="line">RETURNS &#123;INT|STRING|...&#125;</span><br><span class="line">BEGIN</span><br><span class="line">    -- function body</span><br><span class="line">    DECLARE var1[,var2,...] type [default default_value]; -- 声明局部变量</span><br><span class="line">    SET var1 &#x3D; value1; -- 赋值操作</span><br><span class="line">    SELECT COUNT(*) FROM people INTO var2; -- 赋值操作</span><br><span class="line">    -- 条件</span><br><span class="line">    IF condition_one THEN ...;</span><br><span class="line">    ELSE IF condition_two THEN ...;</span><br><span class="line">    ELSE ...;</span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line">    -- 选择</span><br><span class="line">    CASE case_value</span><br><span class="line">    WHEN when_value THEN ...；</span><br><span class="line">    [WHEN when_value THEN ...];</span><br><span class="line">    [ELSE statement_list];</span><br><span class="line">    END CASE;</span><br><span class="line"></span><br><span class="line">    -- 循环</span><br><span class="line">    WHILE search_condition DO</span><br><span class="line">    ...;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN ();  -- 返回一个值，不能返回集合</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用函数</span><br><span class="line">SELECT function_name(parameter_name);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除函数</span><br><span class="line">DROP FUNCTION function_name;</span><br></pre></td></tr></table></figure><h3 id="自带4个数据库"><a href="#自带4个数据库" class="headerlink" title="自带4个数据库"></a>自带4个数据库</h3><ul><li><code>information_schema</code>：存储 mysql 数据库所维护的其他所有数据库的信息</li><li><code>mysql</code>：主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息</li><li><code>performance_schema</code>：性能优化</li><li><code>sys</code>：快速了解系统的元数据信息，为性能瓶颈分析，性能优化提供帮助</li></ul><h3 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h3><p>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表</p><p>临时表主要是为了放一些中间大结果集的一些子集，临时表建立在内存中，数据存储在内存中</p><h2 id="mysql-索引"><a href="#mysql-索引" class="headerlink" title="mysql 索引"></a>mysql 索引</h2><blockquote><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p></blockquote><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h3><ul><li><p>二叉搜索树</p><ul><li>任意节点如果有左子树，左子树的值小于当前节点</li><li>任意节点如果有右子树，右子树的值大于当前节点</li><li>任意节点的左子树和右子树也是二叉搜索树</li></ul></li><li><p>平衡二叉树</p><ul><li>平衡二叉树是二叉搜索树</li><li>任意节点的左子树和右子树的高度差的绝对值小于等于1</li><li>任意节点的左子树和右子树也是平衡二叉树</li></ul></li><li><p>红黑树</p><blockquote><p><a href="https://segmentfault.com/a/1190000012728513" target="_blank" rel="noopener">红黑树详细分析</a></p></blockquote><ul><li>红黑树是一种近似平衡的二叉搜索树</li><li>红黑树有红节点和黑节点</li><li>根节点一定是黑节点</li><li>叶子节点都是黑节点（NULL节点）</li><li>红节点的子节点一定是黑节点</li><li>根节点到每个叶节点的路径都包含相同数量的黑节点</li></ul><p>红黑树的插入：</p><ul><li>如果新节点 N 是根节点，红染黑</li><li>如果新节点 N 的父节点是黑节点，不作调整</li><li>如果新节点 N 的父节点是红节点<ul><li>父节点的兄弟节点是红节点，将父节点以及其兄弟节点染黑，祖父节点染红，并向上递归</li><li>父节点的兄弟节点是黑节点<ul><li>新节点是父节点的右孩子，左旋，再右旋</li><li>新节点是父节点的左孩子，右旋</li></ul></li></ul></li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2wizhf3o6j20m80d0abh.jpg" alt="pic"></p><p>红黑树的删除：</p><ul><li><p>如果待删节点 X 有两个孩子，找到该节点的前驱或后继，将前驱或者后继的值复制到要删除的节点中，转化为一个孩子节点（以下讨论一个孩子）</p></li><li><p>如果待删节点 X 是红节点，直接用孩子节点 N 补位</p></li><li><p>如果待删节点 X 是黑节点，并且孩子节点 N 是红节点，删除节点，用孩子节点 N 补位并染黑</p></li><li><p>如果待删节点 X 是黑节点，并且孩子节点 N 是黑节点，删除待删节点 X 并用孩子节点 N 补位</p><ul><li>如果 N 是新的根节点，不作调整</li><li>其他情况见下图</li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2wjbfr1hcj20m80lqwim.jpg" alt="pic"></p></li></ul></li><li><p>M阶B树（M指的是子节点的最大个数）</p><ul><li>根节点的子节点取值范围为$[2,M]$，关键字取值范围为$[1,M-1]$</li><li>除根节点之外的非叶节点的子节点取值范围为$[\frac{M}{2},M]$，关键字取值范围为$[\frac{M}{2}-1,M-1]$</li><li>叶节点位于同一层，关键字取值范围为$[\frac{M}{2}-1,M-1]$</li><li>节点内关键字从小到大排序</li><li>一个节点有$k-1$个关键字，则有$k$个子节点，$k-1$个关键字刚好是$k$个子节点的值域划分</li></ul></li><li><p>B+树</p><ul><li>有 $k$ 个子树的节点包含 $k$ 个关键字，非叶节点保存索引，叶节点保存关键字</li><li>叶节点关键字从小到大排序，并且增加指向下一个叶节点的指针</li><li>非页节点存储索引，存储的索引是子节点的最小值或最大值</li></ul></li></ul><h3 id="B-树做索引的优点"><a href="#B-树做索引的优点" class="headerlink" title="B+ 树做索引的优点"></a>B+ 树做索引的优点</h3><ul><li><p>B+ 树的磁盘 IO 操作次数更少 / 查找次数更少</p><blockquote><p><a href="https://www.cnblogs.com/jswang/p/9071847.html" target="_blank" rel="noopener">硬盘基本知识（磁头、磁道、扇区、柱面）</a></p></blockquote><p>索引本身也很大，不可能全部存储在内存中，索引往往以索引文件的形式存储在磁盘中，那么索引的查找过程就要产生磁盘 IO 操作。磁盘的读写时间主要由寻道时间和旋转时间决定，而寻道时间和旋转时间相对于内存读写时间要慢很多</p><p>索引的查找次数越少， IO 操作次数越少。索引的查找次数由树的高度决定，相比于其他的搜索树，B+树的高度更小，复杂度为$O(log_dN)$ ，$d$ 通常很大，这也意味着磁盘 IO 操作更少</p></li><li><p>利用磁盘预读特性</p><blockquote><p><a href="https://blog.csdn.net/fujiandiyi008/article/details/89530124" target="_blank" rel="noopener">说说Innodb中LRU怎么做的？</a></p></blockquote><p>磁盘的最小读写单位是扇区，操作系统与磁盘的最小读写单位是块/簇，内存与操作系统的最小读写单位是页。通常情况下，扇区和页的大小都是4K字节</p><p>为了减少 IO 操作，磁盘往往不是按需读取，而是每次都会预读。预读过程中磁盘会进行顺序读取，顺序读取不需要磁盘并且只需要很短的旋转时间，所以预读可以提高 IO 效率，速度非常快。预读的长度一般为页的整倍数<br>B+ 树的节点大小等于一个页的大小，这样每个节点只需要一次 IO 操作就可以完全载入。每次新建节点，直接申请一个页的空间，可以实现一个节点只需一次 IO 操作。MySQL 默认页的大小是 16Kb，节点的大小也为 16 Kb。通常 B+ 树的高度在 2-4 层，由于 MySql 在运行时，根节点是常驻内存的，因此每次查找只需要大约 2 -3 次 IO</p></li><li><p>B+ 树的查询效率更加稳定</p><p>关键字都在叶节点，并且叶节点都在同一层</p></li><li><p>B+ 树适合范围查找</p><p>B树的关键字存储于整棵树的节点内，查询必须遍历树；而B+树的关键字存储于叶节点，非叶节点存储索引，并且叶节点之间存在指针，适合范围查找和排序等操作</p></li></ul><h3 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h3><p>hash 索引的查询时间复杂度是 $O(1)$，相对于 B+ 树索引更高效。但 Hash 索引存在一系列问题：</p><ul><li>Hash 索引只支持等值查询，比如 <code>=</code> 和<code>in</code></li><li>Hash 索引不支持范围查找，在进行范围查找时要遍历全表</li><li>Hash 索引在查询时必须使用全部索引字段，不然计算的 hash 值不一样；不支持联合索引的最左前缀匹配原则</li><li>Hash 索引无法利用索引排序</li></ul><h3 id="Innodb索引类型"><a href="#Innodb索引类型" class="headerlink" title="Innodb索引类型"></a>Innodb索引类型</h3><ul><li>聚簇索引 / 聚集索引：叶节点存储完整的数据记录，表数据按照索引顺序进行存储。一张表只能有一个聚簇索引</li><li>非聚簇索引：叶节点存储数据存放的地址，不要求数据存储顺序和索引顺序一致</li><li>辅助索引：以其他字段作为索引，叶节点存储主键信息</li><li>BTree+索引：使用B+ 树作为索引的数据结构</li><li>哈希索引：Innodb存储引擎支持自适应哈希索引。当某个索引值被频繁使用时，会在 B+树索引之上再创建一个哈希索引</li><li>全文索引：Innodb 存储引擎在MySQL 5.6.4版本中开始支持全文索引</li></ul><h3 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h3><ul><li>InnoDB 存储引擎：数据文件本身就是索引文件，表文件是按照 B+ 树组织的一个索引结构，data 域保存了完整的数据记录，这种索引叫聚集索引；辅助索引的 data 域存储的是主键</li><li>MyISAM 存储引擎：使用B+ 树作为索引结构，叶节点包括 key 和 data ，data 域存储数据记录的地址；辅助索引的 data 域也存储数据记录的地址</li></ul><h3 id="索引使用和优化"><a href="#索引使用和优化" class="headerlink" title="索引使用和优化"></a>索引使用和优化</h3><p>索引按个数划分，可以分为单列索引和联合索引，联合索引要满足最左前缀原则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE people(</span><br><span class="line">    id INT(20) AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age DATE,</span><br><span class="line">    gender VARCHAR(10) NOT NULL,</span><br><span class="line">    location VARCHAR(100) DEFAULT &#39;secret&#39;,</span><br><span class="line">    PRIMARY KEY(id,name,age)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO people(name,age,gender)</span><br><span class="line">VALUES (&#39;apathy&#39;,&#39;1994-04-16&#39;,&#39;man&#39;),</span><br><span class="line">(&#39;linda&#39;,&#39;1995-12-01&#39;, &#39;woman&#39;),</span><br><span class="line">(&#39;bob&#39;,&#39;1993-04-01&#39;,&#39;man&#39;);</span><br></pre></td></tr></table></figure><ul><li><p>全列匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM people WHERE id &#x3D; 1 and name &#x3D; &#39;apathy&#39; and age &#x3D; &#39;1994-04-16&#39;; -- 会使用索引</span><br></pre></td></tr></table></figure><p>索引对顺序敏感，mysql 查询优化器会自动调整 <code>where</code> 子句的条件查询顺序以使用适合的索引</p></li><li><p>最左前缀匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM people WHERE id &#x3D; 1 and name &#x3D; &#39;apathy&#39;; -- 会使用索引</span><br></pre></td></tr></table></figure></li><li><p>查询条件未提供索引中间列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM people WHERE id &#x3D; 1 and age &#x3D; &#39;1994-04-16&#39;; -- 会使用索引,只使用id</span><br></pre></td></tr></table></figure></li><li><p>查询条件未提供最左前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM people WHERE name &#x3D; &#39;apathy&#39; and age &#x3D; &#39;1994-04-16&#39;; -- 不会使用索引</span><br></pre></td></tr></table></figure></li><li><p>匹配前缀字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM people WHERE id &#x3D; 1 and name like &#39;a%&#39;; -- 会使用索引</span><br></pre></td></tr></table></figure><p>必须是最左前缀</p></li><li><p>范围查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM people WHERE id &lt; 3 and name &#x3D; &#39;apathy&#39;; -- 会使用索引，只使用id</span><br></pre></td></tr></table></figure></li><li><p>查找条件包含表达式或函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM people WHERE id + 1 &#x3D; 2; -- 不会使用索引</span><br><span class="line">SELECT * FROM people WHERE POW(id,2) &#x3D; 2; -- 不会使用索引</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM people WHERE id &#x3D; 1 and CONCAT(name,&#39;,hello&#39;) &#x3D; &#39;apathy,hello&#39;; -- 会使用索引，只使用id</span><br></pre></td></tr></table></figure></li></ul><h2 id="mysql-存储引擎"><a href="#mysql-存储引擎" class="headerlink" title="mysql 存储引擎"></a>mysql 存储引擎</h2><h3 id="InnoDB-amp-MyISAM"><a href="#InnoDB-amp-MyISAM" class="headerlink" title="InnoDB &amp; MyISAM"></a>InnoDB &amp; MyISAM</h3><ul><li>存储：InnoDB 聚簇索引和数据存储在一个文件中，MyISAM 索引和数据分开存储</li><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li><li>外键：InnoDB 支持外键</li><li>备份：InnoDB 支持在线热备份</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</li><li>其它特性：MyISAM 支持压缩表和空间数据索引</li><li>InnoDB 不保存表的行数，MyISAM 保存表的行数</li><li>InnoDB 更安全，保证数据一致性，MyISAM的性能更优，存储空间更少</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存型数据库，数据全部放在内存中</p><h2 id="mysql-事务"><a href="#mysql-事务" class="headerlink" title="mysql 事务"></a>mysql 事务</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>Mysql日志</p><ul><li><p>重做日志(redo log)</p><p>记录修改后的数据；存放保证事务持久性</p></li><li><p>回滚日志(undo log)</p><p>记录修改前的数据；保存事务发生之前的数据版本，可以用于回滚，同时可以提供MVCC下的读；回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可；MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。当需要读取的记录已经被其他事务加锁的时候, 当前事务可以通过 undo 读取之前的版本, 以此实现⼀致性⾮锁定读</p></li><li><p>二进制日志(bin log)</p><p>记录数据库的写操作，在事务提交时会把写操作写入二进制日志，可用于主从复制</p></li><li><p>错误日志(error log)</p><p>记录数据库启动、运行、停止时发生的问题</p></li><li><p>慢查询日志(slow query log)</p><p>记录查询缓慢的 SQL 操作，方便找到 SQL 的瓶颈进行优化</p></li><li><p>一般查询日志(general log)<br>记录执行的 SQL 语句</p></li><li><p>中继日志(relay log)</p><p>来自主数据库的二进制日志文件，IO 线程读取主数据库二进制文件并写入本地的一类日志</p></li></ul><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务是满足ACID特性的一组操作</p><p><img data-src="https://i.loli.net/2019/04/26/5cc271ea95a8d.png" alt="pic"></p><ul><li>原子性<br>通过 undo log 回滚日志实现</li><li>一致性<br>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的</li><li>隔离性</li><li>持久性<br>通过 redo log 重做日志实现</li></ul><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><ul><li><p>脏读</p></li><li><p>不可重复读</p><p>侧重于读-读操作，两次读取信息不一致</p></li><li><p>幻读</p><blockquote><p><a href="https://segmentfault.com/a/1190000016566788" target="_blank" rel="noopener">mysql 幻读详解</a></p></blockquote><p>幻读侧重于某一次的 select 操作得到的结果无法支撑后续的业务操作。举个例子：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在无法插入，此时就发生了幻读</p><p>侧重于读-写操作，第一次读的信息不能支撑写操作</p></li></ul><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><h4 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h4><ul><li>一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁</li><li>二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁</li><li>三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁</li></ul><h4 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h4><p>加锁和解锁分为两个阶段进行</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li>读未提交：存在脏读、不可重复读、幻读问题<ul><li>一个事务可以读取到其他事务未提交的DML数据</li></ul></li><li>读已提交：存在不可重复读、幻读<ul><li>一个事务可以读取到其他事务已提交的DML数据</li></ul></li><li>可重复读：存在幻读问题<ul><li>一个事务可以读取到其他事务已提交的新插入的数据</li></ul></li><li>串行<ul><li>事务串行执行</li><li>or 事务可以并行执行，但是事务对相同数据的操作是串行执行的，对表和行加锁</li></ul></li></ul><h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><ul><li><p>快照读<br>读取某一时刻的快照，RR 级别下的快照读使用 MVCC 和 undo log 来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM ...</span><br></pre></td></tr></table></figure></li><li><p>当前读<br>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br><span class="line">select * from table where ? for update;</span><br><span class="line">insert;</span><br><span class="line">update;</span><br><span class="line">delete;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><blockquote><p><a href="https://blog.csdn.net/w2064004678/article/details/83012387" target="_blank" rel="noopener">Mysql中MVCC的使用及原理详解</a></p></blockquote><p>多版本并发控制是 MySQL 的 innodb 存储引擎实现隔离级别的实现方式。MVCC 可以认为是行锁的变种，实现了不加锁读，它在大多数情况下避免了加锁，使系统开销更小</p><p>MVCC 在读已提交和可重复读两种隔离级别下工作。未提交读总是读取最新的数据，不需要使用 MVCC；串行需要对读取的表加锁，无法使用 MVCC 实现</p><p>在RR级别下，快照读是通过MVVC(多版本控制)和 undo log 来实现的</p><h4 id="innodb-行结构"><a href="#innodb-行结构" class="headerlink" title="innodb 行结构"></a>innodb 行结构</h4><p>innodb 存储引擎的行中额外存储一些信息：</p><ul><li><code>DATA_TRX_ID</code>：6字节，标记了最新更新这条行记录的 transaction id</li><li><code>DATA_ROLL_PTR</code>：7字节，回滚指针，指向当前行记录的回滚日志记录</li><li><code>DB_ROW_ID</code>：6字节，如果没有主键的情况</li><li><code>DELETE BIT</code>：标识该记录是否被删除</li></ul><p>快照：表示当前 <code>select</code> 时刻或事务第一次<code>select</code>时刻还有哪些未提交的事务，维护一个 list，存储正在运行的事务版本号</p><p>MVCC在可重复读和读已提交隔离级别下的区别：</p><ul><li>在可重复读隔离级别下，并不是事务开始时就建立快照，而是事务中第一个查询语句执行时才会建立快照</li><li>在读已提交隔离级别下，事务内每次执行查询时都会建立快照，即会产生不可重复读的问题</li></ul><p>如何解决脏读和不可重复读问题：</p><ul><li>脏读<br>脏读是一个事务读取到了其他事务未提交的更新的数据。MVCC是通过保存数据在某个时间点的快照来实的，而数据快照都是当前时刻已提交的数据，所以不存在脏读问题</li><li>不可重复读<br>不可重复读是一个事务读取到了其他事务已提交的更新的数据。可重复读隔离级别下的 MVCC 保存的是事务中第一个查询语句执行时的快照，其他事务之后的更新操作不会影响到快照，所以不存在不可重复读问题；而在读已提交隔离级别下的 MVCC 每次执行查询时都会建立快照，能够读取到其他事务已提交的修改数据，所以存在不可重复读问题</li></ul><h4 id="解决幻读问题"><a href="#解决幻读问题" class="headerlink" title="解决幻读问题"></a>解决幻读问题</h4><p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM ... FOR UPDATE; -- 对行加写锁 &#x2F; 排它锁，并且对表加意向排它锁</span><br><span class="line">SELECT * FROM ... LOCK IN SHARE MODE; -- 加读锁 &#x2F; 共享锁，并且对表加意向共享锁</span><br></pre></td></tr></table></figure><p>间隙锁：当用范围条件而不是相等条件检索数据并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录叫做间隙，InnoDB也会对间隙加锁，这种锁机制就是间隙锁</p><p>InnoDB 存储引擎的行锁锁定的是索引，而不是记录本身。如果记录存在，加行锁；如果记录不存在，加 Next-Key Locks / 间隙锁；索引相同的记录都会被加锁，故在设计数据库索引时，最好设计成主键索引或唯一索引</p><h2 id="mysql-进阶"><a href="#mysql-进阶" class="headerlink" title="mysql 进阶"></a>mysql 进阶</h2><h3 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h3><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>分表是将一张大表按照一定的规则分解成多张具有独立存储空间的实体表；分表由开发人员完成</p><p>问题：</p><ul><li>ID：全局唯一ID</li><li>事务：分布式事务</li><li>连接：分解成多个单表查询</li></ul><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>分区是将一张大表按照一定的规则将数据划分在多个位置存放，分区由数据库完成（表仍然在同一个物理机上，但可以在不同的磁盘上）</p><ul><li><p>水平分区</p><ul><li>将一张表按行切分成多张表</li><li>可以通过哈希进行划分，比如 $hash(key)%N$</li><li>可以按照范围进行划分，比如时间段</li><li>可以使用映射表存储映射关系</li></ul></li><li><p>垂直分区</p><ul><li>将一张表按列切分成多张表</li><li>可以按照列的关系密集程度来划分</li><li>可以按照列的使用频率进行划分</li></ul></li></ul><p>MySQL支持RANGE，LIST，HASH和 KEY 四种分区，并且每个分区又都有一种特殊的类型。</p><ul><li><p>range 分区</p><p>根据列值所属范围进行分区，比如时间段；支持数字类型</p></li><li><p>range columns 分区</p><p>参数是列名，支持多列；支持数字，date，datetime，字符串类型</p></li><li><p>list 分区</p><p>列值匹配一个离散值集合中的某个值，比如男女；支持数字类型</p></li><li><p>list columns 分区</p><p>参数是列名，支持多列；支持数字，date，datetime，字符串类型</p></li><li><p>hash 分区</p><p>根据 hash 函数的返回值进行分区，基于模函数，支持数字类型，比如$hash(column)%N$</p></li><li><p>线性 hash 分区</p><p>基于另一种算法，它的优点是在数据量大的场景，譬如TB级，增加、删除、合并和拆分分区会更快，缺点是，相对于HASH分区，它数据分布不均匀的概率更大</p></li><li><p>key 分区</p><p>key 分区使用系统提供的 hash 函数进行分区，支持多列；支持除 <code>text</code> 和 <code>BLOB</code> 之外的所有数据类型</p></li><li><p>线性 key 分区</p><p>同线性 hash 类似</p></li></ul><blockquote><p><a href="https://www.cnblogs.com/ivictor/p/5033708.html" target="_blank" rel="noopener">mysql 分区实现</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 例子：range分区</span><br><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,</span><br><span class="line">    job_code INT NOT NULL,</span><br><span class="line">    store_id INT NOT NULL</span><br><span class="line">)</span><br><span class="line">PARTITION BY RANGE (store_id) (</span><br><span class="line">    PARTITION p0 VALUES LESS THAN (6),</span><br><span class="line">    PARTITION p1 VALUES LESS THAN (11),</span><br><span class="line">    PARTITION p2 VALUES LESS THAN (16),</span><br><span class="line">    PARTITION p3 VALUES LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>一个系统的多张数据表，存储到多个数据库实例中</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><blockquote><p><a href="https://www.cnblogs.com/liulei-LL/p/8087012.html" target="_blank" rel="noopener">主从复制面试之作用和原理</a><br><a href="https://www.cnblogs.com/Aiapple/p/5792939.html" target="_blank" rel="noopener">mysql 主从复制原理</a><br><a href="https://www.cnblogs.com/superfat/p/5267449.html" target="_blank" rel="noopener">mysql实现主从复制</a></p></blockquote><p>主从复制，建立一个或多个和主数据库一样的数据库环境，称为从数据库</p><p>形式：</p><ul><li>一主一从</li><li>主主复制</li><li>一主多从</li><li>多主一从</li><li>联级复制</li></ul><p>作用 / 好处：</p><ul><li>数据热备份，避免数据丢失</li><li>容灾，主数据库故障后可以使用从数据库</li><li>读写分离，主数据库处理写操作及实时性要求比较高的读操作，从数据库处理读操作</li><li>降低单机服务器压力</li></ul><p>原理：</p><ul><li>主库 binlog 线程 ：负责将主数据库上的数据更改写入二进制日志（Binary log）</li><li>从库 I/O 线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）</li><li>从库 SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中执行</li></ul><p>问题</p><blockquote><p><a href="https://blog.csdn.net/xihuanyuye/article/details/81220524" target="_blank" rel="noopener">异步复制、全同步复制与半同步复制（逻辑上和技术上）</a></p></blockquote><ul><li><p>主数据库宕机导致数据丢失</p><p>解决：半同步复制，MySQL 5.5 集成了半同步复制，需要安装插件</p><p>主从复制是异步复制</p><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lni9ff23j20hm096wgb.jpg" alt="异步"></p><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lniwdtftj20he097410.jpg" alt="半同步"></p></li><li><p>从数据库复制延迟</p><p>解决：并行复制，从库多线程复制二进制日志</p></li></ul><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><blockquote><p><a href="https://blog.csdn.net/u013421629/article/details/78793966" target="_blank" rel="noopener">mysql 读写分离</a></p></blockquote><p>主数据库处理写操作及并发性要求比较高的读操作，从数据库处理读操作</p><p>作用 / 好处：</p><ul><li>读操作耗时短，写操作耗时长，读写分离缓解锁竞争，提高数据库的并发负载能力</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</li><li>提高安全性</li></ul><p>实现：</p><ul><li><p>代码实现</p></li><li><p>代理服务器</p><p><img data-src="https://i.loli.net/2019/04/26/5cc271a60a6ca.png" alt="pic"></p></li></ul><h2 id="全局-ID"><a href="#全局-ID" class="headerlink" title="全局 ID"></a>全局 ID</h2><ol><li><p>自动增长</p><ul><li>设置自增偏移和步长：伸缩性不好</li><li>redis 全局 ID 映射表：有延迟</li></ul></li><li><p>UUID (GUID)</p><ul><li><p>UUID 共 128 位，包括机器识别号，时间戳，随机数</p></li><li><p>缺点：存储空间大，无序，性能不好</p></li></ul></li><li><p>Snowflake</p><blockquote><p><a href="https://www.lanindex.com/twitter-snowflake，64位自增id算法详解/" target="_blank" rel="noopener">SnowFlake</a></p></blockquote></li></ol><h2 id="mysql-优化"><a href="#mysql-优化" class="headerlink" title="mysql 优化"></a>mysql 优化</h2><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452966059&idx=2&sn=22a82125544a182a20a3b1fec3113ed0&chksm=88ede7c3bf9a6ed558acf519d9f48a31c0fdaf016a623525a334cd57891a3c5ad2a2ca1ddf19&scene=21#wechat_redirect" target="_blank" rel="noopener">大佬是怎么思考设计MySQL优化方案的</a></p></blockquote><p>性能优化顺序</p><ol><li><p>数据库结构设计和 SQL 优化</p><ul><li><p>索引：正确使用索引，索引不能是表达式的一部分，也不能作为函数的参数；对于多个查询条件使用多列索引比使用单列索引更高效，多列索引满足最长前缀匹配原则；对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引；小表可以直接全表扫描，中型表使用索引，大型表进行分区</p></li><li><p>SQL：使用 <code>Explain</code> 分析查询语句；只返回必要的行和列；不使用外键保证数据完整性和准确性；切分大查询；连表查询转化成单表查询；分批处理，比如使用 LIMIT</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452964589&idx=2&sn=3e1cc9a632aec7cc3e5f71a2a4f076ee&scene=21#wechat_redirect" target="_blank" rel="noopener">MySql常用30种SQL查询语句优化方法</a></p></blockquote><ul><li>尽量避免在 where 中使用<code>!=</code> 或 <code>&lt;&gt;</code> ，否则将进行全表扫描</li><li>尽量避免 <code>null</code> 判断，否则将进行全表扫描</li><li>尽量避免使用 <code>or</code> 进行连接查询，否则将进行全表扫描；可以用 <code>union</code>代替</li><li>尽量避免使用 <code>in</code> 或 <code>not in</code>，否则会导致全表扫描；可以考虑 <code>between ... and ...</code> 或 <code>exist</code></li></ul></li><li><p>缓存：使用 redis 缓存热数据；使用本地内存作为二级缓存；将 MySQL 缓存区调大</p></li><li><p>分区：一张大表按照一定的规则将数据划分在多个位置存放，MySQL 支持 range、list、hash、key 分区</p></li><li><p>垂直分表：将一张大表根据字段关联程度或使用频率切分成多个小表</p></li><li><p>水平分库分表：分布式部署；主从复制，读写分离</p></li></ul></li><li><p>数据库参数配置和存储引擎的选择</p><ul><li><p>数据库参数配置：</p><ul><li><p><code>innodbfileper_table = ON</code> 开启独立表空间，默认开启</p></li><li><p><code>sort_buffer_size</code>：每个线程排序缓存大小</p></li><li><p><code>join_buffer_size</code>：每个线程连表查询缓存大小</p></li><li><p><code>read_buffer_size</code>：每个线程查询缓存大小</p></li><li><p><code>read_rnd_buffer_size</code>：每个线程索引缓存大小</p></li><li><p><code>Innodb_buffer_pool_size</code>： InnoDB 缓存池大小，可以设置大一点</p></li><li><p><code>innodb_flush_log_at_trx_commit=(0,1,2)</code>：1是最安全的，0是性能最高，2折中</p><p>0：每秒进行一次 log 写入 cache，并 flush log 到磁盘</p><p>1：在每次事务提交执行 log 写入 cache，并 flush log 到磁盘</p><p>2：每次事务提交，执行 log 数据写到 cache，每秒执行一次 flush log 到磁盘</p></li><li><p><code>query_cache_size</code>：查询缓存大小</p></li><li><p><code>max_connections</code>：允许的最大连接数</p></li><li><p><code>thread_concurrency</code>：并发线程数</p></li><li><p><code>innodb_lock_wait_timeout</code> ：InnoDB 存储引擎锁的超时时间</p></li></ul></li><li><p>存储引擎选择：对于只读的数据库选择 MyISAM 存储引擎，比如读写分离的从数据库可以选择 MyISAM； InnoDB 使用独立表空间</p></li></ul></li><li><p>系统优化和硬件升级</p><ul><li>选择高性能的硬盘</li></ul></li></ol><h2 id="mysql-问题排查"><a href="#mysql-问题排查" class="headerlink" title="mysql 问题排查"></a>mysql 问题排查</h2><h3 id="MySQL-层面"><a href="#MySQL-层面" class="headerlink" title="MySQL 层面"></a>MySQL 层面</h3><ol><li>mysqlshow：功能强大的查看shell命令</li><li>show [SESSION | GLOBAL] variables：查看数据库参数信息</li><li>SHOW [SESSION | GLOBAL] STATUS：查看数据库的状态信息</li><li>information_schema：获取元数据的方法</li><li>SHOW ENGINE INNODB STATUS：Innodb引擎的所有状态</li><li>SHOW PROCESSLIST：查看当前所有连接session状态</li><li>explain：获取查询语句的执行计划</li><li>show index：查看表的索引信息</li><li>slow-log：记录慢查询语句</li><li>mysqldumpslow：分析slowlog文件的</li></ol><p>CPU 层面：<code>top</code></p><p>内存层面：<code>ps -ef</code> <code>ps -aux</code></p><p>IO 设备：<code>iostat</code></p><p>网络层面：<code>netstat</code></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p><a href="https://www.cnblogs.com/zejin2008/p/5262751.html" target="_blank" rel="noopener">mysql 死锁</a></p><p><a href="http://www.kissyu.org/2017/02/19/记录一次Mysql死锁排查过程/" target="_blank" rel="noopener">记录一次Mysql死锁排查过程</a></p></blockquote><p>MySQL 死锁主要原因是不同连接加锁顺序不一致引起的</p><h2 id="mysql-日志流程"><a href="#mysql-日志流程" class="headerlink" title="mysql 日志流程"></a>mysql 日志流程</h2><p><img data-src="https://i.loli.net/2019/05/23/5ce608f08473165231.jpg" alt="pic"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/04/13/00015/"/>
      <url>/2019/04/13/00015/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/xjEKodtfBmykXch.jpg" alt="bing"></p><a id="more"></a><p>redis 是速度非常快的开源 nosql 键值型数据库，可以存储 String 键和5种不同类型的值之间的映射。redis 内置了复制、LUA脚本、LUA驱动事件、事务、数据持久化，并通过 redis 哨兵（Sentinel）和redis 分区来保证高可用性</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis内部使用一个redisObject对象来表示所有的 key 和 value</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2lonf3hazj20f407v403.jpg" alt="pic"></p><ul><li><p>string：内部存储结构，包含字符数组的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//len表示buf中存储的字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//free表示buf中空闲空间的长度</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//buf用于存储字符串内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字符串类型的值能存储的最大容量是 512M</p></li><li><p>list</p><p>String 类型的双向链表</p></li><li><p>set</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SADD</span> <span class="string">key value1 [value2 value3...] // 添加数据</span></span><br></pre></td></tr></table></figure><p>底层使用 hashMap 的 key 来存储 set 中不重复的数据；hashMap 使用拉链法解决哈希冲突</p></li><li><p>hash</p><ul><li>当HashMap的成员比较少时，redis为了节省内存会采用类似一维数组的方式来紧凑存储，对应 value 的redisObject的encoding为zipmap</li><li>当成员数量增大时，会自动转成真正的HashMap，此时encoding为ht</li></ul></li><li><p>zset</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ZADD</span> <span class="string">key score1 value1 [score2 value2...] // 添加数据</span></span><br><span class="line"><span class="attr">ZCARD</span> <span class="string">key // 获取成员数</span></span><br><span class="line"><span class="attr">ZCOUNT</span> <span class="string">key min max // 指定区间分数的成员数</span></span><br></pre></td></tr></table></figure><p>底层数据结构使用 hashMap 和跳跃表实现，hashMap 键存储成员，值存储 score，跳跃表中存放成员数据</p></li></ul><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="字典-hashMap"><a href="#字典-hashMap" class="headerlink" title="字典(hashMap)"></a>字典(hashMap)</h3><ul><li>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作</li><li>在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色</li><li>采用渐进式 rehash，避免一次性执行过多的 rehash 操作给服务器带来过大的负担</li><li>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash</li></ul><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p><img data-src="https://i.loli.net/2019/04/26/5cc2700d4a7a8.png" alt="pic"></p><h2 id="Redis-内存"><a href="#Redis-内存" class="headerlink" title="Redis 内存"></a>Redis 内存</h2><blockquote><p><a href="https://blog.csdn.net/zlts000/article/details/81952277" target="_blank" rel="noopener">理解Redis的内存</a></p></blockquote><h2 id="Sql-amp-NoSql"><a href="#Sql-amp-NoSql" class="headerlink" title="Sql &amp; NoSql"></a>Sql &amp; NoSql</h2><ul><li>Sql 是关系型数据库；NoSql 是非关系型数据库</li><li>Sql 数据存在特定结构的表中；NoSql 的数据存储比较灵活并支持动态数据，存储格式包括文档和键值对等</li><li>Sql 必须定义表才能添加数据；Nosql 不需要预先定义表</li><li>Sql 支持连表查询；Nosql 除 MongoDB 外暂时不支持连表查询</li><li>Sql 提供了丰富的查询语句；Nosql 只有 MongoDB 提供近似于 Sql 的丰富的查询操作</li></ul><h2 id="Redis-amp-Memcached"><a href="#Redis-amp-Memcached" class="headerlink" title="Redis &amp; Memcached"></a>Redis &amp; Memcached</h2><p>Redis 和 Memcached 都是 nosql 键值型数据库</p><ul><li><p>Redis 的值支持5种数据类型，Memcached 只支持字符串</p></li><li><p>Redis 使用单线程实现，Memcached 使用多线程实现</p><ul><li><blockquote><p><a href="https://blog.csdn.net/chenyao1994/article/details/79491337" target="_blank" rel="noopener">为什么说Redis是单线程的以及Redis为什么这么快</a></p></blockquote></li></ul></li><li><p>Redis 支持数据持久化，Memcached 不支持</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452965876&idx=1&sn=8e652ab31b628af89b275cf8f25544ef&chksm=88ede49cbf9a6d8a10231e1dde14976a6cfdfd08778783bfede076c935158895fa99159ec754&scene=21#wechat_redirect" target="_blank" rel="noopener">RDB 和 AOF 持久化的原理</a></p></blockquote><ul><li>RDB 持久化：将某个时间点的所有数据存入磁盘中</li><li>AOF 持久化：将写命令添加到 AOF 文件（Append Only File）的末尾</li></ul></li><li><p>Redis 支持分布式，Memcached 不支持分布式</p><ul><li>Redis 支持分区， Redis Cluster 实现了分布式的支持，支持主从复制</li><li>Memcached 使用客户端一致性哈希实现分布式</li></ul></li><li><p>Redis 提供了丰富的淘汰策略，Memcached 的数据淘汰策略是基于 LRU 的</p></li><li><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘；Memcached 的数据则会一直在内存中</p></li></ul><h2 id="Redis-amp-MongoDB"><a href="#Redis-amp-MongoDB" class="headerlink" title="Redis &amp; MongoDB"></a>Redis &amp; MongoDB</h2><ul><li>redis 是 nosql 键值型数据库，MongoDB 是 nosql 文档型数据库</li><li>redis 的数据存储格式是键值对，MongoDB 的数据存储格式是 json 格式</li><li>redis 的编写语言是 C，MongoDB 的编写语言是C++</li><li>redis 主要存储少量并发性要求高的数据，MongoDB 主要存储海量读写要求较高的数据</li><li>redis 支持事务，MongoDB 不支持事务</li><li>redis 数据结构简单高效，MongoDB支持索引并支持丰富的查询操作</li><li>redis 不支持数据分析，MongoDB 内置数据性能分析功能</li><li>redis 主要应用于较小数据量的高并发场景，MongoDB 主要应用于海量数据的访问效率提升</li></ul><h2 id="redis-为什么快"><a href="#redis-为什么快" class="headerlink" title="redis 为什么快"></a>redis 为什么快</h2><ul><li><p>redis 是内存型数据库，不需要进行磁盘 IO 读写</p></li><li><p>redis 数据结构简单，并进行专门的设计，比如跳跃表插入简单，不需要旋转操作</p></li><li><p>redis 是单线程的，避免了线程切换的开销以及加锁释放锁的操作</p><ul><li>单线程指使用一个线程处理网路请求</li></ul></li><li><p>redis 使用多路 IO 复用，非阻塞 IO</p><blockquote><p><a href="https://www.cnblogs.com/euphie/p/6376508.html" target="_blank" rel="noopener">同步IO、异步IO、阻塞IO、非阻塞IO之间的联系与区别</a></p></blockquote><ul><li>多路 IO 复用：利用 select、poll、epoll 可以同时监测多个连接的 I/O 事件。空闲时，redis 线程阻塞；当一个连接或多个连接有 IO 事件时，redis 去轮询发生 IO 操作的连接并依次处理</li><li>非阻塞 IO：当没有数据或数据未准备好时会一直阻塞等待数据叫做阻塞 IO；当没有数据或数据未准备好时不会等待数据而可以做其他的事叫做非阻塞 IO</li></ul></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">incr key &#x2F;&#x2F; +1</span><br><span class="line">decr key &#x2F;&#x2F; -1</span><br><span class="line">incrby key value &#x2F;&#x2F; +value</span><br><span class="line">decrby key value &#x2F;&#x2F; -value</span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率</p><blockquote><p><a href="http://developer.51cto.com/art/201803/568922.htm" target="_blank" rel="noopener">同为分布式缓存，为何Redis更胜一筹</a></p><p><a href="https://blog.csdn.net/xlgen157387/article/details/79530877" target="_blank" rel="noopener">缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</a></p></blockquote><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lomjj491j20i306j3z2.jpg" alt="pic"></p><h4 id="二八定律"><a href="#二八定律" class="headerlink" title="二八定律"></a>二八定律</h4><p>网站访问数据的特点大多呈现二八定律：80% 的业务访问集中在20% 的数据上</p><h4 id="热数据和冷数据"><a href="#热数据和冷数据" class="headerlink" title="热数据和冷数据"></a>热数据和冷数据</h4><ul><li>热数据：频繁访问的数据，对服务器要求较高，通常存放在性能较强的服务器中</li><li>冷数据：不经常访问的数据，通常存放在性能较低的服务器中</li></ul><h4 id="缓存一般流程"><a href="#缓存一般流程" class="headerlink" title="缓存一般流程"></a>缓存一般流程</h4><ul><li>用户请求数据</li><li>进行缓存查询，如果存在有效缓存返回缓存数据</li><li>如果缓存不存在或已过期，再进行数据库查询</li><li>数据库返回查询结果并把查询结果写入缓存，数据不存在不存入缓存</li></ul><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询数据库一定不存在的数据，缓存不命中会查询数据库，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透</p><p>解决方案：</p><ul><li><p>布隆过滤器</p><blockquote><p><a href="https://www.cnblogs.com/liyulong1982/p/6013002.html" target="_blank" rel="noopener">布隆过滤器(Bloom Filter)详解</a></p></blockquote></li><li><p>缓存空数据的键，并设置短时间的过期时间</p></li></ul><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>对特定值进行高并发查询，当缓存过期时，会有大量查询集中在数据库上，造成缓存击穿</p><p>解决方案：</p><p>和缓存雪崩类似</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存同一时刻失效或集中在一段时间内失效，发生大量缓存穿透，所有查询都集中在数据库上，造成缓存雪崩</p><p>解决方案：</p><ul><li><p>保证缓存服务高可用：redis 哨兵、redis 集群</p></li><li><p>分散缓存时间：比如在原有缓存时间基础上加入随机值</p></li><li><p>限流</p><ul><li>滑动窗口</li><li>令牌桶算法</li><li>漏桶算法</li></ul></li><li><p>队列：保证不会有大量线程对数据库进行一次性读写</p></li><li><p>加锁排队：应用在并发量不高的场景中，很少使用</p></li><li><p>资源熔断</p></li><li><p>降级</p></li><li><p>二级缓存</p></li></ul><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>通过缓存 reload 机制，预先去加载或更新缓存。再即将发生高并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p><p>实现：</p><ul><li>直接写个缓存刷新页面，上线时手工操作下</li><li>数据量不大，可以在项目启动的时候自动进行加载</li><li>定时刷新缓存</li></ul><h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>redis 提供 6 种缓存淘汰策略：</p><ul><li><code>volatile-lru</code>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li><code>volatile-ttl</code>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li><code>volatile-random</code>：从已设置过期时间的数据集中任意选择数据淘汰</li><li><code>allkeys-lru</code>：从所有数据集中挑选最近最少使用的数据淘汰</li><li><code>allkeys-random</code>：从所有数据集中任意选择数据进行淘汰</li><li><code>noeviction</code>：禁止驱逐数据</li></ul><p>redis 4.0 中引入：</p><ul><li><code>volatile-lfu</code>：从已设置过期时间的数据集中挑选访问频率最少的数据淘汰</li><li><code>allkeys-lfu</code>：从所有数据集中挑选访问频率最少的数据淘汰</li></ul><p>定期删除+惰性删除：</p><ul><li>定期清理过期的缓存：redis 默认每隔 100ms 检查是否有过期的 key，redis 并不是检查所有的 key 是否过期，而是随机抽取 key 并检查是否存在过期的 key</li><li>接受用户请求后判断缓存是否过期：当用户获取 key 时，redis 会检查是否过期，如果过期会删除；不过期就返回给用户</li></ul><p>写缓存更新：</p><blockquote><p><a href="https://www.jianshu.com/p/fbe6a7928229?utm_source=oschina-app" target="_blank" rel="noopener">实现缓存最终一致性的两种方案</a></p><p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">数据库和缓存一致性解析</a></p></blockquote><ul><li><p>同时写入缓存和数据库</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lomv4q4gj20jj0a8jsr.jpg" alt="pic"></p></li><li><p>缓存和数据库解耦</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2lomzxkpmj20hm0ceq4n.jpg" alt="pic"></p></li></ul><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也可以随机服务</p><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><ul><li>计数器<ul><li>使用计数器限制一秒内能够通过的请求数，到达阈值后拒绝其他请求，一秒结束后再重新计数</li><li>缺点：如果请求集中在前几毫秒，之后将无法响应请求，这种现象称为“突刺现象”</li></ul></li><li>漏桶算法<ul><li>类比：相当于水倒入漏斗，不管倒入多少水，下边流出的速度始终保持不变</li><li>可以维护一个消息队列，将请求放入消息队列，然后通过一个线程池定期的从消息队列中读取请求。当桶达到最大容量时，拒绝请求</li><li>缺点：无法处理突发流量并响应时间要求比较短的场景</li></ul></li><li>令牌桶算法<ul><li>令牌桶能限制平均请求速度的同时允许一定程度的突发请求</li><li>使用一个桶存放固定数量的令牌，算法以一定的速率向桶中存放令牌，存放令牌持续不断的进行，当桶满时丢弃令牌。每次请求需要先获取令牌，拿到令牌才能执行，否则等待或拒绝请求</li><li>令牌桶算法运行一定程度的突发请求，比如桶初始化时允许存放100个令牌，那么这时运行100个请求同时调用</li></ul></li></ul><h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>List 是一个双向链表，可以通过 <code>lpush</code> 和 <code>rpop</code> 实现消息队列，但还是推荐使用 Kafka、RabbitMQ 等消息中间件</p><h3 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h3><h4 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h4><p>HTTP 是无状态协议，必须使用会话跟踪技术来为不同的用户提供不同的服务</p><ul><li><p><code>cookie</code></p><p>cookie 存储在客户端，既可以在客户端生成，也可以在服务端生成；不可跨域名</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lommslowj20b405kdfu.jpg" alt="pic"></p><p>若客户端不支持 cookie ， 可以使用 URL 重写技术进行会话跟踪，<code>HttpServletResponse</code> 的 <code>encodeURL(String url)</code> 可以对不支持 cookie 的浏览器，通过把 session id 加入 URL 的方式进行会话跟踪</p></li><li><p><code>session</code></p><p>创建 session 的同时会生成唯一的 session id，session 被创建后可以在 session 中增加键值对，只有 session id 会发送到客户端，客户再次发送请求时，将 session id 一同发往服务器</p><p>session 存储在服务端，每个用户都会有 session，当大量用户访问服务器时，内存开销会不断增大；可扩展性不强，集群需要进行 session 复制或使用特定服务器存储 session 来实现 session 共享</p></li><li><p><code>token</code></p><p>token 存储在客户端</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lomr3m00j20oz0krjt0.jpg" alt="pic"></p></li></ul><h4 id="会话共享"><a href="#会话共享" class="headerlink" title="会话共享"></a>会话共享</h4><p>session 共享技术能够解决负载均衡中不同服务器节点对应不同 session 的问题，可以将 session 存储到 redis 的 hash 数据类型中</p><p>实现方式：</p><ul><li>修改配置文件</li><li>重写读写 session 的代码</li><li>使用 <code>spring</code> 的 <code>spring-session.jar</code></li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在单机场景下，可以使用语言内置的锁来实现多进程 / 线程的同步问题，但是在分布式情况下，语言内置锁无法使用，必须使用分布式锁来保证进程 / 线程同步</p><p>对于操作系统而言，锁可以使用互斥量来实现，互斥量为 0 处于锁定状态，互斥量为 1 处于未锁定状态；分布式锁同样可以借鉴这种思想，将锁存储于数据库中，获取锁插入一条记录，释放锁删除一条记录</p><ul><li>数据库乐观锁</li><li>redis 分布式锁</li><li>ZooKeeper 分布式锁</li></ul><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul><li>互斥性：任意时刻只有一个客户端能持有锁</li><li>不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁</li><li>具有容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁</li><li>解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了</li></ul><h4 id="setnx-指令"><a href="#setnx-指令" class="headerlink" title="setnx 指令"></a>setnx 指令</h4><blockquote><p><a href="https://www.cnblogs.com/linjiqin/p/8003838.html" target="_blank" rel="noopener">Redis分布式锁的正确实现方式</a></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>; <span class="comment">// 保证互斥性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;  <span class="comment">// 保证不会发生死锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁，唯一key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识，保证解铃还须系铃人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间，保证不会发生死锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); <span class="comment">// jedis.eval() 保证执行的原子性</span></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="redLock-算法"><a href="#redLock-算法" class="headerlink" title="redLock 算法"></a>redLock 算法</h4><blockquote><p><a href="https://www.jianshu.com/p/7e47a4503b87" target="_blank" rel="noopener">RedRock:Redis分布式锁最牛逼的实现</a></p></blockquote><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用</p><p>假设在分布式场景下有N个 redis master，步骤如下：</p><ul><li>尝试从 N 个相互独立 Redis 实例获取锁</li><li>计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，那么就认为锁获取成功了</li><li>如果锁获取失败，就到每个实例上释放锁</li></ul><p>实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Config config1 = <span class="keyword">new</span> Config();</span><br><span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://192.168.0.1:5378"</span>)</span><br><span class="line">        .setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class="line"></span><br><span class="line">Config config2 = <span class="keyword">new</span> Config();</span><br><span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://192.168.0.1:5379"</span>)</span><br><span class="line">        .setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class="line"></span><br><span class="line">Config config3 = <span class="keyword">new</span> Config();</span><br><span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://192.168.0.1:5380"</span>)</span><br><span class="line">        .setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class="line"></span><br><span class="line">String resourceName = <span class="string">"REDLOCK_KEY"</span>;</span><br><span class="line"></span><br><span class="line">RLock lock1 = redissonClient1.getLock(resourceName);</span><br><span class="line">RLock lock2 = redissonClient2.getLock(resourceName);</span><br><span class="line">RLock lock3 = redissonClient3.getLock(resourceName);</span><br><span class="line"><span class="comment">// 向3个redis实例尝试加锁</span></span><br><span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line"><span class="keyword">boolean</span> isLock;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// isLock = redLock.tryLock();</span></span><br><span class="line">    <span class="comment">// 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。</span></span><br><span class="line">    isLock = redLock.tryLock(<span class="number">500</span>, <span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    System.out.println(<span class="string">"isLock = "</span>+isLock);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">//TODO if get lock success, do something;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论如何, 最后都要解锁</span></span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>redis 不支持主主复制，redis 的主从复制是异步的</p><p>全量复制：</p><ul><li>从节点设置主节点 <code>slaveof</code></li><li>从节点内部的定时任务发现有主节点信息，开始建立 Socket 连接</li><li>建立连接后，发起 ping 命令，希望得到 pong 响应，否则进行重连</li><li>如果主节点设置了权限，进行权限校验，校验失败复制终止</li><li>主服务器创建 RDB 数据快照发送给从服务器，并将发送期间到达的写命令存储到缓冲区中，发送完 RDB 文件开始发送缓冲区的写命令</li><li>从服务器丢弃所有旧数据，载入主服务器发来的 RDB 快照文件，之后从服务器开始接受主服务器发来的写命令</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令</li></ul><p>部分复制：</p><p>如果在主从复制期间，从节点宕机后恢复，不会进行全量复制，而是进行部分复制。RDB 数据之间的同步非常耗时。所以，Redis 在 2.8 版本退出了类似增量复制的 psync 命令，当 Redis 主从直接发生了网络中断，不会进行全量复制，而是将数据放到缓冲区（默认 1MB）里，在通过主从之间各自维护复制 offset 来判断缓存区的数据是否溢出，如果没有溢出，只需要发送缓冲区数据即可，成本很小，反之，则要进行全量复制，因此，控制缓冲区大小非常的重要</p><ul><li>当从节点出现网络中断，超过了 repl-timeout 时间，主节点就会中断复制连接</li><li>主节点会将请求的数据写入到“复制积压缓冲区”，默认 1MB</li><li>当从节点恢复，重新连接上主节点，从节点会将 offset 和主节点 id 发送到主节点</li><li>主节点校验后，如果偏移量的数后的数据在缓冲区中，就发送 cuntinue 响应 —— 表示可以进行部分复制</li><li>主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态</li></ul><h3 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h3><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器</p><p><img data-src="https://i.loli.net/2019/04/26/5cc2703465eb6.png" alt="pic"></p><h2 id="redis-分片"><a href="#redis-分片" class="headerlink" title="redis 分片"></a>redis 分片</h2><ul><li>范围分片</li><li>哈希分片</li></ul><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上</li><li>服务器分片：Redis Cluster</li></ul><p>配置主从复制：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">127.0.0.1 6379</span></span><br><span class="line"><span class="attr">masterauth</span> <span class="string">&lt;master-password&gt;</span></span><br></pre></td></tr></table></figure><h2 id="redis-集群"><a href="#redis-集群" class="headerlink" title="redis 集群"></a>redis 集群</h2><blockquote><p><a href="https://www.cnblogs.com/PatrickLiu/p/8458788.html" target="_blank" rel="noopener">Redis进阶实践之十一 Redis的Cluster集群搭建</a></p><p><a href="https://www.cnblogs.com/jaycekon/p/6237562.html" target="_blank" rel="noopener">深入浅出Redis-redis哨兵集群</a></p><p><a href="https://www.cnblogs.com/PatrickLiu/p/8458788.html" target="_blank" rel="noopener">Redis集群配置</a></p><p><a href="https://www.cnblogs.com/PatrickLiu/p/8473135.html" target="_blank" rel="noopener">Redis集群伸缩性-扩容&amp;删除</a></p></blockquote><p>能力：</p><ul><li>将数据自动切分到多个节点</li><li>当集群子节点发生故障，其余节点正常提供服务</li></ul><p>要求：</p><ul><li>开启 redis 客户端服务端口：6379</li><li>开启集群总线端口：16379</li></ul><p>分片：</p><ul><li>redis 集群中有16384个散列槽，redis 集群中的每个节点负责散列槽的一个子集</li><li>当添加 redis 节点时，只需要把其他节点的散列槽移动到该节点</li><li>删除 redis 节点时，只需要把当前节点的散列槽交由其他节点管理</li></ul><p>redis 集群一致性保证：redis 集群无法保证数据强一致性，主要原因是主从复制是异步复制</p><h2 id="redis-哨兵"><a href="#redis-哨兵" class="headerlink" title="redis 哨兵"></a>redis 哨兵</h2><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器</p><blockquote><p><a href="https://www.cnblogs.com/jaycekon/p/6237562.html" target="_blank" rel="noopener">redis 哨兵</a></p></blockquote><p>配置哨兵</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port</span> <span class="string">26379</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor mymaster 127.0.0.1 6379 2</span></span><br></pre></td></tr></table></figure><p>启动哨兵</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><img data-src="https://i.loli.net/2019/04/26/5cc27069d5af7.png" alt="pic"></p><ul><li>redis 基于 Reactor 模式开发网络事件处理器<ul><li>Reactor 模式：当请求抵达后，服务处理程序使用I/O多路复用策略，然后同步地派发这些请求至相关的请求处理程序</li></ul></li><li>文件事件：redis 使用 IO 多路复用模型处理网络请求，并将这些请求同步的传送给文件事件分配器，分配器根据事件描述符调用相应的事件处理器</li><li>时间事件：redis 将时间事件存储在无序链表中，通过遍历链表的方式去查找已经到达的时间事件，并交给相应的事件处理器</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2019/04/10/00014/"/>
      <url>/2019/04/10/00014/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/lwJrjL6B8sZDuSH.jpg" alt="bing"></p><a id="more"></a><h2 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h2><p>内存分配 ＆ 垃圾回收</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><img data-src="https://i.loli.net/2019/04/26/5cc26ccb287b9.png" alt="pic"></p><ul><li><p>程序计数器</p><p>记录正在运行的虚拟机字节码指令的地址，当前线程所执行的字节码的行号指示器。本地方法由于调用的是操作系统的方法，无虚拟机字节码指令，故程序计数器为<code>null</code>。</p><ul><li>程序计数器无<code>OutOfMemoryError</code></li></ul></li><li><p>Java虚拟机栈<br><img data-src="https://i.loli.net/2019/04/26/5cc26cfdcc1da.png" alt="pic"></p><ul><li>栈帧：Java虚拟机栈的栈元素是栈帧。当Java方法被调用时，代表这个方法的栈帧入栈；当Java方法返回时，栈帧出栈<ul><li>局部变量表</li><li>操作数栈</li><li>动态链接<br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接</li><li>方法出口</li><li>…</li></ul></li><li>局部变量表：存储方法的局部变量以及方法参数，不能直接使用，必须通过相关指令将其压入操作数栈中再使用。局部变量表的空间单位是<code>slot</code>，对于 32 位之内的数据，用一个 slot 来存放，如 int，short，float 等；对于 64 位的数据用连续的两个 slot 来存放，如 long，double 等<ul><li>基本数据类型</li><li>对象引用</li><li>方法参数</li></ul></li><li>操作数栈：Java 虚拟机指令由操作码和操作数组成。操作码是代表某种特定操作含义的数字，操作数是操作码的参数。Java 方法的操作码存储在操作码栈中，操作数栈可理解为 Java 虚拟机栈中的一个用于计算的临时数据存储区</li><li>StackOverflowError：若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError</li><li>OutOfMemoryError：当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常<ul><li>内存溢出：系统已经不能再分配你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出</li><li>内存泄露：意思就是你用资源的时候为他开辟了一段空间，当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，但是内存泄漏次数多了就会导致内存溢出</li></ul></li></ul></li><li><p>本地方法栈</p><p><img data-src="https://i.loli.net/2019/04/26/5cc26d2cae0cf.png" alt="pic"></p><p>Java 可以通过 JNI 来调用其他语言的程序，在Java里用 <code>native</code> 修饰符表示本地方法。本地方法如果是以字节码实现的话，可以将 Java 虚拟机栈和本地方法栈合并，<code>hotspot</code>虚拟机把虚拟机栈和本地方法栈合二为一。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2ri5yp3jxj20fy0acta3.jpg" alt="pic"></p></li><li><p>堆（GC堆）</p><ul><li><p>对象实例</p></li><li><p>数组：数组也是对象</p><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2ries5pyoj20kt0cttc3.jpg" alt="pic"></p></li></ul></li><li><p>方法区</p><ul><li>已被加载的类信息</li><li>常量</li><li>静态变量</li><li>即时编译器编译的代码</li><li>…</li></ul><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2rh3u9fqwj20ie07ytcy.jpg" alt="pic"></p><p>方法信息中包含方法字节码</p></li><li><p>运行时常量池<br>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域</p></li></ul><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h4 id="堆对象回收"><a href="#堆对象回收" class="headerlink" title="堆对象回收"></a>堆对象回收</h4><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lof9a3naj20jm06vq35.jpg" alt="对象.png"></p><ul><li><p>引用计数算法<br>给对象添加引用计数器，当有一个地方引用时，计数器+1；当引用失效时，计数器-1；计数器为0的对象可以被回收</p><ul><li><p>优点：简单高效</p></li><li><p>缺点：循环引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyObject A = <span class="keyword">new</span> MyObject();</span><br><span class="line">    MyObject B = <span class="keyword">new</span> MyObject();</span><br><span class="line">    A.instance = B;</span><br><span class="line">    B.instance = A;</span><br><span class="line">    A = <span class="keyword">null</span>;</span><br><span class="line">    B = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用引用计数算法不会被回收</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可达性分析算法</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2lofww1cij20ry0bamy6.jpg" alt="pic"></p><p>以一系列称为 <code>GC Root</code> 的对象为起始点向下搜索，搜索所走过的路径称为“引用链”，没有任何引用链相连的对象可以被回收</p><p>可作为 <code>GC Root</code> 的对象：</p><ul><li>Java 虚拟机栈的局部变量表中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中类常量引用的对象</li></ul><p>引用（引用强度依次递减）</p><ul><li>强引用<br>存在强引用，垃圾回收器不会回收</li><li>软引用<br>有用但并非必要的对象，当系统即将内存溢出时，将会把这些对象列入回收范围进行二次回收</li><li>弱引用<br>存活到下次垃圾回收之前</li><li>虚引用<br>为一个对象设置虚引用的目的是在这个对象被回收时会收到系统通知，虚引用不会对对象生命周期构成影响</li></ul></li></ul><h4 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h4><ul><li><p>常量回收</p><p>和堆中对象类似，没有被引用可被回收</p></li><li><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法</li></ul></li></ul><p>在 Hotspot 虚拟机中使用永久代实现方法区，由于方法区的回收率特别低。在 jdk1.7 后将常量池和静态变量存储到 Java 堆中，jdk1.8 后完全移除方法区，并将类信息存储于元空间中，元空间在本地内存中</p><h3 id="垃圾收集算法（方法论）"><a href="#垃圾收集算法（方法论）" class="headerlink" title="垃圾收集算法（方法论）"></a>垃圾收集算法（方法论）</h3><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2lognuym9j20yt0cbwg4.jpg" alt="pic"></p><p>新生代：复制</p><p>老年代：标记-清除、标记-整理</p><h3 id="垃圾收集器（具体实现）"><a href="#垃圾收集器（具体实现）" class="headerlink" title="垃圾收集器（具体实现）"></a>垃圾收集器（具体实现）</h3><p><img data-src="https://i.loli.net/2019/04/26/5cc26e4932e1f.jpg" alt="pic"></p><ul><li><p>串行：垃圾回收和程序运行代码串行</p></li><li><p>并行：垃圾回收和程序代码并发执行</p></li><li><p>Serial 收集器<br>复制算法；串行、单线程；适用场景：运行在<code>client 模式下的虚拟机</code></p></li><li><p>ParNew 收集器</p><p>复制算法；串行、多线程；适用场景：多核CPU</p></li><li><p>Parallel Scavenge 收集器</p><p>复制算法；串行、吞吐量优先、自适应调节策略；适用场景：注重高吞吐量</p></li><li><p>Serial Old 收集器<br>串行，标记-整理算法</p></li><li><p>Parallel Old 收集器<br>c串行，标记-整理算法</p></li><li><p>CMS 收集器</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul></li></ul><blockquote><p><a href="https://segmentfault.com/a/1190000004707217" target="_blank" rel="noopener">CMS为什么采用标记-清除算法</a></p></blockquote><p>  标记-清除算法；并行，以获取最短回收停顿时间为目标；适用场景：注重响应速度</p><ul><li><p>G1 收集器：并行</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><blockquote><p><a href="https://segmentfault.com/a/1190000017166003" target="_blank" rel="noopener">G1 垃圾收集器介绍</a></p></blockquote></li></ul><h3 id="垃圾收集器使用场景"><a href="#垃圾收集器使用场景" class="headerlink" title="垃圾收集器使用场景"></a>垃圾收集器使用场景</h3><ul><li><strong>Serial</strong>：适用于 Client 模式</li><li><strong>ParNew</strong>：适用于 Server 模式，与 CMS 搭配</li><li><strong>Parallel Scavenge</strong>：适用于后台计算，不需要太多交互的批处理系统</li><li><strong>Serial Old</strong>：适用于 Client 模式</li><li><strong>Parallel Old</strong>：适用于 Server 模式</li><li><strong>CMS</strong>：以最短垃圾回收时间为目的，适用于响应速度要求高的交互式系统</li><li><strong>G1</strong>：适用于服务端，在多 CPU 和大内存的场景下有很好的性能</li></ul><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ul><li><p><code>minor GC</code> &amp; <code>full GC</code></p><ul><li>minor GC ：回收新生代</li><li>major GC：回收老年代</li></ul></li><li><p>full GC：回收老年代，伴随着新生代的回收</p></li><li><p>内存分配</p><ul><li>对象优先分配在 Eden 区</li><li>大对象直接进入老年代</li><li>长期存活对象进入老年代：为对象设置年龄</li><li>动态对象年龄判断</li><li>空间分配担保</li></ul></li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2lohfiw34j20k70bjt9j.jpg" alt="pic"></p><h3 id="对象分配位置"><a href="#对象分配位置" class="headerlink" title="对象分配位置"></a>对象分配位置</h3><ul><li>堆</li><li>Java 虚拟机栈<ul><li>逃逸分析：判断对象的作用域是否有可能逃逸出函数体</li><li>标量替换：</li></ul></li><li>Thread Local Allocation Buffer (TLAB)</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ul><li>句柄</li><li>直接指针：<code>hotspot</code>使用直接指针</li></ul><h2 id="class-文件结构"><a href="#class-文件结构" class="headerlink" title="class 文件结构"></a>class 文件结构</h2><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2loi3xmchj20sc0z5tcm.jpg" alt="class脑图"></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类初始化情况"><a href="#类初始化情况" class="headerlink" title="类初始化情况"></a>类初始化情况</h3><blockquote><p><a href="https://blog.csdn.net/lixin88/article/details/72590713" target="_blank" rel="noopener">类初始化</a></p></blockquote><ol><li>遇到<code>new</code> <code>getstatic</code> <code>putstatic</code> <code>invokestatic</code> 这四个指令时，如果未初始化会触发初始化<ul><li>编译期常量不依赖类，不会触发类的初始化；运行期常量依赖类，会触发类的初始化</li></ul></li><li>使用 Java 反射机制对类反射调用时，如果未初始化会触发初始化</li><li>当初始化一个类时，父类未初始化会触发初始化</li><li>虚拟机启动需要用户指定一个要执行的主类，会触发主类初始化</li><li>jdk 1.7 ，使用<code>java.lang.invoke.MethodHandle</code>实例解析方法句柄所对应的类未初始化会触发初始化</li></ol><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><blockquote><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">类加载过程</a></p></blockquote><ul><li><p>加载：通过类加载器 ClassLoader 进行加载</p><ul><li>通过类的完全限定名称获取定义该类的二进制字节流</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口</li></ul><p>加载阶段完成后二进制字节流就按照虚拟机所需的格式存储在方区去中</p></li><li><p>验证</p><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul></li><li><p>准备：为类变量分配内存并设计系统初始值</p></li><li><p>解析</p></li><li><p>初始化</p></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>四种类加载器</p><ul><li><p><code>Bootstrap</code>类加载器</p><p>加载核心库， <code>rt.jar</code> 中的JDK类文件</p></li><li><p><code>Extension</code> 类加载器<br>加载扩展库，从 <code>jre/lib/ext</code> 目录下或者 <code>java.ext.dirs</code> 系统属性定义的目录下加载类</p></li><li><p><code>System</code> 类加载器</p><p>从 <code>classpath</code> 环境变量中加载某些应用相关的类</p></li><li><p>Custom 类加载器</p><p>自定义的类加载器</p></li></ul><p>三个机制：</p><ul><li>委托机制<br><code>System</code> -&gt; <code>Extension</code> -&gt; <code>Bootstrap</code>，保证 java 核心库的安全性</li><li>可见性<br>子类加载器可以看到父类加载器加载的类，而反之则不行</li><li>单一性<br>父加载器加载过的类不能被子加载器加载第二次</li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>自定义类加载器的核心在于对字节码文件的获取。最好不要重写loadClass方法，因为这样容易破坏双亲委托模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-内存模型与线程"><a href="#java-内存模型与线程" class="headerlink" title="java 内存模型与线程"></a>java 内存模型与线程</h2><h3 id="硬件并发"><a href="#硬件并发" class="headerlink" title="硬件并发"></a>硬件并发</h3><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2loivht55j20ig09qjrp.jpg" alt="pic"></p><h3 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h3><p>java 内存模型试图屏蔽硬件和操作系统的内存访问差异，以实现 java 在各个平台都有相同的内存访问效果。java 内存模型的主要目标是定义程序中变量的访问规则，这里的变量指的是堆和方法区中的变量，而不包括 java 虚拟机栈和本地方法栈中的局部变量。</p><p><img data-src="https://i.loli.net/2019/04/26/5cc26dd160f66.png" alt="pic"></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>主内存和工作内存具体的交互协议，Java 内存模型定义了8个基本操作：</p><p><img data-src="https://i.loli.net/2019/04/26/5cc26dff2a41a.png" alt="pic"></p><ul><li>lock：作用于主内存，把变量标记为一个线程独占</li><li>unlock：作用于主内存，把处于锁定状态的变量释放</li></ul><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>Java 虚拟机提供的轻量级同步机制，被定义为 <code>volatile</code> 的变量具有两个特性</p><ul><li><p>可见性：保证此变量对所有线程可见，当其中一个线程修改该变量时，其他线程能够立刻得知；可见性不能保证并发安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        val++;  <span class="comment">// 不具备原子性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    incr();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(getVal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>volatile</code> 具有可见性，但无法保证代码执行的原子性。此例中，自增操作由4个字节码指令构成：<code>getstatic</code>、<code>iconst_1</code>、<code>iadd</code>、<code>putstatic</code>。 <code>volatile</code> 可以保证<code>getstatic</code>时是正确的，但是无法保证入栈操作和累加操作时，<code>val</code>值是最新的。</p></li><li><p>禁止指令重排序优化</p></li></ul><h3 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h3><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><blockquote><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">先行发生原则</a></p></blockquote><h2 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h2><p>当多个线程同时访问共享对象时，取得这个对象的结果始终是正确的</p><h3 id="Java-线程安全"><a href="#Java-线程安全" class="headerlink" title="Java 线程安全"></a>Java 线程安全</h3><p>在 Java 语言中，操作共享数据可以分为以下5类：</p><ul><li><p>不可变<br>不可变的对象一定是线程安全的，<code>final</code>、<code>String</code></p></li><li><p>绝对线程安全<br>不管调用环境如何，调用者都不需要额外的同步措施</p></li><li><p>相对线程安全</p><p>对象的单独操作是线程安全的</p></li><li><p>线程兼容<br>对象本身不是线程安全的，需要调用者使用正确的同步手段来保证线程安全</p></li><li><p>线程对立</p><p>无论调用者是否采取同步手段，都无法保证线程安全</p></li></ul><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><p>锁类型</p><ul><li>可重入锁：当线程执行某方法获得一个锁后，再次尝试获得该锁不会被阻塞</li><li>不可重入锁：当线程执行某方法获得一个锁后，再次尝试获得该锁会被阻塞</li><li>可中断锁：当线程在等待锁的过程中，可以中断转而去执行其他的任务</li><li>公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</li></ul><p>方法：</p><ul><li>互斥同步<ul><li>synchronized：可重入锁，非公平锁，需要指定一个引用参数作为锁对象。若不指定参数，实例方法的参数是<code>this</code>，静态方法的参数是<code>Class</code></li><li>ReentrantLock：可重入锁，默认非公平锁。高级特性：等待可中断、公平锁、绑定多个条件</li></ul></li><li>非阻塞同步<ul><li>CAS：处理器指令，是原子操作。需要3个操作数：内存地址、旧的预期值、新值。存在ABA问题，通过版本号解决ABA问题</li></ul></li><li>无同步方案<ul><li>线程私有变量无需同步</li><li>线程本地存储</li></ul></li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ul><li><p>自旋锁：为了让线程等待，只需让线程执行一个忙循环（自旋）</p></li><li><p>锁消除：虚拟机即时编译器在运行时，对一些在代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</p></li><li><p>锁粗化<br>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。锁粗化通过扩大锁作用域的方式将多个锁转化成一个锁</p></li><li><p>轻量级锁<br>在无竞争的情况下，使用CAS操作去消除同步使用的互斥量</p></li><li><p>偏向锁</p><p>在无竞争的情况下，去掉同步操作</p></li></ul><h3 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁 / 轻量级锁 / 重量级锁"></a>偏向锁 / 轻量级锁 / 重量级锁</h3><p>锁的状态：</p><ul><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ul><p>锁的状态是通过对象监视器在对象头中的字段来表明的。四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。<strong>这四种状态都不是Java语言中的锁</strong>，而是Jvm为了提高锁的获取与释放效率而做的优化(<strong>使用synchronized时</strong>)</p><p><strong>偏向锁</strong>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价</p><p><strong>轻量级</strong>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能</p><p><strong>重量级锁</strong>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低</p><h2 id="jvm-参数设置"><a href="#jvm-参数设置" class="headerlink" title="jvm 参数设置"></a>jvm 参数设置</h2><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2rivyd4fcj20e007y0t2.jpg" alt="pic"></p><ul><li><code>-Xms10m</code>：jvm 堆初始化内存</li><li><code>-Xmx10m</code>：jvm 堆最大内存</li><li><code>-Xmn10m</code>：jvm 新生代初始化内存</li><li><code>-XX:NewSize</code>：jvm 新生代初始化内存</li><li><code>-XX:MaxNewSize</code>：jvm 新生代最大内存</li><li><code>-XX:PermSize=16M</code> ：永久代初始化内存</li><li><code>-XX:MaxPermSize=64M</code>：永久代最大内存</li><li><code>-XX:Xss=128K</code>：栈内存大小</li><li><code>-XX:SurvivorRatio</code>：设置Eden和其中一个Survivor的比值</li><li><code>-XX:InitialTenuringThreshol</code>：晋升到老年代年龄的最小值</li><li><code>-XX:MaxTenuringThreshold</code>：晋升到老年代年龄的最大值</li></ul><h2 id="jvm-调优"><a href="#jvm-调优" class="headerlink" title="jvm 调优"></a>jvm 调优</h2><p>jvm 调优并不是一成不变的，而是根据不同的系统来进行分析。可以在运行系统前进行初始化调优，也可以根据运行情况来监测系统从而发现问题解决问题</p><h3 id="jvm-监测"><a href="#jvm-监测" class="headerlink" title="jvm 监测"></a>jvm 监测</h3><p>可以从 CPU 、内存和磁盘等角度对程序进行分析</p><ul><li>CPU<ul><li><code>top</code> ：找到占用 CPU 高的进程</li><li><code>top -p pid -H</code> ：找到占用 CPU 高的线程</li><li><code>jstack -l pid &gt;temp.log</code>：打印堆栈日志</li></ul></li><li>jvm 内存<ul><li><code>jmap -heap pid</code>：查看堆的分布情况</li><li><code>jstat -gcuitl pid 2000 10</code>：每隔 2s 输出 GC 次数，输出 10 次</li></ul></li></ul><h3 id="高性能硬件程序部署策略"><a href="#高性能硬件程序部署策略" class="headerlink" title="高性能硬件程序部署策略"></a>高性能硬件程序部署策略</h3><p>对于 64 位大内存的操作系统来说，如果想充分利用硬件资源，可以有两种部署方式：</p><ul><li>通过 64 位 JDK 使用大内存：如果堆内存分配太大，需要考虑 <code>Full GC</code> 的频率</li><li>使用若干 32 位虚拟机部署虚拟集群</li></ul><h3 id="堆外内存溢出"><a href="#堆外内存溢出" class="headerlink" title="堆外内存溢出"></a>堆外内存溢出</h3><ul><li>栈溢出：使用 <code>-Xss</code> 调整大小</li><li>直接内存溢出：使用 <code>-XX:MaxDirectMemorySize</code> 调整大小</li></ul><h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><p>对于服务处理时间不均等，一快一慢的远程调用，使用异步的方式进行处理，比如消息队列</p><h3 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h3><ul><li>堆大小的调优：一般来说堆越大越好。可以降低 GC 的频率，但会提高单次 GC 的时间。可以增加堆内存并设置定时任务，在深夜触发 GC</li><li>新生代调优：增加新生代的大小会减少 Minor GC 的频率，但这并不意味着会增加单次 Minor GC 的时间。新生代调优的目的是尽可能的待在新生代，减少晋升老年代的对象。但长期存活的对象在新生代频繁复制也会造成不必要的开销，所以需要权衡新生代晋升老年代的年龄的阀值</li><li>老年代调优：尽可能的调优新生代；对 CMS 垃圾回收器手动进行 Full GC</li></ul><h2 id="dump-文件"><a href="#dump-文件" class="headerlink" title="dump 文件"></a>dump 文件</h2><p>获取进程 pid：<code>ps -aux | grep java</code></p><p>获取线程ID：<code>top -p pid -H</code></p><p>获取 dump</p><ul><li><code>jmap</code>：Java 自带工具，<code>jmap -heap pid</code></li><li><code>kill</code>：Linux 命令，<code>kill -3 pid</code></li><li><code>jstack</code>：sun JDK 工具，<code>jstack pid</code></li></ul><h2 id="文献"><a href="#文献" class="headerlink" title="文献"></a>文献</h2><ol><li><p><a href="https://www.cnblogs.com/duanxz/p/3732300.html" target="_blank" rel="noopener">java体系结构-总体介绍</a></p></li><li><p><a href="https://www.cnblogs.com/duanxz/p/3728748.html" target="_blank" rel="noopener">java体系结构-类加载器（一）</a></p></li><li><p><a href="https://www.cnblogs.com/duanxz/p/3728744.html" target="_blank" rel="noopener">JVM体系结构-类加载器（二）</a></p></li><li><p><a href="https://www.cnblogs.com/duanxz/p/3728737.html" target="_blank" rel="noopener">java体系结构-方法区（一）</a></p></li><li><p><a href="https://www.cnblogs.com/duanxz/p/3726574.html" target="_blank" rel="noopener">JVM体系结构-方法区（二）</a></p></li><li><p><a href="https://www.cnblogs.com/duanxz/p/3724459.html" target="_blank" rel="noopener">JVM体系结构-本地方法栈</a></p></li><li><p><a href="https://www.cnblogs.com/duanxz/p/3724473.html" target="_blank" rel="noopener">JVM体系结构-堆（一）</a></p></li><li><p><a href="https://www.cnblogs.com/duanxz/p/3726563.html" target="_blank" rel="noopener">JVM体系结构-堆（二）</a></p></li><li><p><a href="https://www.cnblogs.com/duanxz/p/3482366.html" target="_blank" rel="noopener">JVM参数汇总</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-基础知识</title>
      <link href="/2019/03/17/00013/"/>
      <url>/2019/03/17/00013/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/Cnm15g3KuQGHJfq.jpg" alt="CorsiniGardens_ZH-CN8547012221_1920x1080.jpg"></p><a id="more"></a><blockquote><p><a href="https://www.icourse163.org/course/HIT-154005" target="_blank" rel="noopener">计算机网络视频</a><br><a href="https://dzapathy.github.io/2019/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络-基础知识</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/">计算机网络-应用层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络-传输层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-网络层</a><br><a href="https://dzapathy.github.io/2019/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络-数据链路层</a></p></blockquote><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络是互连的、自治的计算设备集合</p><ul><li>互连：互联互通，通过交换网络互连主机，交换网络的交换节点是路由器</li><li>自治：无主从关系</li></ul><h2 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h2><ul><li><p>网络边缘：主机</p><p>主机运行网络应用程序，主机之间的通信方式包括：</p><ul><li>客户端-服务器(CS)：客户端发送请求，服务端响应请求</li><li>浏览器-服务器(BS)：浏览器发送请求，服务端响应请求</li><li>对等(P2P) ：不区分客户端和服务器</li></ul></li><li><p>接入网络：有线或无线通信链路，将网络边缘接入网络核心</p><ul><li>家庭接入网络</li><li>机构接入网络</li><li>无线接入网络</li><li>…</li></ul></li><li><p>网络核心：路由器等</p><ul><li>路由：通过路由算法计算本地转发表</li><li>转发：根据本地转发表将分组从路由器的输入端口交换到正确的输出端口</li></ul></li></ul><p>互联网服务提供商 ISP 负责将网络边缘接入网络核心并进行网络通信。ISP 可以从互联网管理机构获得 IP 地址并拥有通信链路和联网设备。目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2lrg390i2j20se0ic0ts.jpg" alt="pic"></p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>多路复用指共享链路的技术</p><ul><li><p>频分多路复用</p><p>将信道资源在频率上进行划分，每路信号只是用其中的一个频段的子信号，比如有线电视网路</p></li><li><p>时分多路复用</p><p>将时间划分成时间片</p></li><li><p>波分多路复用</p><p>将信道资源在光的波长上进行划分</p></li><li><p>码分多路复用</p><p>m每个用户都有自己的码片序列，广泛应用于无线链路共享</p></li><li><p>统计多路复用</p><p>在路由器转发分组时，按需共享链路</p></li></ul><h2 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h2><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>在固定时间内能够通过的最大数据量，单位是 <code>bps</code> <code>Kbps</code> 等。它是网络设备的指标，是一个固定值</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>对网络、设备、端口、虚电路或其他设施，单位时间内成功地传送数据的数量，单位也是 <code>bps</code> <code>Kbps</code> 等。吞吐量和带宽的区别是，吞吐量描述当前网络的传输性能，从发送端到接收端的<code>bps</code>。比如，一个带宽为<code>10Mbps</code>的链路连接的一对节点可能只达到<code>2Mbps</code> 的吞吐量。</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><ul><li><p>排队时延</p><p>分组在输入队列和输出队列中排队等待的时间</p></li><li><p>处理时延</p><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等</p></li><li><p>传输时延</p><p>主机或路由器传输数据帧所需要的时间</p></li><li><p>传播时延</p><p>电磁波在信道中传播所需要花费的时间</p></li></ul><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2lta4wsb8j20hn02paam.jpg" alt="pic"></p><p>类比：传输时延指车队通过收费站所需的时间，而传播时延指一辆车从一个收费站到另一个收费站的时间</p><h2 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h2><ul><li><p>电路交换</p><p>电路交换需要 3 个阶段：建立连接、通信和断开连接。两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路，断开连接后链路可以被其他连接使用</p></li><li><p>报文交换</p><p>报文交换是将报文作为一个整体，一次性发送给接收端。报文交换是串行的</p></li><li><p>分组交换</p><p>将报文拆分成报文段，每一个报文段是一个分组。分组交换需要报文的拆分和分组，分组交换是并行的</p></li></ul><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><blockquote><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%A6%82%E8%BF%B0?id=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">计算机网络基础知识</a></p></blockquote><p><img data-src="https://i.loli.net/2019/04/26/5cc26f9333dd8.png" alt="pic"></p><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><ul><li>应用层</li><li>传输层</li><li>物理层</li><li>数据链路层</li><li>物理层</li></ul><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>物理层</li><li>数据链路层</li><li>物理层</li></ul><h3 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP / IP 协议"></a>TCP / IP 协议</h3><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>网路接口层</li></ul><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2ltj2230tj20bb09x0sq.jpg" alt="pic"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-基础知识</title>
      <link href="/2019/03/17/00012/"/>
      <url>/2019/03/17/00012/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/Js1PXKOiQjWDLwr.jpg" alt="Tegallalang_ZH-CN1855493751_1920x1080.jpg"></p><a id="more"></a><blockquote><p><a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about" target="_blank" rel="noopener">操作系统视频</a></p></blockquote><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul><li><p>并发</p><ul><li>并发：在一段时间内同时运行多个程序。操作系统引入进程和线程，使得程序能够并发执行</li><li>并行：在同一时刻同时运行多个指令。并行需要硬件支持，比如多核 CPU</li></ul></li><li><p>共享</p><p>系统中的资源可以被多个并发进程共享</p><ul><li>互斥共享：互斥共享的资源称为临界区。在同一时刻只允许一个进程访问，需要用同步机制来实现临界区的访问</li><li>同时共享：同一时刻运行多个进程访问，不需要同步机制</li></ul></li><li><p>虚拟</p><p>把物理实体转化为逻辑实体</p><ul><li>时分复用技术：进程或线程的时间片轮询技术。每个虚拟处理器获得时间片后，可供进程执行</li><li>空分复用技术：虚拟内存</li></ul></li><li><p>异步</p><p>进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进</p></li></ul><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ul><li><p>进程管理</p><p>进程控制、进程同步、死锁处理、进程通信等</p></li><li><p>内存管理</p><p>内存分配、内存映射、虚拟内存、内存保护和共享等</p></li><li><p>文件管理</p><p>文件存储、目录管理、文件访问和保护等</p></li><li><p>设备管理</p><p>缓冲管理、设备分配、设备处理等</p></li></ul><h2 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态 &amp; 内核态"></a>用户态 &amp; 内核态</h2><p>操作系统启动之后，会加载操作系统的内核，然后将操作系统的控职权交由内核管理。内核与应用程序、外部设备等打交道</p><h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><ul><li>当进程执行应用程序的代码时，处于用户态</li><li>当进程通过系统调用陷入内核态执行内核代码时，处于内核态</li></ul><p>用户态和内核态是操作系统的两种运行级别，用户态的运行级别最低，内核态的运行级别最高；对 Linux 操作系统来说，当程序运行在3级特权时处于用户态，当程序运行在0级特权时处于内核态</p><p>对于 32 位操作系统来说，用户态的地址空间是$0 \sim 3G-1$，内核态的地址空间是$3G \sim 4G-1$</p><h3 id="用户态转内核态（中断）"><a href="#用户态转内核态（中断）" class="headerlink" title="用户态转内核态（中断）"></a>用户态转内核态（中断）</h3><ul><li>系统调用</li><li>异常</li><li>外中断</li></ul><p>系统调用、异常、外中断可以统称为中断，中断根据来源不同还可以分为硬中断和软中断</p><ul><li>硬中断：由硬件发出的中断请求</li><li>软中断：由软件发出的中断请求</li></ul><p>由用户态转内核态的系统开销会很大：</p><ul><li>引导机制</li><li>建立内核堆栈</li><li>验证参数</li><li>内核态映射到用户态的地址空间</li></ul><h4 id="系统调用-amp-异常"><a href="#系统调用-amp-异常" class="headerlink" title="系统调用 &amp; 异常"></a>系统调用 &amp; 异常</h4><p>操作系统与应用程序打交道主要通过系统调用和异常实现</p><ul><li>系统调用：应用程序调用系统调用接口，主动向操作系统发出的服务请求，应用程序正常运行</li><li>异常：应用程序产生异常，指令执行失败，内核通过异常服务处理，捕获到应用程序的异常并抛出异常</li></ul><h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><p>操作系统与外部设备打交道主要通过中断机制实现。例，键盘输入时会把数据写到一个特定的缓冲区，这个缓冲区有大小限制，如果数据超过其限制大小就会造成数据丢失，所以外部设备需要通过中断机制，及时向内核发出指令，然后内核通过调用设备驱动程序，及时把缓冲区的内容读写到内核中</p><p>中断和陷入：</p><ul><li><p>外中断（中断）</p><p>CPU 外部引起的中断。中断是 CPU 对 IO 设备发来的中断信号的一种响应。当发生中断时，CPU 停止正在执行的程序，保留 CPU 的环境，转而去执行相应的中断处理程序。执行完中断处理程序后，再回到 CPU 断点继续执行原来的程序</p></li><li><p>内中断（陷入）</p><p>CPU 内部引起的中断，如非法指令、地址越界等。当发生陷入时，CPU 停止正在执行的程序，保留 CPU 的环境，转而去执行陷入处理程序。执行完陷入处理程序后，再回到 CPU 断点继续执行原来的程序</p></li></ul><h4 id="中断处理方式"><a href="#中断处理方式" class="headerlink" title="中断处理方式"></a>中断处理方式</h4><ul><li><p>屏蔽中断</p><p>当 CPU 处理一个中断时，会屏蔽其他的中断，直到 CPU 处理完本次中断后再去检查是否还有中断发生</p><p>优点：简单</p><p>缺点：不适用实时性比较高的中断</p></li><li><p>嵌套中断</p><p>设置中断优先级。当同时有多个优先级的中断请求时，CPU 优先处理高优先级的中断；高优先级的中断可以抢占正在运行的低优先级的中断</p></li></ul><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2ln6kogouj20io0buacy.jpg" alt="pic"></p><h4 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h4><ul><li>源头：中断是外设引起的，系统调用是应用程序主动请求系统服务，异常是应用程序意想不到的错误</li><li>响应方式：中断是异步的，系统调用是同步或异步的，异常是同步的</li></ul><h2 id="大内核-amp-微内核"><a href="#大内核-amp-微内核" class="headerlink" title="大内核 &amp; 微内核"></a>大内核 &amp; 微内核</h2><ul><li>大内核：将操作系统的功能作为紧密的整体放到内核中<ul><li>优点：各模块共享信息，性能高</li><li>内核复杂度高</li></ul></li><li>微内核：将一部分功能移除内核，降低内核的复杂度<ul><li>内核复杂度低</li><li>频繁进行系统调用，造成性能开销。应用进程与移到用户态的操作系统功能需要通过内核来进行通信</li></ul></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>高级语言编译成汇编语言，汇编语言再次编译成二进制程序，如果有函数调用需要经过连接进行合并生成最终的目标文件</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2ln8e8w29j20uk05o0tu.jpg" alt="pic"></p><p>静态链接和动态链接</p><blockquote><p><a href="https://blog.csdn.net/lisongjia123/article/details/49003159" target="_blank" rel="noopener">静态链接和动态链接</a></p></blockquote><ul><li><p>静态链接</p><p>在生成可执行文件时，把所有需要的函数的二进制码都包含到可执行文件中</p></li><li><p>动态链接<br>在真正使用时，才会将使用的函数的二进制码调入到内存中</p></li></ul><h2 id="硬链接-amp-软连接"><a href="#硬链接-amp-软连接" class="headerlink" title="硬链接 &amp; 软连接"></a>硬链接 &amp; 软连接</h2><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">理解 Linux 的硬链接与软链接</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Operating Systems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础知识</title>
      <link href="/2019/03/16/00011/"/>
      <url>/2019/03/16/00011/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/1POCN9Hrd6aqjxZ.jpg" alt="bing"></p><a id="more"></a><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ol><li><p>JDK和JRE的区别？<br>JDK全称Java Development Kit，包含Java运行环境（JRE）和开发环境，面向Java开发者，提供了一系列开发工具，比如 javac，需要配置环境变量；<br>JRE全称Java Runtime Enviroment，是Java运行环境，面向Java使用者，不需要配置环境变量；</p></li><li><p><code>equals()</code> 和 <code>==</code> 的区别？<br><code>==</code> 比较的是引用，即在内存空间中的存储位置是否一致；<br><code>equals()</code> 是 <code>Object</code> 类提供的方法，可以由子类重写，如何比较由开发者决定，一般比较的是内容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Object</code> 类中的 <code>equals()</code> 方法的默认实现和 <code>==</code> 等价，Java 中很多类都对 <code>equals()</code> 方法进行了重写，比如 <code>String</code>；</p></li><li><p>两个对象的 <code>hashCode()</code>相同，则 <code>equals()</code>也一定为 <code>true</code>，对吗？</p><p>理论上要求：</p><p><code>equals()</code> 返回<code>true</code>，<code>hashCode()</code> 返回值相等；<br><code>hashcode()</code> 返回值相等，<code>equals()</code> 不一定返回<code>true</code>；</p><p>实际上：</p><p><code>equals()</code>返回值相等，<code>hashCode()</code>返回值不一定相等；</p><p><code>equals()</code> 重写后，还要重写<code>hashcode()</code>，<code>hashCode()</code> 能提高哈希表的性能；</p></li><li><p><code>final</code> <code>finally</code> <code>finalize</code> 的区别？</p><p><code>final</code>:</p><p>修饰类：该类不能被继承，<code>final</code>类中所有的成员方法都会隐式的定义为<code>final</code>方法；</p><p>修饰方法：该方法不能被重写；</p><p>修饰变量：常量，只能赋值一次，不能更改；</p><p><code>finally</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>finally</code>经常被用作释放资源；</p><p><code>finalize()</code>：</p><p>这个方法在gc启动，该对象被回收的时候被调用；</p></li><li><p>Java基本数据类型？<br><code>byte</code> <code>short</code>  <code>int</code> <code>long</code> <code>double</code> <code>float</code> <code>char</code> <code>boolean</code> ；</p><p><code>Double</code> 和 <code>Float</code> 包装类没有常量池；</p></li><li><p><code>String</code> <code>StringBuffer</code> <code>StringBuilder</code> 的区别？<br><code>String</code>：字符串常量，线程安全；</p><p><code>StringBuffer</code>：字符串变量，线程安全；</p><p><code>StringBuilder</code>：字符串变量，线程不安全；</p></li><li><p>抽象类和接口的区别？</p><ul><li>默认方法实现：抽象类可以有默认方法，接口不可以（Java 8 可以）</li><li>实现：继承抽象类使用extends，实现接口使用implements</li><li>构造方法：抽象类有构造方法，接口没有构造方法</li><li>访问修饰符：抽象类有public、protected、default、private，接口只有public</li><li>main方法：抽象类有main方法，接口没有main方法</li><li>添加新方法：抽象类添加新方法不需要改变子类方法，接口需要改变子类</li></ul></li><li><p><code>switch</code> 接受数据类型</p><p><code>byte</code> <code>short</code> <code>int</code> <code>char</code> <code>String</code> <code>enum</code></p><p>不支持 <code>boolean</code> ！</p></li><li><p>空接口的作用<br>标志着Java类实现了某个特性或功能</p></li><li><p>Java 泛型<br>类型参数化，将类型转换的类型检查从运行时提前到编译时。省去了强制类型转换，提高安全性。</p></li><li><p>自动装箱和自动拆箱</p><ul><li>自动装箱：静态方法 <code>Integer.valueOf()</code></li><li>自动拆箱：实例方法 <code>i.intValue()</code></li></ul></li><li><p>异常</p><ul><li>可检查异常：编译期间能检查到的异常，需要在代码中进行捕获或抛出异常，比如 <code>IOException</code></li><li>运行时异常：只有在运行期才能知道的异常，比如空指针异常，数组越界</li><li>Error：会导致程序处于不正常状态，不需要捕获，比如 <code>OutOfMemoryError</code></li></ul></li><li><p>foreach 与 for</p><ul><li>for：遍历数组结构的数据，采用 for 更优</li><li>foreach：遍历链表结构的数据，采用 foreach 更优</li></ul></li><li><p>静态分派和动态分派</p><blockquote><p><a href="https://blog.csdn.net/sunxianghuang/article/details/52280002" target="_blank" rel="noopener">Java静态分派与动态分派</a></p></blockquote></li></ol><h2 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h2><blockquote><p><a href="https://www.cnblogs.com/yysbolg/p/9230184.html" target="_blank" rel="noopener">集合知识点</a></p></blockquote><p><img data-src="https://i.loli.net/2019/05/10/5cd4d675dfeb2.gif" alt="gif"></p><ol><li><p><code>ArrayList</code></p><ul><li>默认大小：10</li><li>扩容：原容量的1.5倍，$oldCapacity + (oldCapacity &gt;&gt; 1)$，使用<code>Arrays.copyOf()</code> 复制数组</li><li>删除元素：使用<code>System.copyOf()​</code> 复制数组</li><li><code>modCount</code>：记录 <code>ArrayList</code> 结构发生变化的次数。<code>ArrayList</code>使用<code>size</code>维护自身状态，<code>Iterator</code>使用<code>cursor</code>维护自身状态，不同步</li></ul></li><li><p><code>Vector</code></p><ul><li><p>默认大小：10</p></li><li><p>扩容：原容量的2倍</p></li></ul></li><li><p><code>CopyOnWriteArrayList</code></p><p>读写分离，写时复制，在写时允许读操作，适用于读多写少的场景；读不加锁，写加锁；不适合内存敏感以及对实时性要求很高的场景；</p></li><li><p><code>LinkedList</code></p><ul><li>默认大小：0</li></ul></li><li><p><code>ArrayList</code>和<code>LinkedList</code>的比较</p><ul><li><code>ArrayList</code>使用动态数组，<code>LinkedList</code>使用双向链表</li><li><code>ArrayList</code>支持随机访问，<code>LinkedList</code>不支持</li><li><code>ArrayList</code>插入删除耗时长，<code>LinkedList</code>能快速插入删除</li></ul></li><li><p><code>HasMap</code></p><ul><li>默认大小：16</li><li>扩容：原容量的2倍</li><li>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树</li><li>允许<code>key = null</code>，放在第0个桶内</li><li>插入元素使用头插法</li><li>遍历时顺序是随机的</li><li>非线程安全</li><li><a href="https://www.cnblogs.com/liujinhong/p/6576543.html" target="_blank" rel="noopener">hash</a></li><li><a href="https://www.cnblogs.com/qiumingcheng/p/5259892.html" target="_blank" rel="noopener">HashMap为什么线程不安全(hash碰撞与扩容导致)</a></li><li><a href="https://www.jianshu.com/p/1e9cf0ac07f4" target="_blank" rel="noopener">HashMap的死循环</a></li></ul></li><li><p><code>fail-fast</code><br>fail-fast 机制是java集合中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p></li><li><p><code>HashTable</code></p><ul><li>默认大小：11</li><li>扩容：<code>newsize = olesize*2+1</code></li><li>线程安全</li><li>不允许<code>key = null</code></li><li>迭代器是强一致性</li><li><a href="https://cloud.tencent.com/developer/article/1353456" target="_blank" rel="noopener">HashMap与Hashtable的区别是面试中经常遇到的一个问题</a></li></ul></li><li><p><code>LinkedHashMap</code></p><ul><li>保存了记录的插入顺序，遍历时是有序的</li></ul></li><li><p><code>TreeMap</code></p><ul><li>能够根据键排序，默认按照键的升序排序，遍历时是排好序的</li></ul></li><li><p><code>ConcurrentHashMap</code></p><ul><li>分段锁，初始并发 16</li><li>扩容：segment 内扩容</li><li>迭代器是弱一致性：如果已经遍历完的数据发生了变化，不会抛异常；未遍历到的数据发生了遍历，会遍历到新的数据</li></ul></li></ol><h2 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h2><blockquote><p><a href="https://blog.csdn.net/zhouxiaoyujcut/article/details/83743310" target="_blank" rel="noopener">线程池使用不当会造成内存溢出</a><br><a href="https://zhuanlan.zhihu.com/p/26724352" target="_blank" rel="noopener">Java Concurrency代码实例之一执行者与线程池</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452964569&idx=1&sn=10b22ac390594f03961cf48b72404444" target="_blank" rel="noopener">多线程面试题（一）</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452964573&idx=1&sn=6cc0042c0ad129f28a31a8ddad0bceb9" target="_blank" rel="noopener">多线程面试题（二）</a></p></blockquote><p>Java 提供了 JUC 包，包括：</p><p>执行者和线程池</p><ol><li>执行者：<code>Executor</code> 根接口、<code>ExecutorService</code>接口、<code>Executors</code> 工具类</li><li>线程池：<code>ThreadPollExecutor</code> 线程池、<code>Executors.newCachedThreadPool()</code> 线程池、<code>Executors.newFixedThreadPool(int)</code> 线程池、<code>Executors.newSingleThreadPool(int)</code> 线程池</li><li>异步值：<code>Future</code> 接口、<code>FutureTask</code></li><li><code>ForkJoin</code>：<code>ForkJoinPool</code>、<code>RecursiveAction</code>、<code>RecursiveTask</code></li></ol><p>阻塞队列</p><ol><li>LinkedBlockingQueue：链表实现，不可实现公平策略</li><li>ArrayedBlockingQueue：数组实现，实现公平策略</li><li>SynchronousQueue：支持公平策略</li><li>PriorityBlockingQueue</li><li>DelayQueue</li><li>BlockingDeque</li><li>ConcurrentLinkedQueue</li><li>ConcurrentLinkedDeque</li></ol><p>同步工具</p><ol><li><p>CountdownLatch</p></li><li><p>Semaphore</p></li><li><p>CyclicBarrier</p></li><li><p>Exchange</p></li></ol><p>并发集合</p><ol><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li><li>CopyOnWriteArrayList</li></ol><p>锁</p><ol><li><p><code>LockSupport</code>：能够实现线程的阻塞和唤醒，不需要放在同步代码块中；<code>unpark()</code> 可以优先于<code>park()</code> 调用</p></li><li><p><code>AQS</code>：一个状态值<code>state</code>、阻塞和唤醒线程的能力<code>LockSupport</code>、阻塞队列</p></li><li><p>RentrantLock</p></li><li><p>Condition</p></li><li><p>ReentrantWriteReadLock</p></li></ol><p>原子变量</p><ol><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicBoolean</li><li>AtomicReference</li><li>AtomicStampedReference</li><li>AtomicMarkableReference</li></ol><h3 id="synchronized-volatile"><a href="#synchronized-volatile" class="headerlink" title="synchronized volatile"></a>synchronized volatile</h3><ul><li><p>synchronized：保证原子性和可见性，不会限制指令重排</p></li><li><p>volatile：保证可见性和有序性，无法保证原子性。Volatile 可用于提供线程安全，但具有使用条件：多个变量之间或某个变量的当前值与修改后的值没有约束。Volatile 用于多线程环境下的单次操作（单次读或单次写）。Volatile 的写操作不能依赖于当前值，读操作不能依赖于其他变量</p><blockquote><p><a href="https://blog.csdn.net/vking_wang/article/details/9982709#" target="_blank" rel="noopener">volatile的适用场景</a></p></blockquote><ul><li>状态标记</li><li>一次性安全发布</li><li>volatile bean 模式</li><li>开销较低的“读写锁”</li></ul></li></ul><p>双重检查单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singletin</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>synchronized：保证执行原子性</li><li>volatile：保证有序性</li></ul><p>如果不加 volatile 无法保证有序性，<code>instance = new Singleton()</code> 可能出现先创建引用再创建对象的情况，此时会出现一个问题：instance 不为 null ，但对象并没有创建万；使用 volatile ，可以保证有序性，保证先创建对象再进行引用赋值</p><h3 id="Java-线程状态转换"><a href="#Java-线程状态转换" class="headerlink" title="Java 线程状态转换"></a>Java 线程状态转换</h3><ul><li>创建</li><li>就绪：<code>Thread.start()</code> 会创建线程，并进入就绪状态等待运行</li><li>运行</li><li>阻塞<ul><li>同步阻塞：<code>synchronized</code></li><li>限期等待：<code>Thread.sleep()</code></li><li>无限期等待：<code>Obiect.wait()</code></li></ul></li><li>终止</li></ul><h3 id="wait-sleep-yield"><a href="#wait-sleep-yield" class="headerlink" title="wait sleep yield"></a>wait sleep yield</h3><ul><li><code>wait()</code>：Object 实例方法，线程会释放锁，线程状态由运行状态变为无限期等待状态</li><li><code>sleep()</code>：Thread 静态方法，线程不会释放锁，线程由运行状态变为限期等待状态</li><li><code>yield()</code>：Thread 静态方法，线程不会释放锁，线程由运行状态变为就绪状态</li></ul><h3 id="多线程优点"><a href="#多线程优点" class="headerlink" title="多线程优点"></a>多线程优点</h3><ul><li>提高应用程序并发度和吞吐量，提高 CPU 利用率</li><li>能够充分利用多核 CPU 或多个 CPU</li><li>线程不仅有 CPU 计算时间，还有 IO 读取时间等。对于单核 CPU 来说，当一个线程等待 IO 到达而被阻塞时，可以执行其他线程，从而提高 CPU 利用率</li></ul><h3 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h3><ul><li><p><code>Executors.newCachedThreadPool()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心线程数为 0，最大线程数为 <code>Integer.MAX_VALUE</code>，空闲线程存活时间为 60s ，当线程数超过核心线程数时使用同步队列保存任务。</p><p>由于使用同步队列，如果想将一个元素放入<code>SynchronousQueue</code>，必须至少一个在等待接受这个元素。所以对于缓存线程池，来一个任务，如果有空闲线程会将任务交由空闲线程处理；如果没有空闲线程，再创建一个新的线程处理。</p><p><code>SynchronousQueue</code>的最大线程数是<code>Integer.MAX_VALUE</code>，对于高并发任务，同时创建多个线程很有可能造成内存溢出甚至宕机。</p></li><li><p><code>Executors.newFixedThreadPool(int)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>核心线程数和最大线程数都是 <code>nThreads</code>，当任务数超过线程数时使用<code>LinkedBlockingQueue</code>。由于<code>LinkedBlockingQueue</code>最大值是<code>Integer.MAX_VALUE</code>，当高并发场景很可能队列太大导致内存溢出。</p></li><li><p><code>Executors.newSingleThreadExecutor()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同上，单线程能保证任务有序执行。也会存在内存溢出的风险。</p></li></ul><p>由于以上三种线程池在高并发任务中都存在内存溢出的风险，可以使用自己实现的线程池。选择有界队列如<code>ArrayBlockingQueue</code>，并且采取适当的饱和策略，JDK 提供了 4 种饱和策略：</p><ul><li>终止策略：抛异常</li><li>抛弃策略：抛弃任务</li><li>抛弃旧任务策略：抛弃任务</li><li>调用者策略：不抛异常也不抛弃任务，而是将任务交由主线程执行</li></ul><p><code>LinkedBlockingQueue</code> 也是有界队列，默认值为 <code>Integer.MAX_VALUE</code>，也可以自己设定值</p><h3 id="submit-execute"><a href="#submit-execute" class="headerlink" title="submit execute"></a>submit execute</h3><ul><li>submit 提交 callable 方法，有返回值</li><li>execute 提交 runnable 方法，无返回值</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><blockquote><p><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java并发编程：深入剖析ThreadLocal</a></p><p><a href="https://www.jianshu.com/p/a1cd61fa22da" target="_blank" rel="noopener">ThreadLocal内存泄漏真因探究</a></p></blockquote><p>每个 Thread 都有 threadlocals 成员变量，其类型是<code>ThreadLocal.ThreadLocalMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>当调用 <code>ThreadLocal</code> 类的 <code>get()</code> 和 <code>set()</code> 方法时，实际上是拿到 thread 类的 threadLocals 变量。</p><p>ThreadLocal 的应用场景：</p><ul><li>数据库连接</li><li>Session 管理</li><li>Web 请求</li><li>…</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP</title>
      <link href="/2019/03/14/00010/"/>
      <url>/2019/03/14/00010/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/mi1wGkcjYCalJFd.jpg" alt="AdelieBreeding_ZH-CN1750945258_1920x1080.jpg"></p><a id="more"></a><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lndh36zwj20z60ml0yh.jpg" alt="tcp"></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p>三次握手的原因</p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lndebpl1j20py0hy0vr.jpg" alt="tcp"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p>四次挥手的原因</p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p>TIME_WAIT</p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="noopener">计算机网络-传输层</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发解决方案</title>
      <link href="/2019/03/13/00009/"/>
      <url>/2019/03/13/00009/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/OFXLG59V17RyCY4.jpg" alt="bing"></p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p> 吞吐量是指系统在单位时间内处理请求的数量</p><h3 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h3><p>每秒查询率</p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>响应时间是指系统对请求作出响应的时间</p><h3 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h3><p>并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量</p><h2 id="为什么需要高并发"><a href="#为什么需要高并发" class="headerlink" title="为什么需要高并发"></a>为什么需要高并发</h2><ol><li>业务需求，比如秒杀购物；</li><li>性能需求；</li><li>可简化任务调度，任务调度是指基于给定时间点，给定时间间隔或给定执行次数自动执行任务；</li><li>并行程序在多核CPU有优势：</li></ol><h2 id="高并发带来的问题"><a href="#高并发带来的问题" class="headerlink" title="高并发带来的问题"></a>高并发带来的问题</h2><h3 id="事务隔离级别带来的并发问题"><a href="#事务隔离级别带来的并发问题" class="headerlink" title="事务隔离级别带来的并发问题"></a>事务隔离级别带来的并发问题</h3><ol><li><p>脏读<br>事务T1修改一个数据，T2读取该数据后事务T1回滚，T2读取到的就是脏数据</p><p><img data-src="https://i.loli.net/2019/04/26/5cc26ee0d976e.png" alt="pic"></p></li><li><p>不可重复读<br>事务T1和T2读取一个数据，事务T1修改数据后事务T2再次读取该数据，导致两次读取不一致</p><p><img data-src="https://i.loli.net/2019/04/26/5cc26ee0bf37c.png" alt="pic"></p></li><li><p>幻读<br>事务T1读取数据，事务T2修改数据后事务T1再次读取该数据，导致前后读取不一致</p><p><img data-src="https://i.loli.net/2019/04/26/5cc26ee0db484.png" alt="pic"></p></li></ol><p>事务的隔离级别(√表示存在问题，×表示不存在问题)</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">read committed (oracle)</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">repeatable read (mysql)</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="高并发问题解决方案"><a href="#高并发问题解决方案" class="headerlink" title="高并发问题解决方案"></a>高并发问题解决方案</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>在数据处理过程中，数据处于锁定状态。悲观锁的实现往往需要依靠数据库提供的锁机制。</p><p>mysql 中提供了行级锁和表级锁两种封锁粒度。锁定的数据越少并发性越高，但是锁操作需要消耗资源，封锁粒度越小开销越大。</p><p>mysql 中有读写锁和意向锁。当使用读写锁时，事务T想对表A加表级锁，就需要检查是否有其他事务对表A加了表级锁或对表A的某行加了行级锁，那么就需要对表A的每一行都检查，这是非常耗时的。使用意向锁可以更容易地支持多粒度加锁。</p><p>意向锁在原来的排它锁和共享锁之上引入了意向排它锁和意向共享锁，意向排它锁和意向共享锁都是表锁，用来表示一个事务想要在表中的某个数据行上加排它锁或共享锁。有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了排它锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了共享锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加共享锁，但是不能加排它锁。</li></ul><table><thead><tr><th align="center"></th><th align="center">排它锁</th><th align="center">意向排它锁</th><th align="center">共享锁</th><th align="center">意向共享锁</th></tr></thead><tbody><tr><td align="center">排它锁</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">意向排它锁</td><td align="center">×</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">共享锁</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">意向共享锁</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure><p>上述方式对行加共享锁，对表加意向共享锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE</span><br></pre></td></tr></table></figure><p>上述方式对行加排它锁，对表加意向排它锁</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁，大多是基于数据版本 Version 记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时对此版本号加1。此时将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号则予以更新，否则认为是过期数据。</p><p>如果需要非常高的访问速度，建议使用乐观锁；如果冲突严重，建议使用悲观锁；如果重试的代价比较大，建议使用悲观锁</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Compare And Swap，是一种实现并发算法时常用到的技术</p><p>CAS 有3个操作数：</p><ul><li>内存地址V</li><li>旧的预期值A</li><li>新的目标值B</li></ul><p>只有当地址指向的值等于旧值时，才进行更新，否则说明其他线程对改值进行了更改</p><p>缺点：</p><ul><li>循环时间长开销很大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题</li></ul><blockquote><p><a href="https://blog.csdn.net/v123411739/article/details/79561458" target="_blank" rel="noopener">面试必问的CAS，你懂了吗？</a></p></blockquote><h3 id="Java-分段锁"><a href="#Java-分段锁" class="headerlink" title="Java 分段锁"></a>Java 分段锁</h3><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>在高并发环境下，可以使用消息队列异步处理请求，从而缓解系统的压力。</p><ol><li><p>解耦</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lnl1r4ndj20dl0a7t9a.jpg" alt="o_jieou6.png"></p></li><li><p>异步<br><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lnl4eoyvj20if0dwgme.jpg" alt="o_yibu3.png"></p></li><li><p>削峰</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2lnl97ybdj20hp09fwf3.jpg" alt="o_xuefeng2.png"></p></li></ol><h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>缓存数据是为了让客户端很少甚至不访问数据库服务器进行数据的查询，在高并发下能最大程度的降低对数据库服务器的访问压力。</p><h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>CDN的全称是Content Delivery Network，即内容分发网络，尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络。CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡服务器使用负载均衡算法将请求转发到集群中不同的主服务器。</p><h3 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h3><ol><li>单线程，利用redis队列技术并将访问变为串行访问，消除了传统数据库串行控制的开销</li><li>redis具有快速和持久化的特征，速度快，因为数据存在内存中</li><li>分布式 读写分离模式</li><li>支持丰富数据类型</li><li>支持事务，操作都是原子性，所谓原子性就是对数据的更改要么全部执行，要不全部不执行</li><li>可用于缓存，消息，按key设置过期时间，过期后自动删除</li></ol><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>; <span class="comment">// 保证互斥性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;  <span class="comment">// 保证不会发生死锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁，唯一key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识，保证解铃还须系铃人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间，保证不会发生死锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); <span class="comment">// jedis.eval() 保证执行的原子性</span></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul><li>计数器<ul><li>使用计数器限制一秒内能够通过的请求数，到达阈值后拒绝其他请求，一秒结束后再重新计数</li><li>缺点：如果请求集中在前几毫秒，之后将无法响应请求，这种现象称为“突刺现象”</li></ul></li><li>漏桶算法<ul><li>类比：相当于睡倒入漏斗，不管倒入多少水，下边流出的速度始终保持不变</li><li>可以维护一个消息队列，将请求放入消息队列，然后通过一个线程池定期的从消息队列中读取请求。当桶达到最大容量时，拒绝请求</li><li>缺点：无法处理突发流量并响应时间要求比较短的场景</li></ul></li><li>令牌桶算法<ul><li>令牌桶能限制平均请求速度的同时允许一定程度的突发请求</li><li>使用一个桶存放固定数量的令牌，算法以一定的速率向桶中存放令牌，存放令牌持续不断的进行，当桶满时丢弃令牌。每次请求需要先获取令牌，拿到令牌才能执行，否则等待或拒绝请求</li><li>令牌桶算法运行一定程度的突发请求，比如桶初始化时允许存放100个令牌，那么这时运行100个请求同时调用</li></ul></li></ul><p>限流不仅可以限制请求数，还可以限制单个用户的上传下载的速度。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也可以随机服务。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/数据库系统原理" target="_blank" rel="noopener">数据库系统原理</a></li><li><a href="https://www.cnblogs.com/lr393993507/p/5909804.html" target="_blank" rel="noopener">Java高并发，如何解决，什么方式解决</a></li><li><a href="https://mp.weixin.qq.com/s?src=11×tamp=1552709589&ver=1487&signature=0eLqftWY0AoQtBwYTmIrhJce4U4N77drv3QPFqaDf*Ec9qFBzZXpUmoM8mGOa4Ktn0TaQchdegiA6N1r4F2vnMrF2vyEmkGffhyOBbLW0g-o0*2mHQS-OwT2*ujOsG22&new=1" target="_blank" rel="noopener">别吵吵，分布式锁也是锁</a></li><li><a href="https://www.cnblogs.com/linjiqin/p/8003838.html" target="_blank" rel="noopener">Redis分布式锁的正确实现方式</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性判别分析</title>
      <link href="/2019/03/05/00008/"/>
      <url>/2019/03/05/00008/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/z8UcBI6ukpTaJyr.jpg" alt="ReindeerNorway_ZH-CN5913190372_1920x1080.jpg"></p><a id="more"></a><blockquote><p>线性判别分析（LDA）是一种有监督的数据降维方法。</p></blockquote><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p>投影后类内方差最小，类间方差最大。<br><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g2lodbhuxsj20qr0acjs3.jpg" alt="pic"></p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><table><thead><tr><th>LDA算法</th></tr></thead><tbody><tr><td>输入：$D={(x_1,y_1), (x_2,y_2), …,((x_m,y_m))}, x_i \in R^n, y_i \in {C_1,C_2,…,C_k} $</td></tr><tr><td>输出：$D, x_i \in R^d, y_i \in {C_1,C_2,…,C_k}$</td></tr><tr><td>1.计算类内散度矩阵$S_w =  \sum\limits_{i=1}^{k}S_{w_i} = \sum\limits_{i=1}^{k}\sum\limits_{x \in X_i}(x-\mu_i)(x-\mu_i)^T$</td></tr><tr><td>2.计算类间散度矩阵$S_b = \sum\limits_{i=1}^{k}m_i(\mu_i-\mu)(\mu_i-\mu)^T,m_i$表示第$i$类示例数</td></tr><tr><td>3.计算$S_w^{-1}S_b$</td></tr><tr><td>4.计算$S_w^{-1}S_b$最大的$d$个特征值和对应的特征向量$(w_1,w_2,…,w_d)$，得到投影矩阵$W$</td></tr><tr><td>5.对样本集中的每一个样本特征$x_i$,转化为新的样本$z_i=W^Tx_i$</td></tr><tr><td>6.得到输出样本集$D’={(z_1,y_1), (z_2,y_2), …,((z_m,y_m))}$</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.cnblogs.com/pinard/p/6244265.html" target="_blank" rel="noopener">线性判别分析LDA原理总结</a></li><li><a href="http://sebastianraschka.com/Articles/2014_python_lda.html" target="_blank" rel="noopener">Linear Discriminant Analysis</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convolutional Sequence to Sequence Learning</title>
      <link href="/2019/02/14/00007/"/>
      <url>/2019/02/14/00007/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/r2exHfqLnpkTWFX.jpg" alt="BerlinerMauerFall_ZH-CN1154604596_1920x1080.jpg"></p><a id="more"></a><blockquote><p>Convolutional Sequence to Sequence Learning 是 Facebook 在 2017 年发表的论文，提出 ConvS2S 模型。Seq2Seq 模型在自然语言处理、计算机视觉、语音识别等领域都有非常广泛的应用。Seq2Seq模型是Encoder-Decoder结构，当应用在 NLP 领域时，它的编码器和解码器通常都都选择 RNN/ LSTM / GRU / SRU 网络。而这篇论文摒弃了RNN网络，而是使用 CNN 来做 Seq2Seq 任务，并且在机器翻译任务上取得了非常不错的结果。</p></blockquote><h2 id="Neural-history-of-NLP"><a href="#Neural-history-of-NLP" class="headerlink" title="Neural history of NLP"></a>Neural history of NLP</h2><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g06be441k4j20sg0e8t9l.jpg" alt="发展"></p><p>下面我来介绍一下使用神经网路来做 NLP 的发展史：</p><ul><li><p>2001 - Neural language models</p><p>2001年，Bengio 提出神经概率语言模型（NPLM）模型用于语言建模任务。语言建模任务指的是给定上下文单词去预测当前单词，NPLM 模型使用前馈神经网络来根据上下文信息预测当前词出现的概率<br>$$<br>i-th , output = P(w_i = i | context)<br>$$</p><blockquote><p><a href="https://papers.nips.cc/paper/1839-a-neural-probabilistic-language-model.pdf" target="_blank" rel="noopener">A Neural Probabilistic Language Model-2001</a></p><p><a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="noopener">A Neural Probabilistic Language Model-2003</a></p></blockquote></li><li><p>2008 - Multi-task learning</p><p>2008年，Collobert 和 Weston 首次将多任务学习应用到 NLP 领域。多任务学习（Multi-task learning）是基于共享表示，把多个相关的任务放在一起学习的一种机器学习方法</p><blockquote><p><a href="https://ronan.collobert.com/pub/matos/2008_nlp_icml.pdf" target="_blank" rel="noopener">A Unified Architecture for Natural Language Processing:Deep Neural Networks with Multitask Learning-2008</a></p><p><a href="http://www.jmlr.org/papers/volume12/collobert11a/collobert11a.pdf" target="_blank" rel="noopener">Natural Language Processing (Almost) from Scratch-2011</a></p></blockquote></li><li><p>2013 - Word embeddings</p><p>2013年，Mikolov 等人提出 Word2Vec 模型来构建词嵌入表示。以往的文本表示都是基于 one-hot 这类的稀疏向量，具有高维稀疏、无法学习词之间的信息等问题，而 Word2Vec 是密集向量并且能够学习到词之间的相似性</p><blockquote><p><a href="https://arxiv.org/pdf/1301.3781.pdf" target="_blank" rel="noopener">Efficient Estimation of Word Representations in Vector Space-2013-Word2Vec</a></p><p><a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf" target="_blank" rel="noopener">Distributed Representations of Words and Phrases and their Compositionality-2013-Word2Vec</a></p><p><a href="https://nlp.stanford.edu/pubs/glove.pdf" target="_blank" rel="noopener">GloVe: Global Vectors for Word Representation-2014-GloVe</a></p><p><a href="https://arxiv.org/pdf/1506.02761.pdf" target="_blank" rel="noopener">WordRank: Learning Word Embeddings via Robust Ranking-2015-WordRank</a></p><p><a href="https://arxiv.org/pdf/1607.01759.pdf" target="_blank" rel="noopener">Bag of Tricks for Efficient Text Classification-2016-FastText</a></p></blockquote></li><li><p>2013 - Neural networks for NLP</p><p>2013 年后，大量的深度学习模型开始应用到 NLP 领域，使用最广泛的神经网络是RNN、CNN、层次网络、递归神经网络</p><blockquote><p><a href="https://arxiv.org/pdf/1404.2188.pdf" target="_blank" rel="noopener">A Convolutional Neural Network for Modelling Sentences-2014</a></p><p><a href="https://arxiv.org/pdf/1408.5882.pdf" target="_blank" rel="noopener">Convolutional Neural Networks for Sentence Classification-2014</a></p><p><a href="https://arxiv.org/pdf/1610.10099.pdf" target="_blank" rel="noopener">Neural Machine Translation in Linear Time-2016</a></p><p><a href="http://anthology.aclweb.org/P16-2037" target="_blank" rel="noopener">Dimensional Sentiment Analysis Using a Regional CNN-LSTM Model-2016</a></p></blockquote></li><li><p>2014 - Sequence to Sequence models<br>2014 年，Sutskever 等人提出了 Seq2Seq 模型。Seq2Seq 模型属于编码器-解码器结构，在自然语言处理、计算机视觉、语音识别等领域都有非常广泛的应用</p><blockquote><p><a href="https://arxiv.org/pdf/1406.1078.pdf" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation-2014</a></p><p><a href="https://arxiv.org/pdf/1409.3215.pdf" target="_blank" rel="noopener">Sequence to sequence learning with neural networks-2014</a></p></blockquote></li><li><p>2015 - Attention</p><p>Attention 机制从大量信息中有选择地筛选出少量重要信息并聚焦到这些重要信息上，忽略大多不重要的信息。Attention 机制最早是20世纪90年代，在图像领域提出的一种思想。真正让 Attention 机制火起来的是 Google 在2014年发表的一篇文章《<a href="https://arxiv.org/pdf/1406.6247.pdf" target="_blank" rel="noopener">Recurrent Models of Visual Attention</a>》，在RNN模型基础上加入 Attention 机制来对图像进行分类，使用强化学习机制进行训练。2015年，Bahdanau等人在 Seq2Seq 模型中加入Attention 机制用于机器翻译，这是第一篇将 Attention 机制应用到自然语言处理领域的文章。随后，Attention 机制被广泛应用于自然语言处理、计算机视觉和语音识别等各种不同类型的深度学习任务中，成为了深度学习中非常值得关注与了解的核心技术，也成为了深度学习中非常重要的思想之一</p><blockquote><p><a href="https://arxiv.org/pdf/1406.6247.pdf" target="_blank" rel="noopener">Recurrent Models of Visual Attention-2014</a></p><p><a href="https://arxiv.org/pdf/1409.0473.pdf" target="_blank" rel="noopener">Neural Machine Translation by Jointly Learning to Align and Translate-2015</a></p><p><a href="https://arxiv.org/pdf/1508.04025.pdf" target="_blank" rel="noopener">Effective Approaches to Attention-based Neural Machine Translation-2015</a></p><p><a href="https://arxiv.org/pdf/1512.05193.pdf" target="_blank" rel="noopener">ABCNN: Attention-Based Convolutional Neural Network for Modeling Sentence Pairs-2015</a></p><p><a href="https://arxiv.org/pdf/1705.03122.pdf" target="_blank" rel="noopener">Convolutional Sequence to Sequence Learning-2017</a></p><p><a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need-2017</a></p></blockquote></li><li><p>2015 - Memory-based networks</p><p>记忆网络是在神经网络的基础上引入记忆单元，用来存储长期记忆。记忆单元可以是向量、矩阵或多个矩阵</p><blockquote><p><a href="https://arxiv.org/pdf/1410.5401.pdf" target="_blank" rel="noopener">Neural turing machines-2015</a></p><p><a href="https://arxiv.org/pdf/1410.3916.pdf" target="_blank" rel="noopener">Memory Networks-2015</a></p><p><a href="https://arxiv.org/pdf/1503.08895.pdf" target="_blank" rel="noopener">End-To-End Memory Networks-2015</a></p><p><a href="https://arxiv.org/pdf/1506.07285.pdf" target="_blank" rel="noopener">Ask me anything: Dynamic memory networks for natural language processing-2015</a></p><p><a href="https://arxiv.org/pdf/1603.01417.pdf" target="_blank" rel="noopener">Dynamic Memory Networks for Visual and Textual Question Answering-2016</a></p><p><a href="https://www.nature.com/articles/nature20101" target="_blank" rel="noopener">Hybrid computing using a neural network with dynamic external memory-2016</a></p><p><a href="https://arxiv.org/pdf/1612.03969.pdf" target="_blank" rel="noopener">Tracking the World State with Recurrent Entity Networks-2017</a></p></blockquote></li><li><p>2018 - Pretrained language models</p><p>预训练语言模型是指利用大规模数据集预训练模型进行迁移学习。一方面可以更好的初始化网络参数，另一方面可以加快模型收敛，并且能够取得更好的效果。词嵌入可以认为仅用于初始化模型中的第一层，而预训练语言模型是预训练多层神经网络</p><blockquote><p><a href="https://arxiv.org/pdf/1802.05365.pdf" target="_blank" rel="noopener">Deep Contextualized Word Representations-2018-ELMO</a></p><p><a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf" target="_blank" rel="noopener">Improving Language Understanding by Generative Pre-Training-2018-GPT</a></p><p><a href="https://arxiv.org/pdf/1810.04805.pdf" target="_blank" rel="noopener">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding-2018-BERT</a></p></blockquote></li></ul><h2 id="Seq2Seq-Attention"><a href="#Seq2Seq-Attention" class="headerlink" title="Seq2Seq + Attention"></a>Seq2Seq + Attention</h2><h3 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h3><p>以 Seq2Seq 模型应用到邮件回复系统为例，Encoder 和 Decoder 使用的都是 LSTM。当发送“ Are you free tommorws? ”时，得到自动回复“ Yes, what’s up? ”。首先看 Encoder 部分，在每一时刻 i ，Encoder 接收一个单词，i 时刻隐藏层的计算公式为：<br>$$<br>h_i = RNN(h_{i-1},x_i)<br>$$<br>直到计算完最后一个单词 ，得到输入的隐藏向量 C 作为 Decoder 的初始状态。Decoder 在 i 时刻的输出的计算公式为：<br>$$<br>y_i = RNN(h_{i-1},y_{i-1})<br>$$<br>其实 Seq2Seq 模型是比较灵活的，刚刚讲的只是其中一种。还有另一种变体，随机初始化 / 全零初始化 Decoder 的初始状态，然后将编码器得到的隐藏向量 C 和 上一时刻的输出一起输入到解码器中：<br>$$<br>y_i = RNN(h_{i-1},y_{i-1},C)<br>$$</p><h3 id="Seq2Seq-Attention-1"><a href="#Seq2Seq-Attention-1" class="headerlink" title="Seq2Seq+Attention"></a>Seq2Seq+Attention</h3><p>Seq2Seq 模型 Encoder 最终输出向量 C 作为输入句子的特征表示，这里 C 是固定的。当引入 Attention 机制后， C ，Decoder 不同的词对应不同的 C 。</p><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g2lorui2j8j20yr0rn40h.jpg" alt="test.jpg"></p><p><img data-src="https://camo.githubusercontent.com/a3c087bfca2eb44553f284ac13b19ccc27a333ed/68747470733a2f2f332e62702e626c6f6773706f742e636f6d2f2d3350626a5f64767430566f2f562d71652d4e6c365035492f41414141414141414251632f7a305f365774565774764152744d6b3069395f41744c6579794779563641493477434c63422f73313630302f6e6d742d6d6f64656c2d666173742e676966" alt="pic"></p><p>基于RNN的 Seq2Seq + Attention 模型在做什么：</p><ul><li><p>Encoder：学习各个词的隐藏表示</p></li><li><p>Attention：根据 Decoder 上一时刻隐藏状态和 Encoder 各个词的隐藏表示计算 Attention 向量</p></li><li><p>Decoder：根据 Decoder 上一时刻隐藏状态和 Attention 向量学习 Decoder 当前时刻的隐藏表示</p></li><li><p>Softmax：生成词分布，获得概率最大值</p></li><li><p>Encoder 学习输入数据中各个词的隐藏表示，并且每个词的隐藏表示包含上下文信息，甚至包含整个输入数据和当前词之间的信息<br>$$<br>z_i = RNN(z_{i-1}, x_i) \<br>$$</p></li><li><p>当计算 Decoder 第 i 时刻的输出时，Attention 学习 i-1 时刻隐藏状态 / 上下文信息和 Encoder 的各个词的权重<br>$$<br>a_{ij} = \frac{exp(a(s_{i-1},z_j))}{\sum^{T}<em>{k=1}exp(a(s</em>{i-1},z_k))} \<br>C_i = \sum^{T}<em>{j=1}a</em>{ij}s_j<br>$$</p></li><li><p>Decoder 根据上一时刻的隐藏表示和当前时刻的 Attention 向量来生成当前词的隐藏表示，并且每个生成词的隐藏表示包含上文信息，甚至包含上文全部信息<br>$$<br>y_i = RNN(h_{i-1},C_i)<br>$$<br>最后经过 softmax 层输出生成词</p></li></ul><p>基于RNN的 Seq2Seq + Attention 模型的缺点：</p><ul><li><p>无法并行计算</p></li><li><p>存在长期依赖问题<br>$$<br>P(S_{t+1}|S_t) = P(S_{t+1}|S_1,…,S_t)<br>$$</p></li><li><p>不能很好处理句子结构化信息</p></li><li><p>不平衡</p></li><li><p>一错到底</p></li><li><p>RNN无法并行计算：RNN网络依赖前一时刻的输出</p></li><li><p>RNN存在长期依赖问题：本质上是马尔科夫决策过程，具有马尔科夫性：<br>$$<br>P(S_{t+1}|S_t) = P(S_{t+1}|S_1,…,S_t)<br>$$<br>其中状态 $S_t$ 包含了所有历史相关信息</p></li><li><p>RNN并不能很好的处理句子中的结构化信息：RNN能够很好地学习序列信息，但不能很好地学习词之间的信息、语义信息或者更复杂的信息</p></li><li><p>RNN序列中的第一个元素会进行N次非线性运算，而最后一个元素仅进行1次非线性运算；RNN学习到的隐藏表示是不平衡的，第一个隐藏表示只包含当前词的信息，而最后一个隐藏表示包含所有词的信息</p></li></ul><h2 id="ConvS2S"><a href="#ConvS2S" class="headerlink" title="ConvS2S"></a>ConvS2S</h2><p><img data-src="https://i.loli.net/2018/12/16/5c165b277a9ec.png" alt="convs2s.png"></p><h3 id="Position-Embedding"><a href="#Position-Embedding" class="headerlink" title="Position Embedding"></a>Position Embedding</h3><ol><li><p>Data preprocessing</p><p>在 NLP 中数据通常是不定长的，而CNN / RNN 网络要求输入定长数据，所以第一步要做的是数据预处理，将不定长数据转化为定长数据。转化的方法有两种：第一种是填充，第二种是切割，最后得到长度为 m 的输入序列：<br>$$<br>x = (x_i,…,x_m)<br>$$<br>得到定长数据之后，需要建立字典，将词和 one-hot 建立映射关系。</p></li><li><p>Word embedding</p><p>使用Word2Vec、Glove、FastText、WordRank等任意一个 word embedding 模型，将 one-hot 向量转化成连续向量，得 ：<br>$$<br>w = (w_i,…,w_m), w_i \in R^d<br>$$</p></li><li><p>Position embedding</p><p>对于时间序列来说，尤其是对于NLP中的任务来说，顺序是很重要的信息，它代表着局部甚至是全局的结构，学习不到顺序信息，那么效果将会大打折扣。RNN 擅长处理时序问题，时序问题强调时间的先后顺序，时序问题可以不严格等价于位置问题，先发生的位置在前，后发生的位置在后；CNN 可以使用滑动窗口来捕捉位置信息，只不过在处理时序任务上，CNN 并没有 RNN 那么擅长，所以引入 Position embedding 的目的就是为了让词包含位置信息，从而使 CNN 更好地处理时序任务：<br>$$<br>p = (p_i,…,p_m), p_i \in R^d<br>$$<br>Word embedding 是相对于 Word 而言的，Position embedding 是相对于 Position 而言的。什么是位置信息呢？举个例子，“ I love China ”这句话包含3个单词，“I”的位置是1，“love”的位置是2，“China”的位置是3，那么1,2,3就是位置信息。但是直接使用整数来表示位置信息无法应用到神经网络中，通常会将数字映射成 one-hot 向量，比如1映射成(1,0,0)，2映射成(0,1,0)，以此类推。但 one-hot 向量是高维稀疏的，所以通常会将 one-hot 向量转化为类似于 word embedding 的密集连续向量。</p><ul><li><p>一种方式是将 one-hot / 数字输入到 embedding 层得到连续向量<br>$$<br>\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{pmatrix}<br>\begin{pmatrix}w_{11} &amp; w_{12} &amp; w_{13}\<br>w_{21} &amp; w_{22} &amp; w_{23}\<br>w_{31} &amp; w_{32} &amp; w_{33}\<br>w_{41} &amp; w_{42} &amp; w_{43}\<br>w_{51} &amp; w_{52} &amp; w_{53}\<br>w_{61} &amp; w_{62} &amp; w_{63}\end{pmatrix}<br>=\begin{pmatrix}w_{11} &amp; w_{12} &amp; w_{13}\<br>w_{21} &amp; w_{22} &amp; w_{23}\end{pmatrix}<br>$$<br>假设句子的长度是6，Position embedding 的维度是3，最终 embedding 层可以得到长度为 m 的句子的 Position embedding。</p></li><li><p>另一种方式是使用公式计算<br>$$<br>PE_{\left ( pos,2i \right )}=sin\left ( \frac{pos}{1000^{2i/d}} \right ) \<br>PE_{\left ( pos,2i+1 \right )}=cos\left ( \frac{pos}{1000^{2i/d}} \right )<br>$$<br>其中，pos表示位置，i 表示维度，d 表示 Position Embedding 的维度。生成位置向量中偶数部分的值使用第一个公式，生成位置向量中奇数部分的值使用第二个公式。</p><p>比如英语句子“Tom chase jerry”，我们想把 Tom 映射为3维的位置向量，那么pos=1,d=3，而位置向量的每个值为：<br>$$<br>PE_{\left ( 1,0 \right )}=sin\left ( \frac{1}{1000^{0/3}} \right )<br>$$</p><p>$$<br>PE_{\left ( 1,1 \right )}=cos\left ( \frac{1}{1000^{0/3}} \right )<br>$$</p><p>$$<br>PE_{\left ( 1,2 \right )}=sin\left ( \frac{1}{1000^{2/3}} \right )<br>$$</p><p>Position Embedding本身是一个绝对位置的信息，但在语言中相对位置也很重要，Google选择前述的位置向量公式的一个重要原因是：<br>$$<br>sin(α+β)=sinαcosβ+cosαsinβ \<br>cos(α+β)=cosαcosβ−sinαsinβ<br>$$<br>这表明位置 p+k 的向量可以表示成位置 p 的向量的线性变换，这提供了表达相对位置信息的可能性。</p></li></ul></li><li><p>Element represention</p><p>结合位置向量和词向量有几个可选方案，可以把它们拼接起来作为一个新向量，也可以把位置向量定义为跟词向量一样大小，然后两者加起来。Facebook 选择的是前者：<br>$$<br>e=(w_1+p_1,…,w_m+p_m),e_i \in R^d<br>$$</p></li></ol><p>同理，对解码器的输入也使用 Word embedding + Position embedding ，得：<br>$$<br>g = (g_1,…,g_n)<br>$$<br>下图是在 WMT’14 English-German 数据集上做的实验，PPL表示困惑度，越小越好；BLEU越大越好。从表中可以看出，加入 Position embedding 之后，可以或多或少的提高模型的效果。即使不加 Position embedding ，ConvS2S 模型也能取得不错的效果，原因是 CNN 网络本身就能利用位置信息。</p><p><img data-src="https://i.loli.net/2018/12/16/5c165b2729e90.png" alt="convtable4.png"></p><h3 id="Convolutional-Block-Structure"><a href="#Convolutional-Block-Structure" class="headerlink" title="Convolutional Block Structure"></a>Convolutional Block Structure</h3><p>Encoder 第 l block 的输出为：<br>$$<br>z^l = (z_1^l,…,z_m^l)<br>$$<br>Decoder 第 l block 的输出为：<br>$$<br>h_l = (h_1^l,…,h_n^l)<br>$$</p><ol><li><p>Gated Convolutional Networks</p><blockquote><p><a href="https://arxiv.org/pdf/1612.08083.pdf" target="_blank" rel="noopener">Language Modeling with Gated Convolutional Networks</a></p></blockquote><p>门卷积借鉴了LSTM中门的思想，首先回顾一下LSTM</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g06bhqpse2j21q10nbqam.jpg" alt="pic"><br>$$<br>f_t = \sigma (W_f \cdot [h_{t-1},x_t] + b_f) \<br>i_t = \sigma (W_i \cdot [h_{t-1},x_t] + b_i) \<br>\tilde{C}<em>t = tanh(W_C \cdot [h</em>{t-1},x_t] + b_C) \<br>C_t = f_t \otimes C_{t-1} + i_t \otimes \tilde{C}<em>t \<br>o_t = \sigma (W_o \cdot [h</em>{t-1},x_t] + b_o) \<br>h_t = o_t \otimes tanh(C_t)<br>$$</p><p>实际上 LSTM 通过 sigmoid 函数学习概率，来决定哪些数据应该以多大比例遗忘，哪些数据应该以多大比例记住。门 CNN 同理，通过 sigmoid 函数来决定当前的特征应该以多大比例保留：</p><p>$$<br>h^l(X) = (X * W + b) \otimes \sigma (X * V + c)  \<br>or \quad h^l(X) = tanh(X * W + b) \otimes \sigma (X * V + c) \<br>$$<br>第一种叫Gated linear unit (GLU) ，第二种叫 Gated tanh unit (GTU)</p><p>GLU的优点：</p><ul><li><p>按一定比例保留数据</p></li><li><p>具有拟合非线性函数能力的同时保留线性路径，减缓梯度消失问题<br>  $$<br>  \bigtriangledown [X \otimes \sigma(X)] = \bigtriangledown X \otimes \sigma(X) + X \otimes \sigma(X)^{‘} \bigtriangledown X<br>  $$</p><p>接下来介绍如何利用一维卷积和GLU来获得隐藏表示$h^l_i \in R^d$ ：</p><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g2losp59tej20nh0coq33.jpg" alt="convblock.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method 1</span></span><br><span class="line">z = keras.layers.Conv1D(<span class="number">2</span>d, <span class="number">3</span>, padding=<span class="string">'same'</span>,activation=<span class="literal">None</span>)(e)</span><br><span class="line">z = z[:,:,:d] * K.sigmoid(z[:,:,d:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># method 2</span></span><br><span class="line">z1 = keras.layers.Conv1D(d, <span class="number">3</span>, padding=<span class="string">'same'</span>,activation=<span class="literal">None</span>)(e)</span><br><span class="line">z2 = keras.layers.Conv1D(d, <span class="number">3</span>, padding=<span class="string">'same'</span>,activation=<span class="string">'sigmoid'</span>)(e)</span><br><span class="line">z = z1 * z2</span><br></pre></td></tr></table></figure><p>Encoder 可以获取全部数据信息，所以计算每个词的隐藏表示时可以利用上下文信息甚至利用整句话的信息。但是对于序列生成任务来说，Decoder 的每个词是逐个生成的。由于是监督任务，在训练时可以得到 Decoder 的全部输入。但是在测试时我们并不知道 Decoder 的后续词。所以在 Decoder 部分我们需要对卷积做一些改变，让它只利用上文信息，而无法利用下文信息。具体的做法是给卷积核加 mask 掩码：<br>$$<br>h^l(X) = (X * (W \otimes I) + b) \otimes \sigma (X * (V \otimes I) + c)<br>$$<br>其中，$I$ 表示掩码矩阵。举个例子，词嵌入的维度是4，一维卷积核大小是5，它的掩码矩阵是：<br>$$<br>\begin{pmatrix}w_{11} &amp; w_{12} &amp; w_{13} &amp; w_{14}\<br>w_{21} &amp; w_{22} &amp; w_{23} &amp; w_{24}\<br>w_{31} &amp; w_{32} &amp; w_{33} &amp; w_{34}\<br>w_{41} &amp; w_{42} &amp; w_{43} &amp; w_{44}\<br>w_{51} &amp; w_{52} &amp; w_{53} &amp; w_{54}\end{pmatrix}<br>\otimes<br>\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1\<br>1 &amp; 1 &amp; 1 &amp; 1\<br>1 &amp; 1 &amp; 1 &amp; 1\<br>0 &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 0\end{pmatrix}<br>$$<br><img data-src="https://i.loli.net/2018/12/19/5c19ba8b07c39.jpg" alt="pic"></p><p><img data-src="https://i.loli.net/2018/12/19/5c19c19bc352f.jpg" alt="pic"></p></li></ul></li><li><p>Residual block</p><blockquote><p><a href="https://arxiv.org/pdf/1512.03385.pdf" target="_blank" rel="noopener">Deep Residual Learning for Image Recognition</a></p></blockquote><p>$$<br>h_i^l = h_i^l + h_{i-1}^l \<br>or \quad h_i^l = f(h_i^l) + h_{i-1}^l \<br>or \quad h_i^l = h_i^l + f(h_{i-1}^l) \<br>or \quad h_i^l = f(h_i^l) + f(h_{i-1}^l) \<br>or \quad h_i^l = f(h_i^l + h_{i-1}^l)<br>$$</p><p>优点：</p><ul><li><p>减缓梯度消失</p><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g06be7ig14j2082049t8l.jpg" alt="pic"></p><p>深层网络比浅层网络更具表现力，但随着网络加深，模型越来越难以训练，存在梯度消失问题。如上图加入残差块后，进行反向传播时，$a^{[l+2]}$ 层的梯度会有两个传播路径：沿着深层网络传播；沿着跳跃连接传播。即使深层网络反向传播过程中梯度为0，但是由于存在跳跃连接提供梯度，所以会减缓梯度消失的问题。</p></li><li><p>保证网络性能<br><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g06beaip9xj20kw07mt8x.jpg" alt="pic"></p></li></ul></li><li><p>add layers</p><ul><li><p>捕获更多的上下文信息</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g2lotg379yj20or0b6ab6.jpg" alt="pic"></p></li><li><p>理论上，深层网络比浅层网络更具表现力</p><p><img data-src="https://i.loli.net/2018/12/19/5c19b44e52ec8.jpg" alt="pic"></p></li></ul></li></ol><h3 id="Multi-step-Attention"><a href="#Multi-step-Attention" class="headerlink" title="Multi-step Attention"></a>Multi-step Attention</h3><ol><li><p>Attention</p><p>Attention 机制从大量信息中有选择地筛选出少量重要信息并聚焦到这些重要信息上，忽略大多不重要的信息。</p><p><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g06bef0ga9j20fs0dyt9g.jpg" alt="pic"></p><p>上图中，key 和 value 表示原语句 source 的元素；query 表示目标语句 target 的元素。Attention 机制可以分为3个阶段。以机器翻译为例，key 和 value 都表示原语句的特征表示，qyery 表示上一时刻的隐藏状态 / 上文特征。公式如下：</p><ul><li><p>计算 query 和 key 的相似度<br>$$<br>Similarity(Query,Key_i) = Query\cdot Key_i<br>$$</p></li><li><p>softmax 归一化得到 key 对应 value 的权重<br>$$<br>a_i = Softmax(Similarity_i)=\frac{e^{Similarity_i}}{\sum_{i=1}^{L_x}e^{Similarity_i}}<br>$$</p></li><li><p>对 value 进行加权求和<br>$$<br>Attention(Query,Source)=\sum_{i=1}^{L_x}a_i\cdot Value_i<br>$$</p></li></ul></li><li><p>Multi-step Attention<br>$$<br>d_i^l = W_d^l h_i^l + b_d^l + g_i \<br>a_{ij}^l = \frac{exp(d_i^l \cdot z_j^u)}{\sum_{t=1}^{m}exp(d_i^l \cdot z_t^u)} \<br>c_i^l = \sum_{j=1}^{m} a_{ij}^l(z_j^u + e_j)<br>$$</p><ul><li>第一个公式：残差，将 Decoder 第 $l$ 层的隐藏表示进行线性变换，然后与 Decoder 的输入 $g$ 相加作为第 $l$ 层最后的隐藏状态</li><li>第二个公式：$z_j^u$ 表示 Encoder 最后一层的输出的第 $j$ 个隐藏表示；计算 Encoder 各个隐藏表示与 Decoder 的隐藏特征表示 $d_i^l$ 的相似度，再进行 softmax 归一化</li><li>第三个公式：对 value 进行加权求和，此时 query 是Decoder 第 $l$ 层的第 $i$时刻的特征 $d_i^l$；key 是Encoder 最后一层的输出 $z_j^u$； value 是 $z_j^u + e_j$ 。为什么 value 要加入 $e_j$ 信息？ $z_j^u$ 表示 $j$ 时刻词的特征表示，这个特征表示包含上下文信息；$e_i$ 提供对应输入元素的词信息。在机器翻译这种序列任务中存在词与词对齐的要求，以前的对齐方式是逐元素对齐，这也印证了加入特定输入元素的点信息是有好处的。局部 Attention 的一种对齐方式就是选择对应位置元素，并且 key-value 记忆网络也印证了这一点。</li></ul></li></ol><p><img data-src="https://i.loli.net/2018/12/16/5c165b2778c45.png" alt="convtable5.png"></p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><ul><li>一般建立字典方式：使用<code>&lt;UNK&gt;</code>表示集外词</li><li>双字节编码（byte-pair encoding, BPE）：把罕见词拆分成“子词单元”的组合，解决集外词和罕见词问题</li><li>Word pieces：把单词分别为单词块，解决集外词和罕见词问题</li></ul><p><img data-src="https://i.loli.net/2018/12/16/5c165b27c9471.png" alt="couvs2stable1.png"></p><p><img data-src="https://i.loli.net/2018/12/16/5c165b277c775.png" alt="convs2stable2.png"></p><p><img data-src="https://i.loli.net/2018/12/16/5c165b27c818b.png" alt="convtable3.png"></p><h3 id="beam-search"><a href="#beam-search" class="headerlink" title="beam search"></a>beam search</h3><ul><li><p>贪心搜素（greedy search）</p><p>生成第一个词的分布以后，选择最有可能的第一个词，然后根据第一个词继续挑选出最有可能的第二个词，以此类推，这种算法就叫做贪心搜索。但是真正需要的是挑选出一个序列，使得 $y^1,…,y^n$ 的概率最大化，而贪心搜索不能满足这种需求。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">French: Jane visite l'Afrique en septembre</span><br><span class="line"></span><br><span class="line">Jane is visiting Africa in September</span><br><span class="line">Jane is going to be visiting Africa in September</span><br></pre></td></tr></table></figure></li><li><p>集束搜索（beam search）</p><p>每一时刻我们都会得到每个词的概率，如果想使得 $y^1,…,y^n$ 的概率最大化，最笨拙的想法是保留所有词的概率值，最后从 $size^{n}$ 个序列中选择概率最大的作为最终的输出序列，但是这种方式的计算成本是无法接受的。集束搜索的方式是每次选择前 d 个概率最大的词。</p><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g06beig5pdj20d70ckaal.jpg" alt="pic"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Machine Theory of Mind</title>
      <link href="/2019/02/14/00006/"/>
      <url>/2019/02/14/00006/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/QvS4y5xorTMmRHN.jpg" alt="ReconciliationDay_ZH-CN7914130812_1920x1080.jpg"></p><a id="more"></a><blockquote><p>DeepMind 近日发表的最新研究提出 “机器心智理论”（Machine Theory of Mind），启发自心理学中的 “心智理论”，研究者构建了一个心智理论的神经网络ToMnet，并通过一系列实验证明它具有心智能力。这是开发多智能体AI系统，构建机器-人机交互的中介技术，以及推进可解释AI发展的重要一步。</p></blockquote><h2 id="Machine-Theory-of-Mind"><a href="#Machine-Theory-of-Mind" class="headerlink" title="Machine Theory of Mind"></a>Machine Theory of Mind</h2><p>目前深度学习和深度强化学习取得了飞跃的进展，但是神经网络还是一个黑盒，我们对其能够取得这样效果的原因并不了解。即使我们能够知道网络各个层的权重，也很难弄清楚它们到底是怎么运作的，以及它们可能出错的地方和潜在的风险。随着AI越来越多地进入人类世界，理解神经网络的需求也越来越大。</p><p>暂且不考虑神经网络，首先我们来看一下人类是怎样互相理解的。作为人类，我们每天都会和其他人交流，我们可以预测陌生人未来的行为；可以规划与他人的互动；可以建立高效的沟通。虽然我们并不了解其他人的神经元是怎么活动的，并不了解别人的皮质层是怎么连接的，也并不了解其他人的海马体是怎么运作的，但是我们能够很好的理解他人的行为、揣测他人的想法。这就是<strong>心智理论</strong>（Theory of Mind）。心智理论是指个体能够理解自己与他人的心理状态（包括情绪意图、期望、思考和信念等）并藉此信息预测和解释他人行为的一种能力。</p><p>对其他智能体的 “理解” 有一个显著特点是，智能体对其他智能体的理解不会去思考它真正的底层结构。DeepMind研究人员从人的心智理论中获得灵感，试图构建一个能够对其他智能体进行建模的系统，将其描述为 ——<strong>机器心智理论</strong>，关注点是<strong>观察者</strong>如何使用有限的数据自主地为其他智能体建模。</p><h2 id="Meta-Learning"><a href="#Meta-Learning" class="headerlink" title="Meta Learning"></a>Meta Learning</h2><p>研究者构建了一个心智理论的神经网络ToMnet，是一种元学习模型。<strong>元学习</strong>（Meta Learning）也叫做学会学习（Learning to Learn），其研究重心是使机器拥有学习的能力。元学习是实现快速学习的方法之一，已经成为继强化学习（Reinforcement Learning）之后又一个重要的研究分支。人工智能研究呈现出如下趋势：</p><blockquote><p>Artificial Intelligence –&gt; Machine Learning –&gt; Deep Learning –&gt; Deep Reinforcement Learning –&gt; Deep Meta Learning</p></blockquote><p>之所以会这样发展完全取决于当前人工智能的发展。在Machine Learning时代，复杂一点的分类问题效果就不好了，Deep Learning的出现基本上解决了一对一映射的问题，比如说图像分类，一个输入对一个输出，因此出现了AlexNet这样的里程碑式的成果。但如果输出对下一个输入还有影响呢？也就是序列决策问题（sequential decision making）单一的深度学习就解决不了了，这时就进一步衍生出了深度强化学习（Deep Reinforcement Learning）。有了深度强化学习，序列决策初步取得成效，出现了AlphaGo这样的里程碑式的成果。但是新的问题又出来了，深度强化学习太依赖于巨量的训练，并且需要精确的奖励（Reward），对于现实世界的很多问题并没有好的奖励，也没办法无限量训练，这时怎么办？这就需要元学习，能够充分的利用以往的知识经验来指导新任务的学习，元学习成为目前一个新的攻克方向。</p><p>元学习是实现快速学习的方法之一。为什么人类能够快速学习，因为我们可以<strong>利用以往的经验</strong>来学习！ 所以，要让深度学习能够快速学习，就要研究如何让神经网络能够很好的利用以往的知识，使得神经网络能够根据新的任务调整自己。</p><p>元学习的实现方式多种多样，比如基于记忆Memory的方法 、基于预测梯度的方法 、利用Attention注意力机制的方法等等（参考<a href="https://www.leiphone.com/news/201708/tSXB6oo1mdnbKvkd.html" target="_blank" rel="noopener">元学习：实现通用人工智能的关键</a>）</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>DeepMind试图建立一个模拟其他智能体的模型，设计了一个心智理论的神经网络（Theory of Mind neural network）——ToMnet。该网络相当于一个代理模型，学习怎样通过元学习从头推理其他智能体。通过这个过程，ToMnet 获得了一个关于智能体行为的强大先验模型，以及仅使用少量行为观察就能更丰富地预测智能体的特征和心理状态的能力。研究者将 ToMnet 应用了到简单的格子环境智能体，并且通过了经典的 ToM 任务测试。研究者认为这个系统——智能体自主地学习如何模拟其他智能体——是开发多智能体 AI 系统，构建人机交互的中介技术，以及促进可解释 AI 进展的重要一步。这项工作还有许多潜在的应用，比如改进复杂多智能体任务的决策、数据校准等。</p><p>DeepMind认为，构建心智理论的挑战本质上在于元学习问题。在测试时，我们希望遇到一个以前没见过的智能体，并且它们已经对自身的行为方式有一个强大且丰富的先验知识（训练好的智能体）。此外，在我们看到该智能体在现实中的行动时，我们希望能收集它们的隐藏特征（构成后验知识），这有助于我们预测它们未来的行为。</p><p>为此，DeepMind制定了一个元学习任务。构建了一个<strong>观察者</strong>（observer），它在每一轮（episode）都可以看到 智能体一组新的行为。观察者的目标是<strong>预测智能体未来的行为</strong>。在训练过程中，观察者应该从有限的数据中快速形成有关新智能体的预测。这种关于新智能体的 “学习” 就是我们所说的元学习。通过这个过程，观察者还应该学习到智能体行为的有效先验，这些知识隐含地捕捉了训练群体中智能体之间的共性。</p><p>DeepMind 引入了两个概念来描述该观察者网络及其功能角色。区分两个一般心智理论，即网络的预学习权重与特定智能体心智理论。在网络的预学习权重中，它包含了训练集中所有智能体一般行为的预测。而在特定智能体心智理论中，从单个智能体在测试时的观察形成”agent embedding“，它包含了使得智能体的特性和精神状态区别于其它智能体的内容。这些对应于智能体行为的先验知识和后验知识。</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><p>ToMnet属于强化学习/元学习的模型，处理的任务是一个部分可观察马尔可夫决策过程族$M=U_jMj$。马尔可夫决策过程（MDPs）是强化学习的数学基础，部分可观察马尔可夫决策过程（POMDPs）是马尔可夫决策过程的扩展。</p><ol><li><p>MDPs</p><p> 首先介绍一下马尔可夫决策过程，一个马尔可夫决策过程由一个五元组构成：<br> $$<br> &lt;S,A,P,R,\gamma&gt;<br> $$</p><ul><li><p>$S$表示状态集合</p></li><li><p>$A$表示动作集合</p></li><li><p>$P$表示状态转移函数<br>$$<br>P_{ss^{‘}}^a=P[S_{t+1}=s^{‘}|S_t=s,A_t=a]<br>$$<br>$P$的所有值构成状态转移矩阵</p></li><li><p>$R$表示奖励函数，$R(s,a)$描述了在状态$s$做动作$a$的奖励<br>$$<br>R(s,a)=E[R_{t+1}|S_t=s,A_t=a]<br>$$</p></li><li><p>$\gamma$表示衰减因子，$\gamma \in [0,1]$</p><p>在强化学习中，从初始状态$S_1$到终止状态$S_T$的序列过程，称为一个片段（episode）：$S_1,…,S_T$</p><p>在MDPs问题中，值函数分为状态值函数（V函数）:<br>$$<br>v_{π}(s)=E_{π}[G_t|S_t=s]<br>$$<br>和状态动作值函数（Q函数）:<br>$$<br>q_{π}(s,a)=E_{π}[G_t|S_t=s,A_t=a]<br>$$<br>其中，$π$表示策略，在MDPs中，一个策略$π$是在给定状态下的动作的概率分布：<br>$$<br>π(a|s)=P[A_t=a|S_t=s]<br>$$<br>$G_t=\sum <em>{k=0}^{T-t-1}\gamma ^k R</em>{t+k+1}$是回报值，对于一个强化学习问题，我们最终的目标是最大化回报值的期望，即最大化值函数，值函数使用贝尔曼期望方程求解。</p></li></ul></li><li><p>POMDPs</p><p> POMDPs由七元组组成：<br> $$<br> &lt;S,A,P,R,\Omega,w,\gamma&gt;<br> $$</p><ul><li><p>$\Omega$ 表示观察结果集，观察结果集不等于状态集合$\Omega_t \neq S_t$，环境数据</p></li><li><p>$w$表示条件观测函数，就是系统在观察到环境$o$时，有多大概率确定自己处于状态$s$</p><p>和MDPs问题不同的是，POMDPs不能确定自己处于哪种状态，需要根据当前的环境确定自己目前所处的状态。</p></li></ul></li><li><p>ToMnet任务</p><p> 对于一般的强化学习问题来说，只有一个模型并且通过训练使该模型具有预测下一步状态/动作的能力；而ToMnet存在一个观察者，目标是使用这个观察者来预测agents下一步的状态/动作。那么，与POMDPs不同的是，奖励函数$R$，衰减因子$\gamma$，观察结果集$\Omega$，条件观测函数$w$与agent相关联，而不是与POMDPs相关联。因为在这个任务中，agent不是单一的而是多个，将不同的agent放在同一个POMDPs中可能产生不同的奖励/输出。此时POMDPs是状态集合$S_j$，动作集合$A_j$和转移概率$T_j$的元组$M_j={S_j,A_j,T_j }$，将所有的POMDPs写成$S=U_jS_j$。假设有一个agent族$A=U_iA_i,A_i={\Omega_i,w_i,R_i,\gamma_i,π<em>i }$，策略$π_i$可以是随机的，算法输出或模型学习得到的。如果agent $A_i$在POMDPs中遵循策略$π_i$并产生轨迹$\tau</em>{ij}={ (s_t,a_t)}<em>{t=0}^T$，则观察者能看到轨迹$\tau</em>{ij}={ (x_{t}^{(obs)},a_{t}^{(obs)})}<em>{t=0}^T$，其中$x</em>{t}^{(obs)}=w^{(obs)}(s_t),w^{(obs)}(\cdot):S \to \Omega^{(obs)}$是状态观测函数，$a_{t}^{(obs)}=\alpha^{(obs)}(a_t),\alpha^{(obs)}(\cdot)$是动作观测函数。观察者能够访问agent的轨迹，但是不能访问agent的参数、奖励和策略等。</p><p> ToMnet的任务是能观察到一系列的agents，观察者必须学会预测许多agents的行为。当观察者与单个agent相遇时，能够观测到该agent $A_i$的过去的轨迹${\tau }<em>{t=0}^{N</em>{past}}$，观察者的任务是在POMDPs内对agent的下一步动作/状态进行预测。</p></li></ol><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>为了解决这个问题，DeepMind提出ToMnet架构，ToMnet由3部分构成：character网络、mental state网络和prediction网络。</p><ul><li><p>character网络的目标是将观察者观察到的agents的过去轨迹${\tau }<em>{t=0}^{N</em>{past}}$解析为character嵌入，从神经网络的角度考虑就是使用神经网络$f_{\theta}$来产生输出$e_{char,ij}=f_{\theta}(\tau_{ij}^{(obs)})$，然后相加得$e_{char,i}=\sum_{j=1}^{N_{past}}$。也就是说character网络是学习所有agents的过去轨迹的嵌入表示，即所有agents的共同特征。</p></li><li><p>mental state网络的目标是对当前agent的轨迹$\tau_{ik}^{(obs)}$进行嵌入编码。从神经网络的角度考虑$e_{mental,i}=g_{\phi}([\tau_{ik}^{(obs)}]<em>{0:t-1},e</em>{char,i})$，可以认为mental state网络学习到当前agent的特有特征。</p></li><li><p>prediction网络利用$e_{char}$和$e_{mental}​$来预测agent的后续行为。</p></li></ul><p><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g06akwqdgrj20hr0de755.jpg" alt="架构"></p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>为了证明ToMnet具有机器心智，即具有预测agent下一步动作/状态/策略的能力，DeepMind进行了一系列的实验加以证明，包括随机agent和强化学习agent等。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://arxiv.org/pdf/1802.07740.pdf" target="_blank" rel="noopener">Machine Theory of Mind</a></li><li><a href="https://zhuanlan.zhihu.com/p/27629294" target="_blank" rel="noopener">学会学习Learning to Learn：让AI拥有核心价值观从而实现快速学习</a></li><li><a href="https://www.leiphone.com/news/201708/tSXB6oo1mdnbKvkd.html" target="_blank" rel="noopener">元学习：实现通用人工智能的关键</a></li><li><a href="https://mp.weixin.qq.com/s/n7X17CLMYZ2dUUJ4NbRFkA" target="_blank" rel="noopener">深度 | 让机器思考与互相理解：DeepMind提出机器心智理论神经网络ToMnet</a></li><li><a href="https://mp.weixin.qq.com/s/1YSincOc6VloezgcucpnDw" target="_blank" rel="noopener">DeepMind提出「心智神经网络ToMnet」，训练机器的「理解」能力</a></li><li><a href="https://mp.weixin.qq.com/s/BDwgPgw0ULuHoKdae2g7FA" target="_blank" rel="noopener">可解释AI重大突破 | DeepMind 构建心智理论神经网络让机器互相理解</a></li><li><a href="http://tongtianta.site/paper/509" target="_blank" rel="noopener">Machine Theory of Mind翻译</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis反向工程配置文件</title>
      <link href="/2019/02/11/00005/"/>
      <url>/2019/02/11/00005/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/G7qMlOXtsCJAjxT.jpg" alt="Seidenschwanz_ZH-CN7486965726_1920x1080.jpg"></p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置生成器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项</span></span><br><span class="line"><span class="comment">        resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties</span></span><br><span class="line"><span class="comment">        url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.</span></span><br><span class="line"><span class="comment">        注意，两个属性只能选址一个;</span></span><br><span class="line"><span class="comment">        另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用</span></span><br><span class="line"><span class="comment">    &lt;properties resource="" url="" /&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在MBG工作的时候，需要额外加载的依赖包</span></span><br><span class="line"><span class="comment">        location属性指明加载jar/zip包的绝对路径</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">"/home/apathy/.IntelliJIdea2018.3/config/jdbc-drivers/MySQL Connector/J/5.1.46/mysql-connector-java-5.1.46.jar"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        context:生成一组对象的环境</span></span><br><span class="line"><span class="comment">        id:必选，上下文id，用于在生成错误时提示</span></span><br><span class="line"><span class="comment">        defaultModelType:指定生成对象的样式</span></span><br><span class="line"><span class="comment">            1，conditional：类似hierarchical；</span></span><br><span class="line"><span class="comment">            2，flat：所有内容（主键，blob）等全部生成在一个对象中；</span></span><br><span class="line"><span class="comment">            3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)</span></span><br><span class="line"><span class="comment">        targetRuntime:</span></span><br><span class="line"><span class="comment">            1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；</span></span><br><span class="line"><span class="comment">            2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；</span></span><br><span class="line"><span class="comment">        introspectedColumnImpl：类全限定名，用于扩展MBG</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"mysql"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--去除自动生成的注释--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；</span></span><br><span class="line"><span class="comment">            一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoDelimitKeywords"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成的Java文件的编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFileEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化java代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFormatter"</span> <span class="attr">value</span>=<span class="string">"org.mybatis.generator.api.dom.DefaultJavaFormatter"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化XML代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"xmlFormatter"</span> <span class="attr">value</span>=<span class="string">"org.mybatis.generator.api.dom.DefaultXmlFormatter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="beginningDelimiter" value="`"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="endingDelimiter" value="`"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 必须要有的，使用这个配置链接数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span> <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql:///test"</span> <span class="attr">userId</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- java类型处理器</span></span><br><span class="line"><span class="comment">            用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；</span></span><br><span class="line"><span class="comment">            注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型</span></span><br><span class="line"><span class="comment">                false：默认,</span></span><br><span class="line"><span class="comment">                    scale&gt;0;length&gt;18：使用BigDecimal;</span></span><br><span class="line"><span class="comment">                    scale=0;length[10,18]：使用Long；</span></span><br><span class="line"><span class="comment">                    scale=0;length[5,9]：使用Integer；</span></span><br><span class="line"><span class="comment">                    scale=0;length&lt;5：使用Short；</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- java模型创建器，是必须要的元素</span></span><br><span class="line"><span class="comment">            负责：1，key类（见context的defaultModelType）；2，java类；3，查询类</span></span><br><span class="line"><span class="comment">            targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；</span></span><br><span class="line"><span class="comment">            targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.demo.entry"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  for MyBatis3/MyBatis3Simple</span></span><br><span class="line"><span class="comment">                自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"constructorBased"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- for MyBatis3 / MyBatis3Simple</span></span><br><span class="line"><span class="comment">                是否创建一个不可变的类，如果为true，</span></span><br><span class="line"><span class="comment">                那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"immutable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 设置一个根对象，</span></span><br><span class="line"><span class="comment">                如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项</span></span><br><span class="line"><span class="comment">                注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：</span></span><br><span class="line"><span class="comment">                    1，属性名相同，类型相同，有相同的getter/setter方法；</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="rootClass" value="com._520it.mybatis.domain.BaseDomain"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成SQL map的XML文件生成器，</span></span><br><span class="line"><span class="comment">            注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），</span></span><br><span class="line"><span class="comment">                或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置</span></span><br><span class="line"><span class="comment">            targetPackage/targetProject:同javaModelGenerator</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.demo.mapper"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口</span></span><br><span class="line"><span class="comment">            targetPackage/targetProject:同javaModelGenerator</span></span><br><span class="line"><span class="comment">            type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：</span></span><br><span class="line"><span class="comment">                1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；</span></span><br><span class="line"><span class="comment">                2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；</span></span><br><span class="line"><span class="comment">                3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；</span></span><br><span class="line"><span class="comment">            注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.demo.mapper"</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查</span></span><br><span class="line"><span class="comment">            &lt;property name="rootInterface" value=""/&gt;</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"student"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"school"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素</span></span><br><span class="line"><span class="comment">            选择的table会生成一下文件：</span></span><br><span class="line"><span class="comment">            1，SQL map文件</span></span><br><span class="line"><span class="comment">            2，生成一个主键类；</span></span><br><span class="line"><span class="comment">            3，除了BLOB和主键的其他字段的类；</span></span><br><span class="line"><span class="comment">            4，包含BLOB的类；</span></span><br><span class="line"><span class="comment">            5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；</span></span><br><span class="line"><span class="comment">            6，Mapper接口（可选）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            tableName（必要）：要生成对象的表名；</span></span><br><span class="line"><span class="comment">            注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会</span></span><br><span class="line"><span class="comment">                根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：</span></span><br><span class="line"><span class="comment">                1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；</span></span><br><span class="line"><span class="comment">                2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；</span></span><br><span class="line"><span class="comment">                3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；</span></span><br><span class="line"><span class="comment">                4，否则，使用指定的大小写格式查询；</span></span><br><span class="line"><span class="comment">            另外的，如果在创建表的时候，使用的""把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；</span></span><br><span class="line"><span class="comment">            这个时候，请设置delimitIdentifiers="true"即可保留大小写格式；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            可选：</span></span><br><span class="line"><span class="comment">            1，schema：数据库的schema；</span></span><br><span class="line"><span class="comment">            2，catalog：数据库的catalog；</span></span><br><span class="line"><span class="comment">            3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName</span></span><br><span class="line"><span class="comment">            4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；</span></span><br><span class="line"><span class="comment">            5，enableInsert（默认true）：指定是否生成insert语句；</span></span><br><span class="line"><span class="comment">            6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；</span></span><br><span class="line"><span class="comment">            7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；</span></span><br><span class="line"><span class="comment">            8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；</span></span><br><span class="line"><span class="comment">            9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；</span></span><br><span class="line"><span class="comment">            10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；</span></span><br><span class="line"><span class="comment">            11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；</span></span><br><span class="line"><span class="comment">            12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；</span></span><br><span class="line"><span class="comment">            13，modelType：参考context元素的defaultModelType，相当于覆盖；</span></span><br><span class="line"><span class="comment">            14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）</span></span><br><span class="line"><span class="comment">            15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;table tableName="userinfo" &gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 参考 javaModelGenerator 的 constructorBased属性&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="constructorBased" value="false"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="ignoreQualifiersAtRuntime" value="false"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 参考 javaModelGenerator 的 immutable 属性 &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="immutable" value="false"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="modelOnly" value="false"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 参考 javaModelGenerator 的 rootClass 属性--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="rootClass" value=""/&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 参考javaClientGenerator 的  rootInterface 属性--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="rootInterface" value=""/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="runtimeCatalog" value=""/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="runtimeSchema" value=""/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="runtimeTableName" value=""/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 注意，该属性只针对MyBatis3Simple有用；--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="selectAllOrderByClause" value="age desc,username asc"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;property name="useActualColumnNames" value="false"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; generatedKey用于生成生成主键的方法，--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--column:主键的列名；--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--sqlStatement：要生成的selectKey语句，有以下可选项：--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--Informix  :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--JDBC      :相当于在生成的insert元素上添加useGeneratedKeys="true"和keyProperty属性--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;generatedKey column="" sqlStatement=""/&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--那么就可以设置searchString为"^CUST_"，并使用空白替换，那么生成的Customer对象中的属性名称就不是--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；--&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果使用了columnOverride元素，该属性无效；--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&lt;columnRenamingRule searchString="" replaceString=""/&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--column:要重新设置的列名；--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--注意，一个table元素中可以有多个columnOverride元素哈~--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;columnOverride column="username"&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 使用property属性来指定列要生成的属性名称 &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;property name="property" value="userName"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--&amp;lt;!&amp;ndash; javaType用于指定生成的domain的属性类型，使用类型的全限定名--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;property name="javaType" value=""/&gt;--&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--&amp;lt;!&amp;ndash; jdbcType用于指定该列的JDBC类型--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;property name="jdbcType" value=""/&gt;--&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--&amp;lt;!&amp;ndash; typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;property name="jdbcType" value=""/&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--&amp;lt;!&amp;ndash; 参考table元素的delimitAllColumns配置，默认为false--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;property name="delimitedColumnName" value=""/&gt;--&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;/columnOverride&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash; ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--column:指定要忽略的列的名字；--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false--&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--注意，一个table元素中可以有多个ignoreColumn元素--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;ignoreColumn column="deptId" delimitedColumnName=""/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/table&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adversarial Autoencoder</title>
      <link href="/2019/02/11/00004/"/>
      <url>/2019/02/11/00004/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/UjcJTCVhogf7zs6.jpg" alt="MountHowitt_ZH-CN1042812457_1920x1080.jpg"></p><a id="more"></a><h2 id="相关理论"><a href="#相关理论" class="headerlink" title="相关理论"></a>相关理论</h2><p>对抗自编码器（AAE）是AE+GAN的生成模型，可以说是VAE和GAN的一种改进模型。<br>首先介绍一下生成式模型的基本方法，下图是 Goodfellow 2016年总结的和神经网络相关生成式方法的“家谱”。以极大似然为根节点，按照是否需要定义概率密度函数划分为：明确概率、没有明确概率。<br>明确概率又可以进一步划分为：准确求解、近似求解。准确求解就是可以直接通过数学方法来建模求解。但是在神经网络中，准确求解可能会出现时间复杂度极高、高维不可求、无法微分等问题。此时就需要通过近似求解来结果这种问题。近似求解可以分为：确定近似方法和随机近似方法。确定近似方法主要使用变分推断，采用最大化变分下界（确定的公式）的方法来求解，比如VAE就是使用变分推断求出变分下界，将潜在变量空间Z构造成高斯分布。随机方法也就是马尔科夫链蒙特卡洛采样这类算法，比如BM、RBM、DBN、DBM等，主要以MCMC算法为主。变分推断和蒙特卡洛采样其实挺相似的。在蒙特卡洛采样中，采样大量的样本来拟合真实数据的分布，而在变分推断中，使用简单分布来拟合真实数据分布。但是马尔科夫链蒙特卡洛采样速度慢并且不准确。<br>没有明确概率又可以分为：马尔科夫链蒙特卡洛采样、GAN两部分。今天要讲解的AAE就属于GAN的一种。<br>由于马尔科夫链蒙特卡洛采样需要进行大量的采样来拟合真实数据的分布，导致速度慢并且不准确。所以现在比较火的生成模型就是：VAE、GAN、pixel，在训练时可以直接采用BP算法，克服了MCMC训练存在的不足之处。<br><img data-src="http://static.leiphone.com/uploads/new/article/740_740/201702/589978abeec64.png?imageMogr2/format/jpg/quality/90" alt="generative model tree"></p><h2 id="AAE"><a href="#AAE" class="headerlink" title="AAE"></a>AAE</h2><p>下面简单介绍一下AAE的模型。AAE是AE+GAN的生成模型，可以说是VAE和GAN的一种改进模型。<br>为什么是VAE的改进模型：VAE的目的是通过变分推断的方法使得潜在变量空间$z$服从多维高斯分布，而AAE的目的也是使得潜在变量空间$z$服从多维高斯分布。可以说说殊途同归的两种模型；<br>为什么是GAN的改进模型：AAE通过加入对抗网络的方法使得潜在变量空间$z$服从多维高斯分布；<br>AAE由两部分构成：<br>AE（编码器、解码器）：对于所有的自编码器来说其目标都是样本重构。自编码器首先通过编码器把高維空间中的向量$X$，压缩成低維向量$Z$(潜变量)，然后通过解码器把低維向量解压重构出$X$，然后使用均方差损失通过BP进行训练。如该图上半部分所示，编码器首先把一个样本手写字体1通过编码器压缩成一个低維向量$z$，然后通过解码器重构原始样本。<br>GAN（生成器、判别器）：判别器用于区分真样本和假样本，生成器用于生成假样本。AE的编码器相当于GAN的生成器。<br><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g02i90btrbj20km0a1gm6.jpg" alt="Adversarial Autoencoders"><br>再介绍一下模型的变量：<br>$x$：输入样本数据向量;<br>$q(z|x)$：编码器分布函数;<br>$z$：潜在变量空间，编码出来的潜在变量，服从$z \sim q(z)$分布;<br>$q(z)$：AAE模型学习出来的分布;<br>$p(z)$：自己定义的任意先验分布，通常$N(0,I)$;<br>AAE的训练涉及到AE的训练和GAN的训练。AE训练比较简单，使用均方差作为损失函数，通过BP算法进行训练。由于涉及到GAN，下面来复习一下GAN。</p><h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><p>下图是GAN的损失函数。下面以生成图片为例来说明一下GAN的公式和原理。<br><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g02ib09k5uj20n101qmx5.jpg" alt="公式"><br>GAN由两部分构成：生成器、判别器。首先从左到右解释一下这个公式。$G$表示生成器，$D$表示判别器，$x$表示真实数据，$P_{data}(x)$表示真实数据的分布，$D(x)$表示判别器判断真实数据是否真实的概率，$z$表示随机噪声，$P_z(z)$表示噪声数据的分布，$G(z)$表示随机噪声通过生成器后生成的假图片、$D(G(z))$是判别器判断生成器生成的图片是否真实的概率。<br>再解释一下为什么要最小化$G$，最大化$D$：</p><ul><li>$G$是生成器，用于生成图片。它接收一个随机的噪声$z$，从噪声$z$中采样通过生成器来生成图片$G(z)$。生成器$G$的目的：$D(G(z))$是判别器判断生成器生成的图片是否真实的概率，生成器$G$应该希望自己生成的图片“越接近真实越好”。也就是说，$G$希望$D(G(z))$尽可能得大，这时$V(D,G)$会变小。所以式子最前面是最小化$G（min_G）$</li><li>$D$是判别器，用于判别一张图片是不是“真实的”。它的输入参数是$x$，$G(z)$。考虑单样本，从真实数据分布中采样得到真样本$x$，经过判别器得到$D(x)$；将假样本$G(z)$输入判别器得到$D(G(z))$。判别器$D$的目的：$D$的能力越强，$D(x)$应该越大，$D(G(x))$应该越小。这时$V(D,G)$会变大。因此式子最前面是最大化$D（max_D）$<br><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g02ic6mauij20e809pjrf.jpg" alt="gan"><br>在训练过程中，生成器$G$的目标就是尽量生成真实的图片去欺骗判别器$D$。而判别器$D$的目标就是尽量把生成器$G$生成的图片和真实图片区分出来。这样生成器$G$和判别器D构成了一个动态的“博弈过程”。在最理想的状态下，生成器$G$可以生成足以“以假乱真”的图片$G(z)$。对于$D$来说，它难以判定$G$生成的图片究竟是不是真实的，因此$D(G(z)) = 0.5$。<br>下面给出GAN训练的伪代码：<br><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g02id4doopj20n50faabv.jpg" alt="GAN训练"><br>训练AAE时，在训练AAE的对抗网络时，使用的也是这种训练方法。<br>下面再通过一张图来直观的理解一下GAN的训练过程。黑色虚线是真实数据的高斯分布，绿色的线是生成器学习到的伪造分布，蓝色的线是判别器判定为真实图片的概率。（标x的横线代表服从高斯分布x的采样空间，标z的横线代表服从均匀分布的采样空间）同理，对于AAE来说，黑色虚线表示真实数据的分布p(z)，绿线表示潜在变量空间的分布q(z)，蓝色虚线表示经过判别器得到的概率。<br><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g02jkgq2e8j20go05n0t6.jpg" alt="aae"></li></ul><h2 id="AAE训练"><a href="#AAE训练" class="headerlink" title="AAE训练"></a>AAE训练</h2><p><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g02i90btrbj20km0a1gm6.jpg" alt="Adversarial Autoencoders"><br>对抗自编码器使用SGD算法进行训练，每个批训练可以分成两个过程：<br>(1)样本重构阶段<br>SGD更新自编码器的编码器和解码器的参数, 使得损失函数最小化:<br><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g02iev2m59j204k01aq2p.jpg" alt="函数"><br>(2)正则化约束阶段<br>A. 首先更新判别器参数, 用于区分真实样本($p(z)$采样的样本,正样本）、自编码编码层生成样本$z(q(z)$负样本)<br>B. 然后更新生成器参数(自编码器的编码器),以此来提高混淆判别器的能力<br><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g02iey3fbmj20n101qmx5.jpg" alt="函数"></p><h2 id="和VAE比较"><a href="#和VAE比较" class="headerlink" title="和VAE比较"></a>和VAE比较</h2><p>很多时候希望潜变量$z$服从于某个已知的先验分布$p(z)$，比如希望$z$的每个特征相互独立并且符合高斯分布；甚至在机器学习分类问题上，希望这个潜在的表征向量$z$与我们的分类标签有关。<br>AAE和VAE都可以在潜在变量空间生成高斯分布。在变分自编码器中，我们通过一大堆复杂的公式(如变分推理、参数变换等)，进行变分贝叶斯推导，构造变分下界，然后转换成KL散度、重新参数化等构造出损失函数，来使得编码潜变量$z$服从于高斯分布。<br><img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g02igqkc4bj20hk08cq34.jpg" alt="公式"><br><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g02igu0qn4j20j30713yu.jpg" alt="公式"><br>下面是变分自编码器的结构图。<br><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g02igx3arxj20oq0cpmy2.jpg" alt="VAE"><br>对抗自编码的目标也是如此，目的是约束潜在变量空间$Z$服从高斯分布。只不过其不需要一系列复杂的变分推理，而是借助于对抗网络训练的框架，就实现了$Z$的约束，使得$z$服从于高斯分布。<br>下图对抗自编码器和变分自编码器在手写数字集MNIST上的比较。ABCD是AAE、VAE经过数据降维、数据可视化转化成2维的结果图。每种颜色代表相关的标签。A、C表示z经过数据可视化转换成2维高斯生成的图。B、D表示z经过数据可视化转换成10个2维高斯生成的图。左图意在说明，对抗自编码器可以和变分自编码器一样使得z的分布服从高斯分布，甚至对抗自编码器的效果要优于变分自编码器（图中表现出尖锐的转变，潜在变量空间z施加高斯分布后，空间被填满）。E是经过训练的变分自编码器从潜在变量空间z采样，经过解码器生成的手写数字。<br><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g02iij21lhj20im0bmmyl.jpg" alt="实验"></p><h2 id="AAE-p-z-x-选择"><a href="#AAE-p-z-x-选择" class="headerlink" title="AAE $p(z|x)$选择"></a>AAE $p(z|x)$选择</h2><p>$q(z|x)$的3种选择：</p><ol><li>确定性函数：$q(z|x)$是关于$x$的确定性函数。$q(z)$只与真实数据$x$有关；<br><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g02ikbiarcj206e01owea.jpg" alt="公式"></li><li>高斯后验：假设$q(z|x)$是一个高斯分布，其均值和方差由编码器网络预测：$z \sim N(μ,σ)$<br><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g02igx3arxj20oq0cpmy2.jpg" alt="图"></li><li>通用近似后验：$q(z)$由数据分布$p_d(x)$和随机噪声$p_η(η)$决定。<br><img data-src="http://wx1.sinaimg.cn/mw690/9f1bc5a3ly1g02ilobzucj209301n3yc.jpg" alt="图"></li></ol><p>选择不同类型的$q(z|x)$可用于不同的任务。一般情况下后两种的效果要优于第一种。<br>$(z|x)$选择确定性函数情况下，网络必须通过利用数据分布的随机性来匹配$q(z)$和$p(z)$，但是由于数据的经验分布是固定的训练集，这可能产生不太平滑的$q(z)$。在高斯后验或通用近似后验的情况下，网络可以获得额外的随机性来源，可以产生平滑的$q(z)$</p><h2 id="将标签信息纳入对抗网络"><a href="#将标签信息纳入对抗网络" class="headerlink" title="将标签信息纳入对抗网络"></a>将标签信息纳入对抗网络</h2><p><img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g02imygc17j20br08mmxd.jpg" alt="图"><br>可以利用部分或完整标签信息来更加严格地规范自编码器的潜在表示。以10个二维高斯为例，加入标签的目的是强制每种高斯分布代表MNIST的单个标签。标签用one-hot向量表示，每个one-hot向量表示一个数字。加入标签之后训练的结果是每个高斯分布表示的是一类数字。<br><img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g02in1fz62j208x08ddg0.jpg" alt="图"></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>监督对抗自编码器<br> <img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g02ipqrh9gj20ab08cglr.jpg" alt="图"><br> 在上边的对抗自编码器的结构图中，将类标签信息以one-hot向量形式输入解码器，此时潜在变量空间$z$学习的是图片样式信息。解码器利用标签信息和样式信息重构图像，这种结构迫使网络保留独立于隐藏层z的标签的所有信息。<br> <img data-src="http://wx4.sinaimg.cn/mw690/9f1bc5a3ly1g02iptrfvuj20bw0by74v.jpg" alt="图"><br> 上图左图展示了在MNIST数字集上训练这种网络的结果。每一行重构图像的样式相同（例如字体）。</li><li>半监督对抗自编码器<br> <img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g02ipwo8d0j20e50d1jrx.jpg" alt="图"><br> 此时有两个对抗网络,第一个对抗网络用于约束标签类别分布$p(y)$,第二个对抗网络用于约束潜变量$z$的先验分布$p(z)$。自编码器的编码层$q(z,y|x)$用于预测标签$y$、潜变量$z$, 解码层$p(x|z,y)$输入预测标签$y、z$用于重构样本$X$。<br> $p(y) = Cat(y), p(z) = N (z|0,I),  x \sim P(x|z,y)$<br> 训练过程可以分成三个阶段:<br> (1)无监督重构阶段<br> (2)对抗正则化阶段<br> (3)半监督分类阶段:SGD更新$q(y|x)$以此最小化有标签数据交叉熵损失函数<br> <img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g02ipzseo6j20pg084gn4.jpg" alt="图"><br> 半监督对抗自编码器在MNIST和SVHN数据集上的半监督分类结果（错误率）</li><li>对抗自编码器的无监督聚类<br> 对抗自编码器可以以无监督的方式从连续的潜在样式特征中分离出离散的分类特征。下图表示使用具有16个标签MNIST的AAE无监督聚类。每行对应于一个簇，第一个图像是簇头。<br> <img data-src="http://wx2.sinaimg.cn/mw690/9f1bc5a3ly1g02iq445qmj20qa08odh6.jpg" alt="图"><br> <img data-src="http://wx3.sinaimg.cn/mw690/9f1bc5a3ly1g02ispb84oj20ip035mxf.jpg" alt="图"><br> 无监督聚类，对抗自编码器在MNIST数据集上的聚类效果（错误率）并且随着标签数量的增长，AAE聚类的错误率在降低。<br>此外，对抗自编码器还可以用于特征提取、数据降维、数据可视化等方面。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AAE是在自编码器中引入对抗网络，从而限制潜在变量空间$z$服从高斯分布，达到和变分自编码器相同的目的。而相较于变分自编码器、AAE灵活性更好，理论上可以用潜在变量空间$z$的分布来拟合任意分布（离散或连续），并在数据生成、聚类、数据降维、特征提取、数据可视化方面取得了较好的效果。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://blog.csdn.net/hjimce/article/details/54411244" target="_blank" rel="noopener">Adversarial Autoencoders学习笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/27159510" target="_blank" rel="noopener">从PM到GAN</a></li><li><a href="https://www.sohu.com/a/136528577_465975" target="_blank" rel="noopener">教程 | 通过PyTorch实现对抗自编码器</a></li><li><a href="http://blog.csdn.net/yinruiyang94/article/details/77839048" target="_blank" rel="noopener">谈谈Adversarial Autoencoders</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发基础</title>
      <link href="/2019/02/10/00003/"/>
      <url>/2019/02/10/00003/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/O1njhSwcBoTbEvp.jpg" alt="bing"></p><a id="more"></a><h2 id="Producer-and-Consumer"><a href="#Producer-and-Consumer" class="headerlink" title="Producer and Consumer"></a>Producer and Consumer</h2><p>生产者-消费者模型可以通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，同时实现解耦</p><h3 id="生产者消费者-basic"><a href="#生产者消费者-basic" class="headerlink" title="生产者消费者-basic"></a>生产者消费者-basic</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumerBasic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">10</span>; <span class="comment">// 仓库最大容量</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 仓库</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;  <span class="comment">// 生产</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size() == MAX_VALUE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"inability to produce"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(<span class="string">"product"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" has producted a product"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;  <span class="comment">// 消费</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"inability to consume"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.poll();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" has consumed a product"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerAndConsumerBasic pac = <span class="keyword">new</span> ProducerAndConsumerBasic();</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                    pac.produce();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                    pac.consume();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者-Condition"><a href="#生产者消费者-Condition" class="headerlink" title="生产者消费者-Condition"></a>生产者消费者-Condition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumerCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> MAX_VALUE; <span class="comment">// 最大生产量</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">// 产品队列</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">private</span> Condition full = lock.newCondition();  <span class="comment">// 队列满的时候等待</span></span><br><span class="line">    <span class="keyword">private</span> Condition empty = lock.newCondition();  <span class="comment">// 队列空的时候等待</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerAndConsumerCondition</span><span class="params">(<span class="keyword">int</span> MAX_VALUE)</span> </span>&#123; <span class="comment">// 初始化最大生产量</span></span><br><span class="line">        <span class="keyword">this</span>.MAX_VALUE = MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;  <span class="comment">// 生产</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == MAX_VALUE)&#123;</span><br><span class="line">                System.out.println(<span class="string">"queue's size is "</span> + queue.size() + <span class="string">", inability to produce"</span>);</span><br><span class="line">                full.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(<span class="string">"product"</span>);</span><br><span class="line">            System.out.println(<span class="string">"producting "</span> + queue.size());</span><br><span class="line">            empty.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;  <span class="comment">// 消费</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"queue's size is "</span> + queue.size() + <span class="string">", inability to consume"</span>);</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.poll();</span><br><span class="line">            System.out.println(<span class="string">"consuming "</span> + queue.size());</span><br><span class="line">            full.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerAndConsumerCondition pac = <span class="keyword">new</span> ProducerAndConsumerCondition(<span class="number">10</span>);</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                pac.produce();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                pac.consume();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown(); <span class="comment">// 不写这句会一直等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者-BlockingQueue"><a href="#生产者消费者-BlockingQueue" class="headerlink" title="生产者消费者-BlockingQueue"></a>生产者消费者-BlockingQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumerBlockingQueue2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>); <span class="comment">// 设置阻塞队列大小为10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> d = (<span class="keyword">int</span>) (Math.random()*<span class="number">10000</span>);</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.name + <span class="string">" is producting "</span> + d);</span><br><span class="line">                    queue.put(d);</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.name + <span class="string">" has producted "</span> + d);</span><br><span class="line">                    System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.name + <span class="string">" is consuming"</span>);</span><br><span class="line">                    <span class="keyword">int</span> d = queue.take();</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.name + <span class="string">" has consumed "</span> + d);</span><br><span class="line">                    System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerAndConsumerBlockingQueue2 pc = <span class="keyword">new</span> ProducerAndConsumerBlockingQueue2();</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        service.execute(pc.<span class="keyword">new</span> Producer(<span class="string">"producer 1"</span>));</span><br><span class="line">        service.execute(pc.<span class="keyword">new</span> Producer(<span class="string">"producer 2"</span>));</span><br><span class="line">        service.execute(pc.<span class="keyword">new</span> Consumer(<span class="string">"consumer 1"</span>));</span><br><span class="line">        service.execute(pc.<span class="keyword">new</span> Consumer(<span class="string">"consumer 2"</span>));</span><br><span class="line">        service.execute(pc.<span class="keyword">new</span> Consumer(<span class="string">"consumer 3"</span>));</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者-PipedStream"><a href="#生产者消费者-PipedStream" class="headerlink" title="生产者消费者-PipedStream"></a>生产者消费者-PipedStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumerStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要在一个线程中同时使用PipedInpuStream和PipedOutputStream，这会造成死锁</span></span><br><span class="line">    <span class="keyword">private</span> PipedInputStream pis;  <span class="comment">// 输入流，读数据</span></span><br><span class="line">    <span class="keyword">private</span> PipedOutputStream pos;  <span class="comment">// 输出流，写数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerAndConsumerStream</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pis = <span class="keyword">new</span> PipedInputStream(size);</span><br><span class="line">            pos = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">            pis.connect(pos); <span class="comment">// 只能调用一次</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                pos.write(count.getAndIncrement());</span><br><span class="line">                pos.flush();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">" has produced a product "</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pis.close();</span><br><span class="line">                pos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                pis.read();</span><br><span class="line">                count.getAndDecrement();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">" has consumed a product "</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pis.close();</span><br><span class="line">                pos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerAndConsumerStream pac = <span class="keyword">new</span> ProducerAndConsumerStream(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pac.consume();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pac.produce();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reader-and-Writer"><a href="#Reader-and-Writer" class="headerlink" title="Reader and Writer"></a>Reader and Writer</h2><h3 id="读写锁-读者写者问题"><a href="#读写锁-读者写者问题" class="headerlink" title="读写锁-读者写者问题"></a>读写锁-读者写者问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReaderAndWriter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;  <span class="comment">// 共享数据</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();  <span class="comment">// 锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;  <span class="comment">// 读</span></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" before read: "</span> + <span class="keyword">this</span>.data);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" after read: "</span> + <span class="keyword">this</span>.data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object data)</span> </span>&#123;  <span class="comment">// 写</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" before write: "</span> + <span class="keyword">this</span>.data);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" after write: "</span> + <span class="keyword">this</span>.data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReaderAndWriter raw = <span class="keyword">new</span> ReaderAndWriter();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                        raw.read();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                        raw.write(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁-缓存"><a href="#读写锁-缓存" class="headerlink" title="读写锁-缓存"></a>读写锁-缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;()); <span class="comment">// 线程安全</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(); <span class="comment">// 读写锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        lock.readLock().lock();  <span class="comment">// 读锁</span></span><br><span class="line">        <span class="keyword">if</span>(map.get(key) == <span class="keyword">null</span>)&#123;  <span class="comment">// 如果没有缓存写数据</span></span><br><span class="line">            lock.readLock().unlock();  <span class="comment">// 释放读锁</span></span><br><span class="line">            lock.writeLock().lock();  <span class="comment">// 开启写锁</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(key) == <span class="keyword">null</span>) &#123;  <span class="comment">// 双重检查</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is writing to cache for "</span> + key);</span><br><span class="line">                map.put(key, <span class="string">"value "</span> + System.currentTimeMillis());  <span class="comment">// 写数据</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" has writed to cache for "</span> + key);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.readLock().lock();  <span class="comment">// 开启读锁</span></span><br><span class="line">            lock.writeLock().unlock();  <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        Object value = map.get(key);  <span class="comment">// 读数据</span></span><br><span class="line">        lock.readLock().unlock();  <span class="comment">// 释放写锁</span></span><br><span class="line">        <span class="keyword">return</span> value;  <span class="comment">// 返回数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cache cache = <span class="keyword">new</span> Cache();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Object value = cache.getData(<span class="string">"key one"</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" gets key one's cache: "</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Object value = cache.getData(<span class="string">"key two"</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" gets key two's cache: "</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dead-block"><a href="#Dead-block" class="headerlink" title="Dead block"></a>Dead block</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadBock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="keyword">true</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="keyword">false</span>)).start();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> tag;</span><br><span class="line"></span><br><span class="line">    MyRunnable(<span class="keyword">boolean</span> tag)&#123;</span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(MyBock.lock_a)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" : lock_a"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span>(MyBock.lock_b)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" : lock_b"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(MyBock.lock_b)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" : lock_b"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span>(MyBock.lock_a)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" : lock_a"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock_a = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock_b = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CyclicBarrier可以使不同的线程彼此等待，在不同的线程都执行完了后再执行下面的程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);  <span class="comment">// 设置3个线程等待，都执行完再继续执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" is coming, "</span></span><br><span class="line">                        + <span class="string">" one"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    cb.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" is coming, "</span></span><br><span class="line">                        + <span class="string">" two"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    cb.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" is coming, "</span></span><br><span class="line">                        + <span class="string">" three"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    cb.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Concurrent </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率分布的距离</title>
      <link href="/2019/02/10/00002/"/>
      <url>/2019/02/10/00002/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/7RkLEzFOPjx9uNf.jpg" alt="AcadiaBlueberries_ZH-CN6014510748_1920x1080.jpg"></p><a id="more"></a><blockquote><p>机器学习中度量两个概率分布距离的方法总结：卡方检验 / 交叉熵 / F散度 / W距离 / MMD距离</p></blockquote><h2 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h2><p>$$<br>\chi^{2}=\sum\frac{\left ( A-E \right )^{2}}{E}=\sum_{i=1}^{k}\frac{\left ( A_{i}-E_{i} \right )^{2}}{E_{i}}=\sum_{i=1}^{k}\frac{\left ( A_{i}-n<em>p_{i} \right )^{2}}{n</em>p_{i}}<br>$$</p><p>其中，$A_i$为观察频数，$E_i$为期望频数，期望频数$E_i$ = 总频数$n$ * 期望频率$p_i$。卡方检验经常用来检验某一种观测分布是不是符合某一类典型的理论分布（如二项分布，正态分布等) 。$\chi ^{2}$越小，两个分布越接近。</p><h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>$$<br>H(P,Q)=-\sum_{x}^{ }P(x)log Q(x)<br>$$</p><p>其中，$P$为真实分布，$Q$为非真实分布，$H(P,Q)$越小，两个分布越接近。</p><h2 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h2><p>$$<br>D_{KL}(P||Q)=\sum_{x}^{ }P(x)log \frac{P(x)}{Q(x)}<br>$$</p><p>其中，$P$为真实分布，$Q$为非真实分布，$D_{KL}(P||Q)$越小，两个分布越接近。KL散度具有非负性和不对称性。</p><h2 id="JS散度"><a href="#JS散度" class="headerlink" title="JS散度"></a>JS散度</h2><p>$$<br>D_{JS}(P||Q)=\frac{1}{2}D_{KL}(P||\frac{P+Q}{2})+\frac{1}{2}D_{KL}(Q||\frac{P+Q}{2})<br>$$</p><p>其中，$P$为真实分布，$Q$为非真实分布，$D_{JS}(P||Q)$越小，两个分布越接近。JS散度具有非负性和对称性。</p><h2 id="Hellinger距离"><a href="#Hellinger距离" class="headerlink" title="Hellinger距离"></a>Hellinger距离</h2><p>$$<br>H(P,Q)=\frac{1}{\sqrt{2}}\left | \sqrt{P}-\sqrt{Q} \right |_2<br>$$</p><p>其中，$P$为真实分布，$Q$为非真实分布，$H(P,Q)$越小，两个分布越接近。</p><h2 id="F散度"><a href="#F散度" class="headerlink" title="F散度"></a>F散度</h2><p>$$<br>D_{f}(P||Q)=\sum_{x}^{ }Q(x)f(\frac{P(x)}{Q(x)})<br>$$</p><p>其中，$P$为真实分布，$Q$为非真实分布，$D_{f}(P||Q)$越小，两个分布越接近。F散度具有非负性。</p><table><thead><tr><th align="center">Divergence</th><th align="center">f(t)</th></tr></thead><tbody><tr><td align="center">KL-divergence</td><td align="center">$tlogt$</td></tr><tr><td align="center">reverse KL-divergence</td><td align="center">$-logt$</td></tr><tr><td align="center">Hellinger distance</td><td align="center">$(\sqrt t -1)^2, 2(1-\sqrt t)$</td></tr><tr><td align="center">Total variation distance</td><td align="center">$\frac{1}{2}(t-1)$</td></tr><tr><td align="center">$\chi ^{2}$-divergence</td><td align="center">$(t-1)^2, t^2-1$</td></tr></tbody></table><h2 id="巴氏距离"><a href="#巴氏距离" class="headerlink" title="巴氏距离"></a>巴氏距离</h2><p>$$<br>D_B(P,Q)=-ln(BC(P,Q))<br>$$</p><p>其中$BC(P,Q)$是Bhattacharyya系数：$BC(P,Q)=\sum_{x}^{ } \sqrt{P(x)Q(x)}$</p><h2 id="MMD距离（最大均值差异）"><a href="#MMD距离（最大均值差异）" class="headerlink" title="MMD距离（最大均值差异）"></a>MMD距离（最大均值差异）</h2><p>$$<br>MMD(F,X,Y)=[\frac{1}{m^2}\sum_{i,j=1}^{m}k(x_i,x_j)-\frac{2}{mn}\sum_{i,j=1}^{m,n}k(x_i,y_j)+\frac{1}{n^2}\sum_{i,j=1}^{n}k(y_i,y_j)]^\frac{1}{2}<br>$$</p><p>其中，$k(·)$是核函数，用于把原变量映射到高维空间中。$X,Y$表示两种分布的样本，$F$表示函数集。基于两个分布的样本，通过寻找在样本空间上的映射函数$k$，求不同分布的样本在$k$上的函数值的均值，通过把两个均值作差可以得到两个分布对应于$k$的均值差异。寻找一个$k$使得这个均值差异有最大值，就得到了MMD。最后取MMD作为检验统计量（test statistic），从而判断两个分布是否相同。如果这个值足够小，就认为两个分布相同，否则就认为它们不相同。更加简单的理解就是：求两堆数据在高维空间中的均值的距离。</p><h2 id="Wasserstein距离-EM距离"><a href="#Wasserstein距离-EM距离" class="headerlink" title="Wasserstein距离(EM距离)"></a>Wasserstein距离(EM距离)</h2><p>$$<br>W(P,Q)=\inf_{\gamma \sim \prod (P,Q)}  E_{(x,y)\sim \gamma }[\left | x-y \right |]<br>$$</p><p>其中，$\prod (P,Q)$是$P$和$Q$是组合起来的所有可能的联合分布的集合，反过来说$\prod (P,Q)$中每一个分布的边缘分布都是$P$和$Q$。对于每一个可能的联合分布$\gamma$而言，可以从中采样$(x,y)\sim \gamma$得到一个真实样本$x$和一个生成样本$y$，并算出这对样本的距离$\left | x-y \right |$，所以可以计算该联合分布$\gamma$下样本对距离的期望值$E_{(x,y)\sim \gamma }[\left | x-y \right |]$。 在所有可能的联合分布中能够对这个期望值取到的下界$\inf_{\gamma \sim \prod (P,Q)}E_{(x,y)\sim \gamma }[\left | x-y \right |]$，就定义为Wasserstein距离。</p><p>Wasserstein距离相比KL散度、JS散度的优越性在于，即便两个分布没有重叠，Wasserstein距离仍然能够反映它们的远近。</p><p>根据Kantorovich-Rubinstein对偶原理，可以得到Wasserstein距离的等价形式：</p><p>$$<br>W(P, Q)=\frac{1}{K} \sup_{||f||<em>L\leq K} \mathbb E</em>{x \sim P}[f(x)]- \mathbb E_{x \sim Q}[f(x)]<br>$$</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.cnblogs.com/denny402/p/7050779.html" target="_blank" rel="noopener">概率分布之间的距离度量以及python实现(三)</a></li><li><a href="https://www.cnblogs.com/denny402/p/7054950.html" target="_blank" rel="noopener">概率分布之间的距离度量以及python实现(四)</a></li><li><a href="https://blog.csdn.net/snowdroptulip/article/details/78770088" target="_blank" rel="noopener">卡方检验和卡方分布</a></li><li><a href="https://zhuanlan.zhihu.com/p/25071913" target="_blank" rel="noopener">令人拍案叫绝的Wasserstein GAN</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decison Tree</title>
      <link href="/2019/02/10/00001/"/>
      <url>/2019/02/10/00001/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/02/15/RGcQ9fboCez3d7y.jpg" alt="bing"></p><a id="more"></a><blockquote><p>决策树是一种用于分类/回归的机器学习算法，基于树结构来进行决策。一棵决策树包含根结点、内部结点和叶结点。根结点包含样本全集，内部结点对应属性，叶结点对应决策结果。</p></blockquote><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：训练集：D=&#123;(x_1,y_1),(x_2,y_2),...,(x_m,y_m)&#125; ，属性集：A=&#123;a_1,a_2,...,a_d&#125;</span></span><br><span class="line"><span class="comment"># 输出：以node为根结点的决策树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TreeGenerate</span><span class="params">(D,A)</span>:</span></span><br><span class="line">    生成结点node;</span><br><span class="line">    <span class="keyword">if</span> D中样本属于同类C:</span><br><span class="line">        将node标记为类别C; <span class="comment">#属于同类，无需划分</span></span><br><span class="line">    <span class="keyword">if</span> A为空 <span class="keyword">or</span> D中样本在A上取值相同:</span><br><span class="line">         将node标记为叶结点，类别标记为D中样本最多的类; <span class="comment">#无法划分，类别设定为当前结点最多的类</span></span><br><span class="line">    从A中选取最优划分属性a; <span class="comment"># 不同选取策略产生不同决策树算法</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a[<span class="string">'value'</span>]:</span><br><span class="line">        为node生成一个分支; <span class="comment"># 属性的取值</span></span><br><span class="line">        D_v = &#123;a[<span class="string">'value'</span>]:a[<span class="string">'value'</span>]=a_v&#125; <span class="comment"># 划分子集</span></span><br><span class="line">        <span class="keyword">if</span> D_v为空:</span><br><span class="line">            将分支结点标记为叶结点，类别标记为D中样本最多的类; <span class="comment"># 无法划分，类别设定为父结点最多的类</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            TreeGenerate(D_v,A\&#123;a&#125;); <span class="comment"># 递归生成决策树</span></span><br></pre></td></tr></table></figure><h2 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h2><ol><li><p>信息增益（ID3决策树算法）<br> $$<br> Ent(D)=-\sum_{k=1}^{\left | \gamma  \right |}p_klog_2p_k<br> $$</p><p> $$<br> Gain(D,a) = Ent(D)-\sum_{v=1}^{V}\frac{\left | D^v \right |}{\left | D \right |}Ent(D^v)<br> $$</p><p> $Ent(V)$ 表示信息熵，是度量样本集合纯度最常用的一种指标。信息熵越小，集合纯度越高。$Gain(D,a)$ 表示信息增益。信息增益越大，意味着使用属性$a$来进行划分所获得的集合纯度越高。</p><p><strong>缺点</strong>：信息增益对可取值数目较多的属性有所偏好。</p></li><li><p>增益率（C4.5决策树算法）<br> $$<br> Gain_ratio(D,a) = \frac{Gain(D,a)}{-\sum_{v=1}^{V}\frac{\left | D^v \right |}{\left | D \right |}log_2\frac{\left | D^v \right |}{\left | D \right |}}<br> $$<br> $IV(a)={-\sum_{v=1}^{V}\frac{\left | D^v \right |}{\left | D \right |}log_2\frac{\left | D^v \right |}{\left | D \right |}}$称为$a$的固有值，$a$的取值数目越多，$IV(a)$越大。$Gain_ratio(D,a)$表示增益率，增益率越大，集合纯度越高。</p><p> <strong>缺点</strong>：增益率对可取值数目较少的属性有所偏好。（C4.5算法没有直接使用增益率，而是先从候选属性中找出信息增益大于平均值的属性，再从中找出增益率最高的作为最优化分属性，这是一种折中）</p></li><li><p>基尼指数（CART决策树算法）</p><p> $$<br> Gini(D) = 1 - \sum_{k=1}^{\left | \gamma  \right |}p_k^2<br> $$</p><p> $$<br> Gini_index(D,a) = \sum_{v=1}^{V}\frac{\left | D^v \right |}{\left | D \right |}Gini(D^v)<br> $$</p><p> $Gini(D)$表示基尼指数，$Gini_index(D,a)$表示属性$a$的基尼指数。基尼指数越小，集合纯度越高。</p></li></ol><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>剪枝是决策树算法处理过拟合问题的主要手段。分为预剪枝和后剪枝，预剪枝是在树的生成过程中进行剪枝，后剪枝是生成决策树之后再进行剪枝。剪枝的方法是判断剪枝前后模型的泛化能力是否有提升，泛化能力的度量即为性能评估方法，如准确率等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
